<!DOCTYPE html>
<html style="zoom: 125%">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Construct simple graphs.">
    <meta name="author" content="Avinash Pandey">
    <title>Rascunho de grafo</title>
    <link rel="shortcut icon" href="/favicon.5c4f16e7.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.5c4f16e7.ico" type="image/x-icon">
    <link rel="stylesheet" href="/index.cb41b962.css">
    <link rel="stylesheet" href="/index.36d8eb91.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</head>

<body>
    <div id="container" class="background-color" style="padding-left: 32px; padding-top: 8px;">

        <div class="row">
            <div class="col-md-4 col-sm-12">
                <div class="btn-group">
                    <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" id="dropdownMenuButton1" data-bs-toggle="dropdown" aria-expanded="false">
                          Informações do grafo
                    </button>
                    <div class="dropdown-menu background-color" aria-labelledby="dropdownMenuButton1">
                        <h6 class="dropdown-header">Primeiros conceitos</h6>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_groups">
                            <label class="form-check-label" for="flexCheckDefault">
                                Conjuntos
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_adjacency-matrix">
                            <label class="form-check-label" for="flexCheckDefault">
                                Matriz de adjacência
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_trivial">
                            <label class="form-check-label" for="flexCheckDefault">
                                Trivial
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_complete-graph">
                            <label class="form-check-label" for="flexCheckDefault">
                                Grafo completo
                            </label>
                        </div>
                        <h6 class="dropdown-header">Grau</h6>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_min-degree">
                            <label class="form-check-label" for="flexCheckDefault">
                                Grau mínimo
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_max-degree">
                            <label class="form-check-label" for="flexCheckDefault">
                                Grau máximo
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_regular-graph">
                            <label class="form-check-label" for="flexCheckDefault">
                                K-regular
                            </label>
                        </div>
                        <h6 class="dropdown-header">Coloração/multipartição</h6>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_bipartite">
                            <label class="form-check-label" for="flexCheckDefault">
                                Bipartido
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_chromatic-color">
                            <label class="form-check-label" for="flexCheckDefault">
                                Número crômatico
                            </label>
                        </div>

                        <!-- <h6 class="dropdown-header">Ciclos</h6>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_cycles">
                            <label class="form-check-label" for="flexCheckDefault">
                                Número de ciclos
                            </label>
                        </div> -->
                        <h6 class="dropdown-header">Árvores</h6>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_trees">
                            <label class="form-check-label" for="flexCheckDefault">
                                Árvores
                            </label>
                        </div>

                        <h6 class="dropdown-header">Conectividade</h6>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="property_components">
                            <label class="form-check-label" for="flexCheckDefault">
                                Componentes
                            </label>
                        </div>
                    </div>
                </div>
                <div class="card text-dark bg-light mb-3 margin-top output-card-display" id="output-groups-card">
                    <!-- <div class="card-header">Conjuntos</div> -->
                    <div class="card-body">
                        <div id="output-groups">
                        </div>
                    </div>
                </div>
                <div class="card text-dark bg-light mb-3 margin-top output-card-display" id="output-degree-card">
                    <div class="card-body">
                        <div id="output-degree">
                        </div>
                    </div>
                </div>
                <div class="card text-dark bg-light mb-3 margin-top output-card-display" id="output-coloring-card">
                    <div class="card-body">
                        <div id="output-coloring">
                        </div>
                    </div>
                </div>
                <div class="card text-dark bg-light mb-3 margin-top output-card-display" id="output-cycles-card">
                    <div class="card-body">
                        <div id="output-cycles">
                        </div>
                    </div>
                </div>
                <div class="card text-dark bg-light mb-3 margin-top output-card-display" id="output-trees-card">
                    <div class="card-body">
                        <div id="output-trees">
                        </div>
                    </div>
                </div>
                <div class="card text-dark bg-light mb-3 margin-top output-card-display" id="output-conectivity-card">
                    <div class="card-body">
                        <div id="output-conectivity">
                        </div>
                    </div>
                </div>
                <!-- <div id="svg-output">
                    <div id="output-groups" class="graph-output">
                    </div>

                </div> -->
            </div>
            <div class="col-md-8 col-sm-12">
                <div class="row d-flex justify-content-between" id="properties" style="margin-left: 0px">
                    <div>
                        <button type="button" class="btn btn-outline-secondary" id="clear">Limpar</button>

                        <input id="toggle-vertex-id-input" type="checkbox" class="btn-check" autocomplete="off">
                        <label class="btn btn-outline-light" for="toggle-vertex-id-input">
                            <i id="toggle-vertex-id-icon" class="bi-eye" style="font-size: 1rem; color: black;"></i>
                        </label>
                    </div>
                    <div>

                        <button type="button" class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#importModal">Importar</button>
                        <button type="button" class="btn btn-outline-secondary" id="export">Exportar</button>
                    </div>
                </div>
                <div id="svg-wrap"></div>
                <div class="card  mb-3 margin-top card-bg-info" style="width: 900px;">
                    <!-- <div class="card-header">Conjuntos</div> -->
                    <div class="card-body">
                        <div>
                            Pressione o
                            <b>Botão esquerdo do mouse</b> no espaço em branco para adicionar um novo <b>vértice</b>.
                        </div>
                        <br>
                        <div>
                            Pressione e segure o
                            <b>Botão esquerdo do mouse</b> enquanto arrasta a linha de um vértice para outro para criar uma nova <b>aresta</b>.
                        </div>
                        <br>
                        <div>
                            Pressione o
                            <b>Botão direito do mouse</b> em um vértice para <b>remover o vértice</b> do grafo.
                        </div>
                        <br>
                        <div>
                            Pressione o
                            <b>Botão direito do mouse</b> em uma aresta para <b>remover a aresta</b> do grafo.
                        </div>
                    </div>
                </div>

                <div class="card  mb-3 margin-top card-bg-info" style="width: 900px;">
                    <!-- <div class="card-header">Conjuntos</div> -->
                    <div class="card-body">
                        <div>
                            Pressione
                            <b>Ctrl + botão esquerdo do mouse</b> em um vértice para obter mais informações daquele vértice.
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>
    <!-- Modal -->
    <div class="modal" id="importModal" tabindex="-1" aria-labelledby="importModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="importModalLabel">Importar</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <input type="file" id="inputElement">
                </div>
                <div class="modal-footer">
                    <button id="modal-close-btn" type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
                </div>
            </div>
        </div>
    </div>
</body>

<script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"5pDwl":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "5e7f3a710f742ab0";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    var parents = getParents(module.bundle.root, id); // If no parents, the asset is new. Prevent reloading the page.
    if (!parents.length) return true;
    return parents.some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"iglst":[function(require,module,exports) {
var _graphJs = require("./src/graph.js");

},{"./src/graph.js":"c5U8Z"}],"c5U8Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PropertyType", ()=>PropertyType
);
parcelHelpers.export(exports, "Graph", ()=>Graph
);
var _underscore = require("underscore");
var _underscoreDefault = parcelHelpers.interopDefault(_underscore);
var _graphProperties = require("./graph_properties");
const INIT_VERTICES = [
    {
        id: 0
    },
    {
        id: 1
    },
    {
        id: 2
    },
    {
        id: 3
    },
    {
        id: 4
    }, 
];
const INIT_EDGES = [
    {
        id: 0,
        source: 0,
        target: 1
    },
    {
        id: 1,
        source: 0,
        target: 2
    },
    {
        id: 2,
        source: 0,
        target: 3
    },
    {
        id: 3,
        source: 0,
        target: 4
    },
    {
        id: 4,
        source: 1,
        target: 2
    },
    {
        id: 5,
        source: 1,
        target: 3
    },
    {
        id: 6,
        source: 1,
        target: 4
    },
    {
        id: 7,
        source: 2,
        target: 3
    },
    {
        id: 8,
        source: 2,
        target: 4
    },
    {
        id: 9,
        source: 3,
        target: 4
    }, 
];
const PropertyType = {
    GROUPS: "GROUPS",
    ADJACENCY_MATRIX: "ADJACENCY_MATRIX",
    TRIVIAL: "TRIVIAL",
    COMPLETE_GRAPH: "COMPLETE_GRAPH",
    MIN_DEGREE: "MIN_DEGREE",
    MAX_DEGREE: "MAX_DEGREE",
    REGULAR_GRAPH: "REGULAR_GRAPH",
    BIPARTITE: "BIPARTITE",
    CHROMATIC_COLOR: "CHROMATIC_COLOR",
    COLORING: "COLORING",
    CYCLES: "CYCLES",
    TREES: "TREES",
    COMPONENTS: "COMPONENTS"
};
class Graph {
    graphVertices = INIT_VERTICES;
    graphEdges = INIT_EDGES;
    propertiesToShow = [];
    chromaticNumber;
    // Methods
    restartGraph;
    toggleColors;
    toggleVertexId;
    // utils
    isEdgeOfVertex = (vertex, edge)=>{
        // console.log("isEdgeOfVertex", { vertex, edge, includes: vertex.edges.includes(edge) })
        return (vertex.id == edge.source.id || vertex.id == edge.target.id) && (vertex.edges == null || !vertex.edges.map((it)=>it.source
        ).includes(edge) || !vertex.edges.map((it)=>it.target
        ).includes(edge));
    };
    // mappers
    mapNodeToVertex = (node)=>({
            id: node['id'],
            degree: 0,
            edges: []
        })
    ;
    mapLinkToEdge = (link)=>({
            id: link['id'],
            source: link['source'],
            target: link['target']
        })
    ;
    addEdge(link) {
        // console.log("addEdge", { link, graphVertices: this.graphVertices });
        var newEdge = this.mapLinkToEdge(link);
        this.graphEdges = [
            ...this.graphEdges,
            newEdge, 
        ];
        this.graphVertices = this.graphVertices.map((it)=>this.isEdgeOfVertex(it, newEdge) ? {
                ...it,
                degree: it.degree + 1,
                edges: [
                    ...it.edges || [],
                    newEdge
                ]
            } : it
        );
    // console.log("addEdge end", { newEdge, graphEdges: this.graphEdges, graphVertices: this.graphVertices });
    }
    // Main methods
    showVertexInfo(node) {
        if (window.div.style("opacity") > 0 && window.div.attr("id") == node.id) return;
        var vertex1 = this.graphVertices.find((vertex)=>vertex["id"] == node["id"]
        );
        window.div.html(_graphProperties.getVertexId(vertex1) + _graphProperties.getVertexDegree(vertex1) + _graphProperties.getVertexNeighborhood(vertex1)).attr("id", function() {
            return vertex1.id.toString();
        }).style("margin-left", node.x + 20 + "px").style("margin-top", node.y - 12 + "px");
        MathJax.Hub.Queue([
            "Typeset",
            MathJax.Hub
        ]);
        window.div.transition().duration(200).style("z-index", 0).style("opacity", 0.98);
    }
    hideVertexInfo() {
        window.div.transition().duration(200).style("z-index", -1).style("opacity", 0);
    }
    hasProperty(property) {
        return this.propertiesToShow.find((it)=>it == property
        );
    }
    showMathJaxOutput(content, componentId) {
        try {
            if (content.length > 0) {
                document.getElementById(componentId + "-card").classList.remove("output-card-display");
                document.getElementById(componentId).textContent = content;
                if (MathJax != null) MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub
                ]);
            } else {
                document.getElementById(componentId + "-card").classList.add("output-card-display");
                document.getElementById(componentId).textContent = content;
                if (MathJax != null) MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub
                ]);
            }
        } catch (e) {
        // 
        }
    }
    showGraphInfo() {
        var contentsToShow1 = "";
        if (this.hasProperty(PropertyType.GROUPS) || this.hasProperty(PropertyType.ADJACENCY_MATRIX) || this.hasProperty(PropertyType.COMPLETE_GRAPH) || this.hasProperty(PropertyType.TRIVIAL)) contentsToShow1 += _graphProperties.sectionHeader("Primeiros conceitos");
        if (this.hasProperty(PropertyType.GROUPS)) contentsToShow1 += _graphProperties.showGroups(this.graphVertices, this.graphEdges);
        if (this.hasProperty(PropertyType.ADJACENCY_MATRIX)) contentsToShow1 += _graphProperties.showAdjacencyMatrix();
        if (this.hasProperty(PropertyType.TRIVIAL)) contentsToShow1 += _graphProperties.showTrivialGraph();
        if (this.hasProperty(PropertyType.COMPLETE_GRAPH)) contentsToShow1 += _graphProperties.showCompleteGraph();
        this.showMathJaxOutput(contentsToShow1, "output-groups");
        var contentsToShow2 = "";
        if (this.hasProperty(PropertyType.MIN_DEGREE) || this.hasProperty(PropertyType.MAX_DEGREE) || this.hasProperty(PropertyType.REGULAR_GRAPH)) contentsToShow2 += _graphProperties.sectionHeader("Grau");
        if (this.hasProperty(PropertyType.MIN_DEGREE)) contentsToShow2 += _graphProperties.showGraphMinDegree();
        if (this.hasProperty(PropertyType.MAX_DEGREE)) contentsToShow2 += _graphProperties.showGraphMaxDegree();
        if (this.hasProperty(PropertyType.REGULAR_GRAPH)) contentsToShow2 += _graphProperties.showGraphRegular();
        this.showMathJaxOutput(contentsToShow2, "output-degree");
        var contentsToShow3 = "";
        if (this.hasProperty(PropertyType.BIPARTITE) || this.hasProperty(PropertyType.CHROMATIC_COLOR) || this.hasProperty(PropertyType.COLORING)) contentsToShow3 += _graphProperties.sectionHeader("Coloração/multipartição");
        else _graphProperties.resetColoring(this.graphVertices);
        if (this.hasProperty(PropertyType.BIPARTITE)) {
            _graphProperties.greedyColoring(this.graphVertices);
            contentsToShow3 += _graphProperties.showBiparte(window.graph.chromaticNumber == 2);
        }
        if (this.hasProperty(PropertyType.CHROMATIC_COLOR)) {
            _graphProperties.greedyColoring(this.graphVertices);
            contentsToShow3 += _graphProperties.showChromaticNumber(window.graph.chromaticNumber);
        }
        // if (this.hasProperty(PropertyType.COLORING)) {
        //     GraphProperties.greedyColoring(this.graphVertices);
        //     contentsToShow3 += GraphProperties.showBiparte(window.graph.chromaticNumber == 2);
        //     contentsToShow3 += GraphProperties.showChromaticNumber(window.graph.chromaticNumber);
        // } else {
        //     GraphProperties.resetColoring(this.graphVertices);
        // }
        this.showMathJaxOutput(contentsToShow3, "output-coloring");
        var contentsToShow4 = "";
        if (this.hasProperty(PropertyType.CYCLES)) contentsToShow4 += _graphProperties.sectionHeader("Ciclos");
        if (this.hasProperty(PropertyType.CYCLES)) contentsToShow4 += _graphProperties.showCycles();
        this.showMathJaxOutput(contentsToShow4, "output-cycles");
        var contentsToShow5 = "";
        if (this.hasProperty(PropertyType.TREES)) contentsToShow5 += _graphProperties.sectionHeader("Árvores");
        if (this.hasProperty(PropertyType.TREES)) contentsToShow5 += _graphProperties.showTrees();
        this.showMathJaxOutput(contentsToShow5, "output-trees");
        var contentsToShow6 = "";
        if (this.hasProperty(PropertyType.COMPONENTS)) contentsToShow6 += _graphProperties.sectionHeader("Conectividade");
        if (this.hasProperty(PropertyType.COMPONENTS)) contentsToShow6 += _graphProperties.checkComponents();
        this.showMathJaxOutput(contentsToShow6, "output-conectivity");
        // console.log("showGraphInfo final", contentsToShow);
        try {
            document.getElementById("svg-output").textContent = contentsToShow;
            if (MathJax != null) MathJax.Hub.Queue([
                "Typeset",
                MathJax.Hub
            ]);
        } catch (e) {
        // 
        }
    }
    showGraphInfoThrottle = _underscoreDefault.default.throttle(this.showGraphInfo, 500);
    refresh(nodes, links) {
        // var a = nodes.length != this.graphVertices.length;
        // var b = links.length != this.graphEdges.length;
        // var c = this.graphVertices.filter((e) => e.edges == null || e.edges.length == 0).length > 0;
        if (nodes.length != this.graphVertices.length || links.length != this.graphEdges.length || this.graphVertices.filter((e)=>e.edges == null
        ).length > 0) {
            this.graphVertices = nodes.map((it)=>this.mapNodeToVertex(it)
            );
            this.graphEdges = [];
            links.map((it)=>{
                this.addEdge(it);
            });
            // if (nodes.length != this.graphVertices.length || links.length != this.graphEdges.length) {
            //     console.log("refresh/if", { nodes, links, graphEdges: this.graphEdges, graphVertices: this.graphVertices })
            //     this.graphVertices = vertices;
            //     this.graphEdges = edges;
            // }
            this.showGraphInfoThrottle();
        }
    // console.log("refresh end", { graphEdges: this.graphEdges, graphVertices: this.graphVertices });
    }
    importGraph(vertices, edges) {
        // console.log("importGraph", vertices, edges);
        this.graphVertices = vertices;
        this.graphEdges = edges;
        this.restartGraph();
    }
}
window.graph = new Graph();

},{"underscore":"dga04","./graph_properties":"6Ena2","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dga04":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// ESM Exports
// ===========
// This module is the package entry point for ES module users. In other words,
// it is the module they are interfacing with when they import from the whole
// package instead of from a submodule, like this:
//
// ```js
// import { map } from 'underscore';
// ```
//
// The difference with `./index-default`, which is the package entry point for
// CommonJS, AMD and UMD users, is purely technical. In ES modules, named and
// default exports are considered to be siblings, so when you have a default
// export, its properties are not automatically available as named exports. For
// this reason, we re-export the named exports in addition to providing the same
// default export as in `./index-default`.
parcelHelpers.export(exports, "default", ()=>_indexDefaultJsDefault.default
);
var _indexDefaultJs = require("./index-default.js");
var _indexDefaultJsDefault = parcelHelpers.interopDefault(_indexDefaultJs);
var _indexJs = require("./index.js");
parcelHelpers.exportAll(_indexJs, exports);

},{"./index-default.js":"cVW5k","./index.js":"aPH2r","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cVW5k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Default Export
// ==============
// In this module, we mix our bundled exports into the `_` object and export
// the result. This is analogous to setting `module.exports = _` in CommonJS.
// Hence, this module is also the entry point of our UMD bundle and the package
// entry point for CommonJS and AMD users. In other words, this is (the source
// of) the module you are interfacing with when you do any of the following:
//
// ```js
// // CommonJS
// var _ = require('underscore');
//
// // AMD
// define(['underscore'], function(_) {...});
//
// // UMD in the browser
// // _ is available as a global variable
// ```
var _indexJs = require("./index.js");
// Add all of the Underscore functions to the wrapper object.
var _ = _indexJs.mixin(_indexJs);
// Legacy Node.js API.
_._ = _;
exports.default = _;

},{"./index.js":"aPH2r","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aPH2r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Named Exports
// =============
//     Underscore.js 1.13.1
//     https://underscorejs.org
//     (c) 2009-2021 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
// Baseline setup.
parcelHelpers.export(exports, "VERSION", ()=>_setupJs.VERSION
);
parcelHelpers.export(exports, "restArguments", ()=>_restArgumentsJsDefault.default
);
// Object Functions
// ----------------
// Our most fundamental functions operate on any JavaScript object.
// Most functions in Underscore depend on at least one function in this section.
// A group of functions that check the types of core JavaScript values.
// These are often informally referred to as the "isType" functions.
parcelHelpers.export(exports, "isObject", ()=>_isObjectJsDefault.default
);
parcelHelpers.export(exports, "isNull", ()=>_isNullJsDefault.default
);
parcelHelpers.export(exports, "isUndefined", ()=>_isUndefinedJsDefault.default
);
parcelHelpers.export(exports, "isBoolean", ()=>_isBooleanJsDefault.default
);
parcelHelpers.export(exports, "isElement", ()=>_isElementJsDefault.default
);
parcelHelpers.export(exports, "isString", ()=>_isStringJsDefault.default
);
parcelHelpers.export(exports, "isNumber", ()=>_isNumberJsDefault.default
);
parcelHelpers.export(exports, "isDate", ()=>_isDateJsDefault.default
);
parcelHelpers.export(exports, "isRegExp", ()=>_isRegExpJsDefault.default
);
parcelHelpers.export(exports, "isError", ()=>_isErrorJsDefault.default
);
parcelHelpers.export(exports, "isSymbol", ()=>_isSymbolJsDefault.default
);
parcelHelpers.export(exports, "isArrayBuffer", ()=>_isArrayBufferJsDefault.default
);
parcelHelpers.export(exports, "isDataView", ()=>_isDataViewJsDefault.default
);
parcelHelpers.export(exports, "isArray", ()=>_isArrayJsDefault.default
);
parcelHelpers.export(exports, "isFunction", ()=>_isFunctionJsDefault.default
);
parcelHelpers.export(exports, "isArguments", ()=>_isArgumentsJsDefault.default
);
parcelHelpers.export(exports, "isFinite", ()=>_isFiniteJsDefault.default
);
parcelHelpers.export(exports, "isNaN", ()=>_isNaNJsDefault.default
);
parcelHelpers.export(exports, "isTypedArray", ()=>_isTypedArrayJsDefault.default
);
parcelHelpers.export(exports, "isEmpty", ()=>_isEmptyJsDefault.default
);
parcelHelpers.export(exports, "isMatch", ()=>_isMatchJsDefault.default
);
parcelHelpers.export(exports, "isEqual", ()=>_isEqualJsDefault.default
);
parcelHelpers.export(exports, "isMap", ()=>_isMapJsDefault.default
);
parcelHelpers.export(exports, "isWeakMap", ()=>_isWeakMapJsDefault.default
);
parcelHelpers.export(exports, "isSet", ()=>_isSetJsDefault.default
);
parcelHelpers.export(exports, "isWeakSet", ()=>_isWeakSetJsDefault.default
);
// Functions that treat an object as a dictionary of key-value pairs.
parcelHelpers.export(exports, "keys", ()=>_keysJsDefault.default
);
parcelHelpers.export(exports, "allKeys", ()=>_allKeysJsDefault.default
);
parcelHelpers.export(exports, "values", ()=>_valuesJsDefault.default
);
parcelHelpers.export(exports, "pairs", ()=>_pairsJsDefault.default
);
parcelHelpers.export(exports, "invert", ()=>_invertJsDefault.default
);
parcelHelpers.export(exports, "functions", ()=>_functionsJsDefault.default
);
parcelHelpers.export(exports, "methods", ()=>_functionsJsDefault.default
);
parcelHelpers.export(exports, "extend", ()=>_extendJsDefault.default
);
parcelHelpers.export(exports, "extendOwn", ()=>_extendOwnJsDefault.default
);
parcelHelpers.export(exports, "assign", ()=>_extendOwnJsDefault.default
);
parcelHelpers.export(exports, "defaults", ()=>_defaultsJsDefault.default
);
parcelHelpers.export(exports, "create", ()=>_createJsDefault.default
);
parcelHelpers.export(exports, "clone", ()=>_cloneJsDefault.default
);
parcelHelpers.export(exports, "tap", ()=>_tapJsDefault.default
);
parcelHelpers.export(exports, "get", ()=>_getJsDefault.default
);
parcelHelpers.export(exports, "has", ()=>_hasJsDefault.default
);
parcelHelpers.export(exports, "mapObject", ()=>_mapObjectJsDefault.default
);
// Utility Functions
// -----------------
// A bit of a grab bag: Predicate-generating functions for use with filters and
// loops, string escaping and templating, create random numbers and unique ids,
// and functions that facilitate Underscore's chaining and iteration conventions.
parcelHelpers.export(exports, "identity", ()=>_identityJsDefault.default
);
parcelHelpers.export(exports, "constant", ()=>_constantJsDefault.default
);
parcelHelpers.export(exports, "noop", ()=>_noopJsDefault.default
);
parcelHelpers.export(exports, "toPath", ()=>_toPathJsDefault.default
);
parcelHelpers.export(exports, "property", ()=>_propertyJsDefault.default
);
parcelHelpers.export(exports, "propertyOf", ()=>_propertyOfJsDefault.default
);
parcelHelpers.export(exports, "matcher", ()=>_matcherJsDefault.default
);
parcelHelpers.export(exports, "matches", ()=>_matcherJsDefault.default
);
parcelHelpers.export(exports, "times", ()=>_timesJsDefault.default
);
parcelHelpers.export(exports, "random", ()=>_randomJsDefault.default
);
parcelHelpers.export(exports, "now", ()=>_nowJsDefault.default
);
parcelHelpers.export(exports, "escape", ()=>_escapeJsDefault.default
);
parcelHelpers.export(exports, "unescape", ()=>_unescapeJsDefault.default
);
parcelHelpers.export(exports, "templateSettings", ()=>_templateSettingsJsDefault.default
);
parcelHelpers.export(exports, "template", ()=>_templateJsDefault.default
);
parcelHelpers.export(exports, "result", ()=>_resultJsDefault.default
);
parcelHelpers.export(exports, "uniqueId", ()=>_uniqueIdJsDefault.default
);
parcelHelpers.export(exports, "chain", ()=>_chainJsDefault.default
);
parcelHelpers.export(exports, "iteratee", ()=>_iterateeJsDefault.default
);
// Function (ahem) Functions
// -------------------------
// These functions take a function as an argument and return a new function
// as the result. Also known as higher-order functions.
parcelHelpers.export(exports, "partial", ()=>_partialJsDefault.default
);
parcelHelpers.export(exports, "bind", ()=>_bindJsDefault.default
);
parcelHelpers.export(exports, "bindAll", ()=>_bindAllJsDefault.default
);
parcelHelpers.export(exports, "memoize", ()=>_memoizeJsDefault.default
);
parcelHelpers.export(exports, "delay", ()=>_delayJsDefault.default
);
parcelHelpers.export(exports, "defer", ()=>_deferJsDefault.default
);
parcelHelpers.export(exports, "throttle", ()=>_throttleJsDefault.default
);
parcelHelpers.export(exports, "debounce", ()=>_debounceJsDefault.default
);
parcelHelpers.export(exports, "wrap", ()=>_wrapJsDefault.default
);
parcelHelpers.export(exports, "negate", ()=>_negateJsDefault.default
);
parcelHelpers.export(exports, "compose", ()=>_composeJsDefault.default
);
parcelHelpers.export(exports, "after", ()=>_afterJsDefault.default
);
parcelHelpers.export(exports, "before", ()=>_beforeJsDefault.default
);
parcelHelpers.export(exports, "once", ()=>_onceJsDefault.default
);
// Finders
// -------
// Functions that extract (the position of) a single element from an object
// or array based on some criterion.
parcelHelpers.export(exports, "findKey", ()=>_findKeyJsDefault.default
);
parcelHelpers.export(exports, "findIndex", ()=>_findIndexJsDefault.default
);
parcelHelpers.export(exports, "findLastIndex", ()=>_findLastIndexJsDefault.default
);
parcelHelpers.export(exports, "sortedIndex", ()=>_sortedIndexJsDefault.default
);
parcelHelpers.export(exports, "indexOf", ()=>_indexOfJsDefault.default
);
parcelHelpers.export(exports, "lastIndexOf", ()=>_lastIndexOfJsDefault.default
);
parcelHelpers.export(exports, "find", ()=>_findJsDefault.default
);
parcelHelpers.export(exports, "detect", ()=>_findJsDefault.default
);
parcelHelpers.export(exports, "findWhere", ()=>_findWhereJsDefault.default
);
// Collection Functions
// --------------------
// Functions that work on any collection of elements: either an array, or
// an object of key-value pairs.
parcelHelpers.export(exports, "each", ()=>_eachJsDefault.default
);
parcelHelpers.export(exports, "forEach", ()=>_eachJsDefault.default
);
parcelHelpers.export(exports, "map", ()=>_mapJsDefault.default
);
parcelHelpers.export(exports, "collect", ()=>_mapJsDefault.default
);
parcelHelpers.export(exports, "reduce", ()=>_reduceJsDefault.default
);
parcelHelpers.export(exports, "foldl", ()=>_reduceJsDefault.default
);
parcelHelpers.export(exports, "inject", ()=>_reduceJsDefault.default
);
parcelHelpers.export(exports, "reduceRight", ()=>_reduceRightJsDefault.default
);
parcelHelpers.export(exports, "foldr", ()=>_reduceRightJsDefault.default
);
parcelHelpers.export(exports, "filter", ()=>_filterJsDefault.default
);
parcelHelpers.export(exports, "select", ()=>_filterJsDefault.default
);
parcelHelpers.export(exports, "reject", ()=>_rejectJsDefault.default
);
parcelHelpers.export(exports, "every", ()=>_everyJsDefault.default
);
parcelHelpers.export(exports, "all", ()=>_everyJsDefault.default
);
parcelHelpers.export(exports, "some", ()=>_someJsDefault.default
);
parcelHelpers.export(exports, "any", ()=>_someJsDefault.default
);
parcelHelpers.export(exports, "contains", ()=>_containsJsDefault.default
);
parcelHelpers.export(exports, "includes", ()=>_containsJsDefault.default
);
parcelHelpers.export(exports, "include", ()=>_containsJsDefault.default
);
parcelHelpers.export(exports, "invoke", ()=>_invokeJsDefault.default
);
parcelHelpers.export(exports, "pluck", ()=>_pluckJsDefault.default
);
parcelHelpers.export(exports, "where", ()=>_whereJsDefault.default
);
parcelHelpers.export(exports, "max", ()=>_maxJsDefault.default
);
parcelHelpers.export(exports, "min", ()=>_minJsDefault.default
);
parcelHelpers.export(exports, "shuffle", ()=>_shuffleJsDefault.default
);
parcelHelpers.export(exports, "sample", ()=>_sampleJsDefault.default
);
parcelHelpers.export(exports, "sortBy", ()=>_sortByJsDefault.default
);
parcelHelpers.export(exports, "groupBy", ()=>_groupByJsDefault.default
);
parcelHelpers.export(exports, "indexBy", ()=>_indexByJsDefault.default
);
parcelHelpers.export(exports, "countBy", ()=>_countByJsDefault.default
);
parcelHelpers.export(exports, "partition", ()=>_partitionJsDefault.default
);
parcelHelpers.export(exports, "toArray", ()=>_toArrayJsDefault.default
);
parcelHelpers.export(exports, "size", ()=>_sizeJsDefault.default
);
// `_.pick` and `_.omit` are actually object functions, but we put
// them here in order to create a more natural reading order in the
// monolithic build as they depend on `_.contains`.
parcelHelpers.export(exports, "pick", ()=>_pickJsDefault.default
);
parcelHelpers.export(exports, "omit", ()=>_omitJsDefault.default
);
// Array Functions
// ---------------
// Functions that operate on arrays (and array-likes) only, because they’re
// expressed in terms of operations on an ordered list of values.
parcelHelpers.export(exports, "first", ()=>_firstJsDefault.default
);
parcelHelpers.export(exports, "head", ()=>_firstJsDefault.default
);
parcelHelpers.export(exports, "take", ()=>_firstJsDefault.default
);
parcelHelpers.export(exports, "initial", ()=>_initialJsDefault.default
);
parcelHelpers.export(exports, "last", ()=>_lastJsDefault.default
);
parcelHelpers.export(exports, "rest", ()=>_restJsDefault.default
);
parcelHelpers.export(exports, "tail", ()=>_restJsDefault.default
);
parcelHelpers.export(exports, "drop", ()=>_restJsDefault.default
);
parcelHelpers.export(exports, "compact", ()=>_compactJsDefault.default
);
parcelHelpers.export(exports, "flatten", ()=>_flattenJsDefault.default
);
parcelHelpers.export(exports, "without", ()=>_withoutJsDefault.default
);
parcelHelpers.export(exports, "uniq", ()=>_uniqJsDefault.default
);
parcelHelpers.export(exports, "unique", ()=>_uniqJsDefault.default
);
parcelHelpers.export(exports, "union", ()=>_unionJsDefault.default
);
parcelHelpers.export(exports, "intersection", ()=>_intersectionJsDefault.default
);
parcelHelpers.export(exports, "difference", ()=>_differenceJsDefault.default
);
parcelHelpers.export(exports, "unzip", ()=>_unzipJsDefault.default
);
parcelHelpers.export(exports, "transpose", ()=>_unzipJsDefault.default
);
parcelHelpers.export(exports, "zip", ()=>_zipJsDefault.default
);
parcelHelpers.export(exports, "object", ()=>_objectJsDefault.default
);
parcelHelpers.export(exports, "range", ()=>_rangeJsDefault.default
);
parcelHelpers.export(exports, "chunk", ()=>_chunkJsDefault.default
);
// OOP
// ---
// These modules support the "object-oriented" calling style. See also
// `underscore.js` and `index-default.js`.
parcelHelpers.export(exports, "mixin", ()=>_mixinJsDefault.default
);
parcelHelpers.export(exports, "default", ()=>_underscoreArrayMethodsJsDefault.default
);
var _setupJs = require("./_setup.js");
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isNullJs = require("./isNull.js");
var _isNullJsDefault = parcelHelpers.interopDefault(_isNullJs);
var _isUndefinedJs = require("./isUndefined.js");
var _isUndefinedJsDefault = parcelHelpers.interopDefault(_isUndefinedJs);
var _isBooleanJs = require("./isBoolean.js");
var _isBooleanJsDefault = parcelHelpers.interopDefault(_isBooleanJs);
var _isElementJs = require("./isElement.js");
var _isElementJsDefault = parcelHelpers.interopDefault(_isElementJs);
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isNumberJs = require("./isNumber.js");
var _isNumberJsDefault = parcelHelpers.interopDefault(_isNumberJs);
var _isDateJs = require("./isDate.js");
var _isDateJsDefault = parcelHelpers.interopDefault(_isDateJs);
var _isRegExpJs = require("./isRegExp.js");
var _isRegExpJsDefault = parcelHelpers.interopDefault(_isRegExpJs);
var _isErrorJs = require("./isError.js");
var _isErrorJsDefault = parcelHelpers.interopDefault(_isErrorJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
var _isArrayBufferJs = require("./isArrayBuffer.js");
var _isArrayBufferJsDefault = parcelHelpers.interopDefault(_isArrayBufferJs);
var _isDataViewJs = require("./isDataView.js");
var _isDataViewJsDefault = parcelHelpers.interopDefault(_isDataViewJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isFiniteJs = require("./isFinite.js");
var _isFiniteJsDefault = parcelHelpers.interopDefault(_isFiniteJs);
var _isNaNJs = require("./isNaN.js");
var _isNaNJsDefault = parcelHelpers.interopDefault(_isNaNJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
var _isEmptyJs = require("./isEmpty.js");
var _isEmptyJsDefault = parcelHelpers.interopDefault(_isEmptyJs);
var _isMatchJs = require("./isMatch.js");
var _isMatchJsDefault = parcelHelpers.interopDefault(_isMatchJs);
var _isEqualJs = require("./isEqual.js");
var _isEqualJsDefault = parcelHelpers.interopDefault(_isEqualJs);
var _isMapJs = require("./isMap.js");
var _isMapJsDefault = parcelHelpers.interopDefault(_isMapJs);
var _isWeakMapJs = require("./isWeakMap.js");
var _isWeakMapJsDefault = parcelHelpers.interopDefault(_isWeakMapJs);
var _isSetJs = require("./isSet.js");
var _isSetJsDefault = parcelHelpers.interopDefault(_isSetJs);
var _isWeakSetJs = require("./isWeakSet.js");
var _isWeakSetJsDefault = parcelHelpers.interopDefault(_isWeakSetJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _pairsJs = require("./pairs.js");
var _pairsJsDefault = parcelHelpers.interopDefault(_pairsJs);
var _invertJs = require("./invert.js");
var _invertJsDefault = parcelHelpers.interopDefault(_invertJs);
var _functionsJs = require("./functions.js");
var _functionsJsDefault = parcelHelpers.interopDefault(_functionsJs);
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _extendOwnJs = require("./extendOwn.js");
var _extendOwnJsDefault = parcelHelpers.interopDefault(_extendOwnJs);
var _defaultsJs = require("./defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _createJs = require("./create.js");
var _createJsDefault = parcelHelpers.interopDefault(_createJs);
var _cloneJs = require("./clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _tapJs = require("./tap.js");
var _tapJsDefault = parcelHelpers.interopDefault(_tapJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
var _hasJs = require("./has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _mapObjectJs = require("./mapObject.js");
var _mapObjectJsDefault = parcelHelpers.interopDefault(_mapObjectJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _toPathJs = require("./toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _propertyOfJs = require("./propertyOf.js");
var _propertyOfJsDefault = parcelHelpers.interopDefault(_propertyOfJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
var _timesJs = require("./times.js");
var _timesJsDefault = parcelHelpers.interopDefault(_timesJs);
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
var _escapeJs = require("./escape.js");
var _escapeJsDefault = parcelHelpers.interopDefault(_escapeJs);
var _unescapeJs = require("./unescape.js");
var _unescapeJsDefault = parcelHelpers.interopDefault(_unescapeJs);
var _templateSettingsJs = require("./templateSettings.js");
var _templateSettingsJsDefault = parcelHelpers.interopDefault(_templateSettingsJs);
var _templateJs = require("./template.js");
var _templateJsDefault = parcelHelpers.interopDefault(_templateJs);
var _resultJs = require("./result.js");
var _resultJsDefault = parcelHelpers.interopDefault(_resultJs);
var _uniqueIdJs = require("./uniqueId.js");
var _uniqueIdJsDefault = parcelHelpers.interopDefault(_uniqueIdJs);
var _chainJs = require("./chain.js");
var _chainJsDefault = parcelHelpers.interopDefault(_chainJs);
var _iterateeJs = require("./iteratee.js");
var _iterateeJsDefault = parcelHelpers.interopDefault(_iterateeJs);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _bindJs = require("./bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _bindAllJs = require("./bindAll.js");
var _bindAllJsDefault = parcelHelpers.interopDefault(_bindAllJs);
var _memoizeJs = require("./memoize.js");
var _memoizeJsDefault = parcelHelpers.interopDefault(_memoizeJs);
var _delayJs = require("./delay.js");
var _delayJsDefault = parcelHelpers.interopDefault(_delayJs);
var _deferJs = require("./defer.js");
var _deferJsDefault = parcelHelpers.interopDefault(_deferJs);
var _throttleJs = require("./throttle.js");
var _throttleJsDefault = parcelHelpers.interopDefault(_throttleJs);
var _debounceJs = require("./debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _wrapJs = require("./wrap.js");
var _wrapJsDefault = parcelHelpers.interopDefault(_wrapJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _composeJs = require("./compose.js");
var _composeJsDefault = parcelHelpers.interopDefault(_composeJs);
var _afterJs = require("./after.js");
var _afterJsDefault = parcelHelpers.interopDefault(_afterJs);
var _beforeJs = require("./before.js");
var _beforeJsDefault = parcelHelpers.interopDefault(_beforeJs);
var _onceJs = require("./once.js");
var _onceJsDefault = parcelHelpers.interopDefault(_onceJs);
var _findKeyJs = require("./findKey.js");
var _findKeyJsDefault = parcelHelpers.interopDefault(_findKeyJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _findLastIndexJs = require("./findLastIndex.js");
var _findLastIndexJsDefault = parcelHelpers.interopDefault(_findLastIndexJs);
var _sortedIndexJs = require("./sortedIndex.js");
var _sortedIndexJsDefault = parcelHelpers.interopDefault(_sortedIndexJs);
var _indexOfJs = require("./indexOf.js");
var _indexOfJsDefault = parcelHelpers.interopDefault(_indexOfJs);
var _lastIndexOfJs = require("./lastIndexOf.js");
var _lastIndexOfJsDefault = parcelHelpers.interopDefault(_lastIndexOfJs);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _findWhereJs = require("./findWhere.js");
var _findWhereJsDefault = parcelHelpers.interopDefault(_findWhereJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _reduceJs = require("./reduce.js");
var _reduceJsDefault = parcelHelpers.interopDefault(_reduceJs);
var _reduceRightJs = require("./reduceRight.js");
var _reduceRightJsDefault = parcelHelpers.interopDefault(_reduceRightJs);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _rejectJs = require("./reject.js");
var _rejectJsDefault = parcelHelpers.interopDefault(_rejectJs);
var _everyJs = require("./every.js");
var _everyJsDefault = parcelHelpers.interopDefault(_everyJs);
var _someJs = require("./some.js");
var _someJsDefault = parcelHelpers.interopDefault(_someJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _invokeJs = require("./invoke.js");
var _invokeJsDefault = parcelHelpers.interopDefault(_invokeJs);
var _pluckJs = require("./pluck.js");
var _pluckJsDefault = parcelHelpers.interopDefault(_pluckJs);
var _whereJs = require("./where.js");
var _whereJsDefault = parcelHelpers.interopDefault(_whereJs);
var _maxJs = require("./max.js");
var _maxJsDefault = parcelHelpers.interopDefault(_maxJs);
var _minJs = require("./min.js");
var _minJsDefault = parcelHelpers.interopDefault(_minJs);
var _shuffleJs = require("./shuffle.js");
var _shuffleJsDefault = parcelHelpers.interopDefault(_shuffleJs);
var _sampleJs = require("./sample.js");
var _sampleJsDefault = parcelHelpers.interopDefault(_sampleJs);
var _sortByJs = require("./sortBy.js");
var _sortByJsDefault = parcelHelpers.interopDefault(_sortByJs);
var _groupByJs = require("./groupBy.js");
var _groupByJsDefault = parcelHelpers.interopDefault(_groupByJs);
var _indexByJs = require("./indexBy.js");
var _indexByJsDefault = parcelHelpers.interopDefault(_indexByJs);
var _countByJs = require("./countBy.js");
var _countByJsDefault = parcelHelpers.interopDefault(_countByJs);
var _partitionJs = require("./partition.js");
var _partitionJsDefault = parcelHelpers.interopDefault(_partitionJs);
var _toArrayJs = require("./toArray.js");
var _toArrayJsDefault = parcelHelpers.interopDefault(_toArrayJs);
var _sizeJs = require("./size.js");
var _sizeJsDefault = parcelHelpers.interopDefault(_sizeJs);
var _pickJs = require("./pick.js");
var _pickJsDefault = parcelHelpers.interopDefault(_pickJs);
var _omitJs = require("./omit.js");
var _omitJsDefault = parcelHelpers.interopDefault(_omitJs);
var _firstJs = require("./first.js");
var _firstJsDefault = parcelHelpers.interopDefault(_firstJs);
var _initialJs = require("./initial.js");
var _initialJsDefault = parcelHelpers.interopDefault(_initialJs);
var _lastJs = require("./last.js");
var _lastJsDefault = parcelHelpers.interopDefault(_lastJs);
var _restJs = require("./rest.js");
var _restJsDefault = parcelHelpers.interopDefault(_restJs);
var _compactJs = require("./compact.js");
var _compactJsDefault = parcelHelpers.interopDefault(_compactJs);
var _flattenJs = require("./flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _withoutJs = require("./without.js");
var _withoutJsDefault = parcelHelpers.interopDefault(_withoutJs);
var _uniqJs = require("./uniq.js");
var _uniqJsDefault = parcelHelpers.interopDefault(_uniqJs);
var _unionJs = require("./union.js");
var _unionJsDefault = parcelHelpers.interopDefault(_unionJs);
var _intersectionJs = require("./intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
var _differenceJs = require("./difference.js");
var _differenceJsDefault = parcelHelpers.interopDefault(_differenceJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
var _zipJs = require("./zip.js");
var _zipJsDefault = parcelHelpers.interopDefault(_zipJs);
var _objectJs = require("./object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _rangeJs = require("./range.js");
var _rangeJsDefault = parcelHelpers.interopDefault(_rangeJs);
var _chunkJs = require("./chunk.js");
var _chunkJsDefault = parcelHelpers.interopDefault(_chunkJs);
var _mixinJs = require("./mixin.js");
var _mixinJsDefault = parcelHelpers.interopDefault(_mixinJs);
var _underscoreArrayMethodsJs = require("./underscore-array-methods.js");
var _underscoreArrayMethodsJsDefault = parcelHelpers.interopDefault(_underscoreArrayMethodsJs);

},{"./_setup.js":"bU4rb","./restArguments.js":"aKoU9","./isObject.js":"fewdV","./isNull.js":"5IXoW","./isUndefined.js":"1rdlx","./isBoolean.js":"ffqST","./isElement.js":"bgiPo","./isString.js":"lSLRQ","./isNumber.js":"jtK5H","./isDate.js":"7OIGk","./isRegExp.js":"3gbYP","./isError.js":"dRdPu","./isSymbol.js":"05hWy","./isArrayBuffer.js":"fz1w4","./isDataView.js":"kiEXp","./isArray.js":"oMlWT","./isFunction.js":"kDkjm","./isArguments.js":"ccahD","./isFinite.js":"1QPhO","./isNaN.js":"3kTfb","./isTypedArray.js":"96nwS","./isEmpty.js":"bWwBk","./isMatch.js":"lVx0T","./isEqual.js":"4Y7Ng","./isMap.js":"btbMz","./isWeakMap.js":"3nLaV","./isSet.js":"fmko9","./isWeakSet.js":"1WWW6","./keys.js":"l8Krv","./allKeys.js":"gEhlz","./values.js":"gylxe","./pairs.js":"5eJgq","./invert.js":"hY4ge","./functions.js":"aQpNB","./extend.js":"56G2o","./extendOwn.js":"aFcJ0","./defaults.js":"fFxIE","./create.js":"heZD5","./clone.js":"agxO3","./tap.js":"7c8Mk","./get.js":"jpYyN","./has.js":"dc692","./mapObject.js":"jTjJs","./identity.js":"f05xz","./constant.js":"akQkN","./noop.js":"eVJ12","./toPath.js":"afZr1","./property.js":"c6Iih","./propertyOf.js":"cHCOK","./matcher.js":"ekXoC","./times.js":"9U23S","./random.js":"jDe0A","./now.js":"fZ1Zl","./escape.js":"21f6N","./unescape.js":"brBbv","./templateSettings.js":"69goE","./template.js":"hyJUN","./result.js":"jjeXL","./uniqueId.js":"aS6hE","./chain.js":"h8Igg","./iteratee.js":"hFOL3","./partial.js":"hLcX3","./bind.js":"48NsZ","./bindAll.js":"9u5NU","./memoize.js":"ceNZR","./delay.js":"k0bcV","./defer.js":"5pRfB","./throttle.js":"87yq2","./debounce.js":"1Csjh","./wrap.js":"luJbh","./negate.js":"jleQN","./compose.js":"NhC2V","./after.js":"hdEPt","./before.js":"6OzV9","./once.js":"g5TYa","./findKey.js":"3zqFY","./findIndex.js":"edEuk","./findLastIndex.js":"akOdX","./sortedIndex.js":"4zP4e","./indexOf.js":"krndY","./lastIndexOf.js":"4BWXf","./find.js":"doTH0","./findWhere.js":"k1pe6","./each.js":"ewQpM","./map.js":"giPqo","./reduce.js":"aPzI9","./reduceRight.js":"1xJDA","./filter.js":"eA6Gs","./reject.js":"bnI9j","./every.js":"cWFVa","./some.js":"3Watr","./contains.js":"ibLHC","./invoke.js":"2PsTm","./pluck.js":"16Uqx","./where.js":"68doq","./max.js":"jGJNf","./min.js":"c6yfU","./shuffle.js":"7rhS3","./sample.js":"1Yno6","./sortBy.js":"9ldTP","./groupBy.js":"gXyFd","./indexBy.js":"8sscK","./countBy.js":"58Fry","./partition.js":"fVFy0","./toArray.js":"9hdGm","./size.js":"6mXmd","./pick.js":"iJky2","./omit.js":"7TToI","./first.js":"1fmF2","./initial.js":"2Q93K","./last.js":"gWLnh","./rest.js":"l7YiK","./compact.js":"5geL8","./flatten.js":"kzSeC","./without.js":"jGT7e","./uniq.js":"ci6Hh","./union.js":"9B8VJ","./intersection.js":"9e2VQ","./difference.js":"iJk2V","./unzip.js":"8xaCn","./zip.js":"LKE7e","./object.js":"3kVS9","./range.js":"6d5vI","./chunk.js":"bTQIh","./mixin.js":"3Jc5x","./underscore-array-methods.js":"ehthA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bU4rb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION
);
parcelHelpers.export(exports, "root", ()=>root
);
parcelHelpers.export(exports, "ArrayProto", ()=>ArrayProto
);
parcelHelpers.export(exports, "ObjProto", ()=>ObjProto
);
parcelHelpers.export(exports, "SymbolProto", ()=>SymbolProto
);
parcelHelpers.export(exports, "push", ()=>push
);
parcelHelpers.export(exports, "slice", ()=>slice
);
parcelHelpers.export(exports, "toString", ()=>toString
);
parcelHelpers.export(exports, "hasOwnProperty", ()=>hasOwnProperty
);
parcelHelpers.export(exports, "supportsArrayBuffer", ()=>supportsArrayBuffer
);
parcelHelpers.export(exports, "supportsDataView", ()=>supportsDataView
);
parcelHelpers.export(exports, "nativeIsArray", ()=>nativeIsArray
);
parcelHelpers.export(exports, "nativeKeys", ()=>nativeKeys
);
parcelHelpers.export(exports, "nativeCreate", ()=>nativeCreate
);
parcelHelpers.export(exports, "nativeIsView", ()=>nativeIsView
);
parcelHelpers.export(exports, "_isNaN", ()=>_isNaN
);
parcelHelpers.export(exports, "_isFinite", ()=>_isFinite
);
parcelHelpers.export(exports, "hasEnumBug", ()=>hasEnumBug
);
parcelHelpers.export(exports, "nonEnumerableProps", ()=>nonEnumerableProps
);
parcelHelpers.export(exports, "MAX_ARRAY_INDEX", ()=>MAX_ARRAY_INDEX
);
var global = arguments[3];
var VERSION = '1.13.1';
var root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || Function('return this')() || {
};
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;
var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined', supportsDataView = typeof DataView !== 'undefined';
var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
var _isNaN = isNaN, _isFinite = isFinite;
var hasEnumBug = !({
    toString: null
}).propertyIsEnumerable('toString');
var nonEnumerableProps = [
    'valueOf',
    'isPrototypeOf',
    'toString',
    'propertyIsEnumerable',
    'hasOwnProperty',
    'toLocaleString'
];
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"aKoU9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
        var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0;
        for(; index < length; index++)rest[index] = arguments[index + startIndex];
        switch(startIndex){
            case 0:
                return func.call(this, rest);
            case 1:
                return func.call(this, arguments[0], rest);
            case 2:
                return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for(index = 0; index < startIndex; index++)args[index] = arguments[index];
        args[startIndex] = rest;
        return func.apply(this, args);
    };
}
exports.default = restArguments;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fewdV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isObject(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
}
exports.default = isObject;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5IXoW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isNull(obj) {
    return obj === null;
}
exports.default = isNull;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1rdlx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isUndefined(obj) {
    return obj === void 0;
}
exports.default = isUndefined;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ffqST":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function isBoolean(obj) {
    return obj === true || obj === false || _setupJs.toString.call(obj) === '[object Boolean]';
}
exports.default = isBoolean;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bgiPo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isElement(obj) {
    return !!(obj && obj.nodeType === 1);
}
exports.default = isElement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lSLRQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('String');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9L0lE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function tagTester(name) {
    var tag = '[object ' + name + ']';
    return function(obj) {
        return _setupJs.toString.call(obj) === tag;
    };
}
exports.default = tagTester;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jtK5H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Number');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7OIGk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Date');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3gbYP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('RegExp');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dRdPu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Error');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"05hWy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Symbol');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fz1w4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('ArrayBuffer');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kiEXp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isArrayBufferJs = require("./isArrayBuffer.js");
var _isArrayBufferJsDefault = parcelHelpers.interopDefault(_isArrayBufferJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var isDataView = _tagTesterJsDefault.default('DataView');
// In IE 10 - Edge 13, we need a different heuristic
// to determine whether an object is a `DataView`.
function ie10IsDataView(obj) {
    return obj != null && _isFunctionJsDefault.default(obj.getInt8) && _isArrayBufferJsDefault.default(obj.buffer);
}
exports.default = _stringTagBugJs.hasStringTagBug ? ie10IsDataView : isDataView;

},{"./_tagTester.js":"9L0lE","./isFunction.js":"kDkjm","./isArrayBuffer.js":"fz1w4","./_stringTagBug.js":"liky0","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kDkjm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _setupJs = require("./_setup.js");
var isFunction = _tagTesterJsDefault.default('Function');
// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = _setupJs.root.document && _setupJs.root.document.childNodes;
if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') isFunction = function(obj) {
    return typeof obj == 'function' || false;
};
exports.default = isFunction;

},{"./_tagTester.js":"9L0lE","./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"liky0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasStringTagBug", ()=>hasStringTagBug
);
parcelHelpers.export(exports, "isIE11", ()=>isIE11
);
var _setupJs = require("./_setup.js");
var _hasObjectTagJs = require("./_hasObjectTag.js");
var _hasObjectTagJsDefault = parcelHelpers.interopDefault(_hasObjectTagJs);
var hasStringTagBug = _setupJs.supportsDataView && _hasObjectTagJsDefault.default(new DataView(new ArrayBuffer(8))), isIE11 = typeof Map !== 'undefined' && _hasObjectTagJsDefault.default(new Map);

},{"./_setup.js":"bU4rb","./_hasObjectTag.js":"fxe6G","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fxe6G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Object');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"oMlWT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _setupJs.nativeIsArray || _tagTesterJsDefault.default('Array');

},{"./_setup.js":"bU4rb","./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ccahD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var isArguments = _tagTesterJsDefault.default('Arguments');
(function() {
    if (!isArguments(arguments)) isArguments = function(obj) {
        return _hasJsDefault.default(obj, 'callee');
    };
})();
exports.default = isArguments;

},{"./_tagTester.js":"9L0lE","./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aSS50":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function has(obj, key) {
    return obj != null && _setupJs.hasOwnProperty.call(obj, key);
}
exports.default = has;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1QPhO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
function isFinite(obj) {
    return !_isSymbolJsDefault.default(obj) && _setupJs._isFinite(obj) && !isNaN(parseFloat(obj));
}
exports.default = isFinite;

},{"./_setup.js":"bU4rb","./isSymbol.js":"05hWy","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3kTfb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _isNumberJs = require("./isNumber.js");
var _isNumberJsDefault = parcelHelpers.interopDefault(_isNumberJs);
function isNaN(obj) {
    return _isNumberJsDefault.default(obj) && _setupJs._isNaN(obj);
}
exports.default = isNaN;

},{"./_setup.js":"bU4rb","./isNumber.js":"jtK5H","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"96nwS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _isDataViewJs = require("./isDataView.js");
var _isDataViewJsDefault = parcelHelpers.interopDefault(_isDataViewJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _isBufferLikeJs = require("./_isBufferLike.js");
var _isBufferLikeJsDefault = parcelHelpers.interopDefault(_isBufferLikeJs);
// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
    // `ArrayBuffer.isView` is the most future-proof, so use it when available.
    // Otherwise, fall back on the above regular expression.
    return _setupJs.nativeIsView ? _setupJs.nativeIsView(obj) && !_isDataViewJsDefault.default(obj) : _isBufferLikeJsDefault.default(obj) && typedArrayPattern.test(_setupJs.toString.call(obj));
}
exports.default = _setupJs.supportsArrayBuffer ? isTypedArray : _constantJsDefault.default(false);

},{"./_setup.js":"bU4rb","./isDataView.js":"kiEXp","./constant.js":"akQkN","./_isBufferLike.js":"kJLYf","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"akQkN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function constant(value) {
    return function() {
        return value;
    };
}
exports.default = constant;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kJLYf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createSizePropertyCheckJs = require("./_createSizePropertyCheck.js");
var _createSizePropertyCheckJsDefault = parcelHelpers.interopDefault(_createSizePropertyCheckJs);
var _getByteLengthJs = require("./_getByteLength.js");
var _getByteLengthJsDefault = parcelHelpers.interopDefault(_getByteLengthJs);
exports.default = _createSizePropertyCheckJsDefault.default(_getByteLengthJsDefault.default);

},{"./_createSizePropertyCheck.js":"b727b","./_getByteLength.js":"8j0nM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"b727b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function createSizePropertyCheck(getSizeProperty) {
    return function(collection) {
        var sizeProperty = getSizeProperty(collection);
        return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= _setupJs.MAX_ARRAY_INDEX;
    };
}
exports.default = createSizePropertyCheck;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8j0nM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _shallowPropertyJs = require("./_shallowProperty.js");
var _shallowPropertyJsDefault = parcelHelpers.interopDefault(_shallowPropertyJs);
exports.default = _shallowPropertyJsDefault.default('byteLength');

},{"./_shallowProperty.js":"28HTj","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"28HTj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function shallowProperty(key) {
    return function(obj) {
        return obj == null ? void 0 : obj[key];
    };
}
exports.default = shallowProperty;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bWwBk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function isEmpty(obj) {
    if (obj == null) return true;
    // Skip the more expensive `toString`-based type checks if `obj` has no
    // `.length`.
    var length = _getLengthJsDefault.default(obj);
    if (typeof length == 'number' && (_isArrayJsDefault.default(obj) || _isStringJsDefault.default(obj) || _isArgumentsJsDefault.default(obj))) return length === 0;
    return _getLengthJsDefault.default(_keysJsDefault.default(obj)) === 0;
}
exports.default = isEmpty;

},{"./_getLength.js":"30FQX","./isArray.js":"oMlWT","./isString.js":"lSLRQ","./isArguments.js":"ccahD","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"30FQX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _shallowPropertyJs = require("./_shallowProperty.js");
var _shallowPropertyJsDefault = parcelHelpers.interopDefault(_shallowPropertyJs);
exports.default = _shallowPropertyJsDefault.default('length');

},{"./_shallowProperty.js":"28HTj","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"l8Krv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _setupJs = require("./_setup.js");
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _collectNonEnumPropsJs = require("./_collectNonEnumProps.js");
var _collectNonEnumPropsJsDefault = parcelHelpers.interopDefault(_collectNonEnumPropsJs);
function keys1(obj) {
    if (!_isObjectJsDefault.default(obj)) return [];
    if (_setupJs.nativeKeys) return _setupJs.nativeKeys(obj);
    var keys = [];
    for(var key in obj)if (_hasJsDefault.default(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (_setupJs.hasEnumBug) _collectNonEnumPropsJsDefault.default(obj, keys);
    return keys;
}
exports.default = keys1;

},{"./isObject.js":"fewdV","./_setup.js":"bU4rb","./_has.js":"aSS50","./_collectNonEnumProps.js":"bdCpc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bdCpc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
    var hash = {
    };
    for(var l = keys.length, i = 0; i < l; ++i)hash[keys[i]] = true;
    return {
        contains: function(key) {
            return hash[key];
        },
        push: function(key) {
            hash[key] = true;
            return keys.push(key);
        }
    };
}
function collectNonEnumProps(obj, keys) {
    keys = emulatedSet(keys);
    var nonEnumIdx = _setupJs.nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _isFunctionJsDefault.default(constructor) && constructor.prototype || _setupJs.ObjProto;
    // Constructor is a special case.
    var prop = 'constructor';
    if (_hasJsDefault.default(obj, prop) && !keys.contains(prop)) keys.push(prop);
    while(nonEnumIdx--){
        prop = _setupJs.nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) keys.push(prop);
    }
}
exports.default = collectNonEnumProps;

},{"./_setup.js":"bU4rb","./isFunction.js":"kDkjm","./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lVx0T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function isMatch(object, attrs) {
    var _keys = _keysJsDefault.default(attrs), length = _keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for(var i = 0; i < length; i++){
        var key = _keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
}
exports.default = isMatch;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4Y7Ng":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _setupJs = require("./_setup.js");
var _getByteLengthJs = require("./_getByteLength.js");
var _getByteLengthJsDefault = parcelHelpers.interopDefault(_getByteLengthJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _isDataViewJs = require("./isDataView.js");
var _isDataViewJsDefault = parcelHelpers.interopDefault(_isDataViewJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _toBufferViewJs = require("./_toBufferView.js");
var _toBufferViewJsDefault = parcelHelpers.interopDefault(_toBufferViewJs);
// We use this string twice, so give it a name for minification.
var tagDataView = '[object DataView]';
// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
}
// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _underscoreJsDefault.default) a = a._wrapped;
    if (b instanceof _underscoreJsDefault.default) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = _setupJs.toString.call(a);
    if (className !== _setupJs.toString.call(b)) return false;
    // Work around a bug in IE 10 - Edge 13.
    if (_stringTagBugJs.hasStringTagBug && className == '[object Object]' && _isDataViewJsDefault.default(a)) {
        if (!_isDataViewJsDefault.default(b)) return false;
        className = tagDataView;
    }
    switch(className){
        // These types are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
        case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        case '[object Symbol]':
            return _setupJs.SymbolProto.valueOf.call(a) === _setupJs.SymbolProto.valueOf.call(b);
        case '[object ArrayBuffer]':
        case tagDataView:
            // Coerce to typed array so we can fall through.
            return deepEq(_toBufferViewJsDefault.default(a), _toBufferViewJsDefault.default(b), aStack, bStack);
    }
    var areArrays = className === '[object Array]';
    if (!areArrays && _isTypedArrayJsDefault.default(a)) {
        var byteLength = _getByteLengthJsDefault.default(a);
        if (byteLength !== _getByteLengthJsDefault.default(b)) return false;
        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
        areArrays = true;
    }
    if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object') return false;
        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(_isFunctionJsDefault.default(aCtor) && aCtor instanceof aCtor && _isFunctionJsDefault.default(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) return false;
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while(length--){
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while(length--){
            if (!eq(a[length], b[length], aStack, bStack)) return false;
        }
    } else {
        // Deep compare objects.
        var _keys = _keysJsDefault.default(a), key;
        length = _keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (_keysJsDefault.default(b).length !== length) return false;
        while(length--){
            // Deep compare each member
            key = _keys[length];
            if (!(_hasJsDefault.default(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
}
function isEqual(a, b) {
    return eq(a, b);
}
exports.default = isEqual;

},{"./underscore.js":"hjck8","./_setup.js":"bU4rb","./_getByteLength.js":"8j0nM","./isTypedArray.js":"96nwS","./isFunction.js":"kDkjm","./_stringTagBug.js":"liky0","./isDataView.js":"kiEXp","./keys.js":"l8Krv","./_has.js":"aSS50","./_toBufferView.js":"6NZHV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hjck8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function _(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
}
exports.default = _;
_.VERSION = _setupJs.VERSION;
// Extracts the result from a wrapped and chained object.
_.prototype.value = function() {
    return this._wrapped;
};
// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
_.prototype.toString = function() {
    return String(this._wrapped);
};

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6NZHV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getByteLengthJs = require("./_getByteLength.js");
var _getByteLengthJsDefault = parcelHelpers.interopDefault(_getByteLengthJs);
function toBufferView(bufferSource) {
    return new Uint8Array(bufferSource.buffer || bufferSource, bufferSource.byteOffset || 0, _getByteLengthJsDefault.default(bufferSource));
}
exports.default = toBufferView;

},{"./_getByteLength.js":"8j0nM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"btbMz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _methodFingerprintJs = require("./_methodFingerprint.js");
exports.default = _stringTagBugJs.isIE11 ? _methodFingerprintJs.ie11fingerprint(_methodFingerprintJs.mapMethods) : _tagTesterJsDefault.default('Map');

},{"./_tagTester.js":"9L0lE","./_stringTagBug.js":"liky0","./_methodFingerprint.js":"enYoA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"enYoA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Since the regular `Object.prototype.toString` type tests don't work for
// some types in IE 11, we use a fingerprinting heuristic instead, based
// on the methods. It's not great, but it's the best we got.
// The fingerprint method lists are defined below.
parcelHelpers.export(exports, "ie11fingerprint", ()=>ie11fingerprint
);
parcelHelpers.export(exports, "mapMethods", ()=>mapMethods
);
parcelHelpers.export(exports, "weakMapMethods", ()=>weakMapMethods
);
parcelHelpers.export(exports, "setMethods", ()=>setMethods
);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
function ie11fingerprint(methods) {
    var length = _getLengthJsDefault.default(methods);
    return function(obj) {
        if (obj == null) return false;
        // `Map`, `WeakMap` and `Set` have no enumerable keys.
        var keys = _allKeysJsDefault.default(obj);
        if (_getLengthJsDefault.default(keys)) return false;
        for(var i = 0; i < length; i++){
            if (!_isFunctionJsDefault.default(obj[methods[i]])) return false;
        }
        // If we are testing against `WeakMap`, we need to ensure that
        // `obj` doesn't have a `forEach` method in order to distinguish
        // it from a regular `Map`.
        return methods !== weakMapMethods || !_isFunctionJsDefault.default(obj[forEachName]);
    };
}
// In the interest of compact minification, we write
// each string in the fingerprints only once.
var forEachName = 'forEach', hasName = 'has', commonInit = [
    'clear',
    'delete'
], mapTail = [
    'get',
    hasName,
    'set'
];
var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = [
    'add'
].concat(commonInit, forEachName, hasName);

},{"./_getLength.js":"30FQX","./isFunction.js":"kDkjm","./allKeys.js":"gEhlz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gEhlz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _setupJs = require("./_setup.js");
var _collectNonEnumPropsJs = require("./_collectNonEnumProps.js");
var _collectNonEnumPropsJsDefault = parcelHelpers.interopDefault(_collectNonEnumPropsJs);
function allKeys(obj) {
    if (!_isObjectJsDefault.default(obj)) return [];
    var keys = [];
    for(var key in obj)keys.push(key);
    // Ahem, IE < 9.
    if (_setupJs.hasEnumBug) _collectNonEnumPropsJsDefault.default(obj, keys);
    return keys;
}
exports.default = allKeys;

},{"./isObject.js":"fewdV","./_setup.js":"bU4rb","./_collectNonEnumProps.js":"bdCpc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3nLaV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _methodFingerprintJs = require("./_methodFingerprint.js");
exports.default = _stringTagBugJs.isIE11 ? _methodFingerprintJs.ie11fingerprint(_methodFingerprintJs.weakMapMethods) : _tagTesterJsDefault.default('WeakMap');

},{"./_tagTester.js":"9L0lE","./_stringTagBug.js":"liky0","./_methodFingerprint.js":"enYoA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fmko9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _methodFingerprintJs = require("./_methodFingerprint.js");
exports.default = _stringTagBugJs.isIE11 ? _methodFingerprintJs.ie11fingerprint(_methodFingerprintJs.setMethods) : _tagTesterJsDefault.default('Set');

},{"./_tagTester.js":"9L0lE","./_stringTagBug.js":"liky0","./_methodFingerprint.js":"enYoA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1WWW6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('WeakSet');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gylxe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function values1(obj) {
    var _keys = _keysJsDefault.default(obj);
    var length = _keys.length;
    var values = Array(length);
    for(var i = 0; i < length; i++)values[i] = obj[_keys[i]];
    return values;
}
exports.default = values1;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5eJgq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function pairs1(obj) {
    var _keys = _keysJsDefault.default(obj);
    var length = _keys.length;
    var pairs = Array(length);
    for(var i = 0; i < length; i++)pairs[i] = [
        _keys[i],
        obj[_keys[i]]
    ];
    return pairs;
}
exports.default = pairs1;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hY4ge":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function invert(obj) {
    var result = {
    };
    var _keys = _keysJsDefault.default(obj);
    for(var i = 0, length = _keys.length; i < length; i++)result[obj[_keys[i]]] = _keys[i];
    return result;
}
exports.default = invert;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aQpNB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
function functions(obj) {
    var names = [];
    for(var key in obj)if (_isFunctionJsDefault.default(obj[key])) names.push(key);
    return names.sort();
}
exports.default = functions;

},{"./isFunction.js":"kDkjm","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"56G2o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createAssignerJs = require("./_createAssigner.js");
var _createAssignerJsDefault = parcelHelpers.interopDefault(_createAssignerJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
exports.default = _createAssignerJsDefault.default(_allKeysJsDefault.default);

},{"./_createAssigner.js":"6Ww9s","./allKeys.js":"gEhlz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6Ww9s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function createAssigner(keysFunc, defaults) {
    return function(obj) {
        var length = arguments.length;
        if (defaults) obj = Object(obj);
        if (length < 2 || obj == null) return obj;
        for(var index = 1; index < length; index++){
            var source = arguments[index], keys = keysFunc(source), l = keys.length;
            for(var i = 0; i < l; i++){
                var key = keys[i];
                if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
        }
        return obj;
    };
}
exports.default = createAssigner;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aFcJ0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createAssignerJs = require("./_createAssigner.js");
var _createAssignerJsDefault = parcelHelpers.interopDefault(_createAssignerJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
exports.default = _createAssignerJsDefault.default(_keysJsDefault.default);

},{"./_createAssigner.js":"6Ww9s","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fFxIE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createAssignerJs = require("./_createAssigner.js");
var _createAssignerJsDefault = parcelHelpers.interopDefault(_createAssignerJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
exports.default = _createAssignerJsDefault.default(_allKeysJsDefault.default, true);

},{"./_createAssigner.js":"6Ww9s","./allKeys.js":"gEhlz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"heZD5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _extendOwnJs = require("./extendOwn.js");
var _extendOwnJsDefault = parcelHelpers.interopDefault(_extendOwnJs);
function create(prototype, props) {
    var result = _baseCreateJsDefault.default(prototype);
    if (props) _extendOwnJsDefault.default(result, props);
    return result;
}
exports.default = create;

},{"./_baseCreate.js":"3vxk9","./extendOwn.js":"aFcJ0","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3vxk9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _setupJs = require("./_setup.js");
// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
    return function() {
    };
}
function baseCreate(prototype) {
    if (!_isObjectJsDefault.default(prototype)) return {
    };
    if (_setupJs.nativeCreate) return _setupJs.nativeCreate(prototype);
    var Ctor = ctor();
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
}
exports.default = baseCreate;

},{"./isObject.js":"fewdV","./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"agxO3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
function clone(obj) {
    if (!_isObjectJsDefault.default(obj)) return obj;
    return _isArrayJsDefault.default(obj) ? obj.slice() : _extendJsDefault.default({
    }, obj);
}
exports.default = clone;

},{"./isObject.js":"fewdV","./isArray.js":"oMlWT","./extend.js":"56G2o","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7c8Mk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function tap(obj, interceptor) {
    interceptor(obj);
    return obj;
}
exports.default = tap;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jpYyN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
var _deepGetJs = require("./_deepGet.js");
var _deepGetJsDefault = parcelHelpers.interopDefault(_deepGetJs);
var _isUndefinedJs = require("./isUndefined.js");
var _isUndefinedJsDefault = parcelHelpers.interopDefault(_isUndefinedJs);
function get(object, path, defaultValue) {
    var value = _deepGetJsDefault.default(object, _toPathJsDefault.default(path));
    return _isUndefinedJsDefault.default(value) ? defaultValue : value;
}
exports.default = get;

},{"./_toPath.js":"2PZbF","./_deepGet.js":"9J8i1","./isUndefined.js":"1rdlx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2PZbF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _toPathJs = require("./toPath.js");
function toPath(path) {
    return _underscoreJsDefault.default.toPath(path);
}
exports.default = toPath;

},{"./underscore.js":"hjck8","./toPath.js":"afZr1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"afZr1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
function toPath(path) {
    return _isArrayJsDefault.default(path) ? path : [
        path
    ];
}
exports.default = toPath;
_underscoreJsDefault.default.toPath = toPath;

},{"./underscore.js":"hjck8","./isArray.js":"oMlWT","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9J8i1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function deepGet(obj, path) {
    var length = path.length;
    for(var i = 0; i < length; i++){
        if (obj == null) return void 0;
        obj = obj[path[i]];
    }
    return length ? obj : void 0;
}
exports.default = deepGet;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dc692":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
function has(obj, path) {
    path = _toPathJsDefault.default(path);
    var length = path.length;
    for(var i = 0; i < length; i++){
        var key = path[i];
        if (!_hasJsDefault.default(obj, key)) return false;
        obj = obj[key];
    }
    return !!length;
}
exports.default = has;

},{"./_has.js":"aSS50","./_toPath.js":"2PZbF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jTjJs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function mapObject(obj, iteratee, context) {
    iteratee = _cbJsDefault.default(iteratee, context);
    var _keys = _keysJsDefault.default(obj), length = _keys.length, results = {
    };
    for(var index = 0; index < length; index++){
        var currentKey = _keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
}
exports.default = mapObject;

},{"./_cb.js":"l45Ig","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"l45Ig":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
var _iterateeJs = require("./iteratee.js");
var _iterateeJsDefault = parcelHelpers.interopDefault(_iterateeJs);
function cb(value, context, argCount) {
    if (_underscoreJsDefault.default.iteratee !== _iterateeJsDefault.default) return _underscoreJsDefault.default.iteratee(value, context);
    return _baseIterateeJsDefault.default(value, context, argCount);
}
exports.default = cb;

},{"./underscore.js":"hjck8","./_baseIteratee.js":"aNHi1","./iteratee.js":"hFOL3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aNHi1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
function baseIteratee(value, context, argCount) {
    if (value == null) return _identityJsDefault.default;
    if (_isFunctionJsDefault.default(value)) return _optimizeCbJsDefault.default(value, context, argCount);
    if (_isObjectJsDefault.default(value) && !_isArrayJsDefault.default(value)) return _matcherJsDefault.default(value);
    return _propertyJsDefault.default(value);
}
exports.default = baseIteratee;

},{"./identity.js":"f05xz","./isFunction.js":"kDkjm","./isObject.js":"fewdV","./isArray.js":"oMlWT","./matcher.js":"ekXoC","./property.js":"c6Iih","./_optimizeCb.js":"cAw5c","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"f05xz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function identity(value) {
    return value;
}
exports.default = identity;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ekXoC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extendOwnJs = require("./extendOwn.js");
var _extendOwnJsDefault = parcelHelpers.interopDefault(_extendOwnJs);
var _isMatchJs = require("./isMatch.js");
var _isMatchJsDefault = parcelHelpers.interopDefault(_isMatchJs);
function matcher(attrs) {
    attrs = _extendOwnJsDefault.default({
    }, attrs);
    return function(obj) {
        return _isMatchJsDefault.default(obj, attrs);
    };
}
exports.default = matcher;

},{"./extendOwn.js":"aFcJ0","./isMatch.js":"lVx0T","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c6Iih":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _deepGetJs = require("./_deepGet.js");
var _deepGetJsDefault = parcelHelpers.interopDefault(_deepGetJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
function property(path) {
    path = _toPathJsDefault.default(path);
    return function(obj) {
        return _deepGetJsDefault.default(obj, path);
    };
}
exports.default = property;

},{"./_deepGet.js":"9J8i1","./_toPath.js":"2PZbF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cAw5c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function optimizeCb(func, context, argCount) {
    if (context === void 0) return func;
    switch(argCount == null ? 3 : argCount){
        case 1:
            return function(value) {
                return func.call(context, value);
            };
        // The 2-argument case is omitted because we’re not using it.
        case 3:
            return function(value, index, collection) {
                return func.call(context, value, index, collection);
            };
        case 4:
            return function(accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection);
            };
    }
    return function() {
        return func.apply(context, arguments);
    };
}
exports.default = optimizeCb;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hFOL3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
function iteratee(value, context) {
    return _baseIterateeJsDefault.default(value, context, Infinity);
}
exports.default = iteratee;
_underscoreJsDefault.default.iteratee = iteratee;

},{"./underscore.js":"hjck8","./_baseIteratee.js":"aNHi1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eVJ12":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function noop() {
}
exports.default = noop;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cHCOK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
function propertyOf(obj) {
    if (obj == null) return _noopJsDefault.default;
    return function(path) {
        return _getJsDefault.default(obj, path);
    };
}
exports.default = propertyOf;

},{"./noop.js":"eVJ12","./get.js":"jpYyN","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9U23S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
function times(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = _optimizeCbJsDefault.default(iteratee, context, 1);
    for(var i = 0; i < n; i++)accum[i] = iteratee(i);
    return accum;
}
exports.default = times;

},{"./_optimizeCb.js":"cAw5c","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jDe0A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function random(min, max) {
    if (max == null) {
        max = min;
        min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
}
exports.default = random;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fZ1Zl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = Date.now || function() {
    return new Date().getTime();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"21f6N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createEscaperJs = require("./_createEscaper.js");
var _createEscaperJsDefault = parcelHelpers.interopDefault(_createEscaperJs);
var _escapeMapJs = require("./_escapeMap.js");
var _escapeMapJsDefault = parcelHelpers.interopDefault(_escapeMapJs);
exports.default = _createEscaperJsDefault.default(_escapeMapJsDefault.default);

},{"./_createEscaper.js":"521Gb","./_escapeMap.js":"fPOAI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"521Gb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function createEscaper(map) {
    var escaper = function(match) {
        return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _keysJsDefault.default(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
}
exports.default = createEscaper;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fPOAI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"brBbv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createEscaperJs = require("./_createEscaper.js");
var _createEscaperJsDefault = parcelHelpers.interopDefault(_createEscaperJs);
var _unescapeMapJs = require("./_unescapeMap.js");
var _unescapeMapJsDefault = parcelHelpers.interopDefault(_unescapeMapJs);
exports.default = _createEscaperJsDefault.default(_unescapeMapJsDefault.default);

},{"./_createEscaper.js":"521Gb","./_unescapeMap.js":"e8pRT","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e8pRT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _invertJs = require("./invert.js");
var _invertJsDefault = parcelHelpers.interopDefault(_invertJs);
var _escapeMapJs = require("./_escapeMap.js");
var _escapeMapJsDefault = parcelHelpers.interopDefault(_escapeMapJs);
exports.default = _invertJsDefault.default(_escapeMapJsDefault.default);

},{"./invert.js":"hY4ge","./_escapeMap.js":"fPOAI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"69goE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
exports.default = _underscoreJsDefault.default.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
};

},{"./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hyJUN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defaultsJs = require("./defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _templateSettingsJs = require("./templateSettings.js");
// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;
// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
};
var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match) {
    return '\\' + escapes[match];
}
// In order to prevent third-party code injection through
// `_.templateSettings.variable`, we test it against the following regular
// expression. It is intentionally a bit more liberal than just matching valid
// identifiers, but still prevents possible loopholes through defaults or
// destructuring assignment.
var bareIdentifier = /^\s*(\w|\$)+\s*$/;
function template1(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _defaultsJsDefault.default({
    }, settings, _underscoreJsDefault.default.templateSettings);
    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');
    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
        index = offset + match.length;
        if (escape) source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        else if (interpolate) source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        else if (evaluate) source += "';\n" + evaluate + "\n__p+='";
        // Adobe VMs need the match returned to produce the correct offset.
        return match;
    });
    source += "';\n";
    var argument = settings.variable;
    if (argument) {
        // Insure against third-party code injection. (CVE-2021-23358)
        if (!bareIdentifier.test(argument)) throw new Error('variable is not a bare identifier: ' + argument);
    } else {
        // If a variable is not specified, place data values in local scope.
        source = 'with(obj||{}){\n' + source + '}\n';
        argument = 'obj';
    }
    source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
    var render;
    try {
        render = new Function(argument, '_', source);
    } catch (e) {
        e.source = source;
        throw e;
    }
    var template = function(data) {
        return render.call(this, data, _underscoreJsDefault.default);
    };
    // Provide the compiled source as a convenience for precompilation.
    template.source = 'function(' + argument + '){\n' + source + '}';
    return template;
}
exports.default = template1;

},{"./defaults.js":"fFxIE","./underscore.js":"hjck8","./templateSettings.js":"69goE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jjeXL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
function result(obj, path, fallback) {
    path = _toPathJsDefault.default(path);
    var length = path.length;
    if (!length) return _isFunctionJsDefault.default(fallback) ? fallback.call(obj) : fallback;
    for(var i = 0; i < length; i++){
        var prop = obj == null ? void 0 : obj[path[i]];
        if (prop === void 0) {
            prop = fallback;
            i = length; // Ensure we don't continue iterating.
        }
        obj = _isFunctionJsDefault.default(prop) ? prop.call(obj) : prop;
    }
    return obj;
}
exports.default = result;

},{"./isFunction.js":"kDkjm","./_toPath.js":"2PZbF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aS6hE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
function uniqueId(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
}
exports.default = uniqueId;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"h8Igg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
function chain(obj) {
    var instance = _underscoreJsDefault.default(obj);
    instance._chain = true;
    return instance;
}
exports.default = chain;

},{"./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hLcX3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _executeBoundJs = require("./_executeBound.js");
var _executeBoundJsDefault = parcelHelpers.interopDefault(_executeBoundJs);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = _restArgumentsJsDefault.default(function(func, boundArgs) {
    var placeholder = partial.placeholder;
    var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for(var i = 0; i < length; i++)args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        while(position < arguments.length)args.push(arguments[position++]);
        return _executeBoundJsDefault.default(func, bound, this, this, args);
    };
    return bound;
});
partial.placeholder = _underscoreJsDefault.default;
exports.default = partial;

},{"./restArguments.js":"aKoU9","./_executeBound.js":"bOLKm","./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bOLKm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = _baseCreateJsDefault.default(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_isObjectJsDefault.default(result)) return result;
    return self;
}
exports.default = executeBound;

},{"./_baseCreate.js":"3vxk9","./isObject.js":"fewdV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"48NsZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _executeBoundJs = require("./_executeBound.js");
var _executeBoundJsDefault = parcelHelpers.interopDefault(_executeBoundJs);
exports.default = _restArgumentsJsDefault.default(function(func, context, args) {
    if (!_isFunctionJsDefault.default(func)) throw new TypeError('Bind must be called on a function');
    var bound = _restArgumentsJsDefault.default(function(callArgs) {
        return _executeBoundJsDefault.default(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
});

},{"./restArguments.js":"aKoU9","./isFunction.js":"kDkjm","./_executeBound.js":"bOLKm","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9u5NU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _bindJs = require("./bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
exports.default = _restArgumentsJsDefault.default(function(obj, keys) {
    keys = _flattenJsDefault.default(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while(index--){
        var key = keys[index];
        obj[key] = _bindJsDefault.default(obj[key], obj);
    }
    return obj;
});

},{"./restArguments.js":"aKoU9","./_flatten.js":"2sSP7","./bind.js":"48NsZ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2sSP7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
function flatten(input, depth, strict, output) {
    output = output || [];
    if (!depth && depth !== 0) depth = Infinity;
    else if (depth <= 0) return output.concat(input);
    var idx = output.length;
    for(var i = 0, length = _getLengthJsDefault.default(input); i < length; i++){
        var value = input[i];
        if (_isArrayLikeJsDefault.default(value) && (_isArrayJsDefault.default(value) || _isArgumentsJsDefault.default(value))) {
            // Flatten current level of array or arguments object.
            if (depth > 1) {
                flatten(value, depth - 1, strict, output);
                idx = output.length;
            } else {
                var j = 0, len = value.length;
                while(j < len)output[idx++] = value[j++];
            }
        } else if (!strict) output[idx++] = value;
    }
    return output;
}
exports.default = flatten;

},{"./_getLength.js":"30FQX","./_isArrayLike.js":"5QMnd","./isArray.js":"oMlWT","./isArguments.js":"ccahD","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5QMnd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createSizePropertyCheckJs = require("./_createSizePropertyCheck.js");
var _createSizePropertyCheckJsDefault = parcelHelpers.interopDefault(_createSizePropertyCheckJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
exports.default = _createSizePropertyCheckJsDefault.default(_getLengthJsDefault.default);

},{"./_createSizePropertyCheck.js":"b727b","./_getLength.js":"30FQX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ceNZR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
function memoize1(func, hasher) {
    var memoize = function(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!_hasJsDefault.default(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
    };
    memoize.cache = {
    };
    return memoize;
}
exports.default = memoize1;

},{"./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k0bcV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
exports.default = _restArgumentsJsDefault.default(function(func, wait, args) {
    return setTimeout(function() {
        return func.apply(null, args);
    }, wait);
});

},{"./restArguments.js":"aKoU9","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5pRfB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _delayJs = require("./delay.js");
var _delayJsDefault = parcelHelpers.interopDefault(_delayJs);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
exports.default = _partialJsDefault.default(_delayJsDefault.default, _underscoreJsDefault.default, 1);

},{"./partial.js":"hLcX3","./delay.js":"k0bcV","./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"87yq2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {
    };
    var later = function() {
        previous = options.leading === false ? 0 : _nowJsDefault.default();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
    };
    var throttled = function() {
        var _now = _nowJsDefault.default();
        if (!previous && options.leading === false) previous = _now;
        var remaining = wait - (_now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = _now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);
        return result;
    };
    throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
    };
    return throttled;
}
exports.default = throttle;

},{"./now.js":"fZ1Zl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1Csjh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
function debounce(func, wait, immediate) {
    var timeout, previous, args, result, context;
    var later = function() {
        var passed = _nowJsDefault.default() - previous;
        if (wait > passed) timeout = setTimeout(later, wait - passed);
        else {
            timeout = null;
            if (!immediate) result = func.apply(context, args);
            // This check is needed because `func` can recursively invoke `debounced`.
            if (!timeout) args = context = null;
        }
    };
    var debounced = _restArgumentsJsDefault.default(function(_args) {
        context = this;
        args = _args;
        previous = _nowJsDefault.default();
        if (!timeout) {
            timeout = setTimeout(later, wait);
            if (immediate) result = func.apply(context, args);
        }
        return result;
    });
    debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = args = context = null;
    };
    return debounced;
}
exports.default = debounce;

},{"./restArguments.js":"aKoU9","./now.js":"fZ1Zl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"luJbh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
function wrap(func, wrapper) {
    return _partialJsDefault.default(wrapper, func);
}
exports.default = wrap;

},{"./partial.js":"hLcX3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jleQN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function negate(predicate) {
    return function() {
        return !predicate.apply(this, arguments);
    };
}
exports.default = negate;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"NhC2V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while(i--)result = args[i].call(this, result);
        return result;
    };
}
exports.default = compose;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hdEPt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function after(times, func) {
    return function() {
        if (--times < 1) return func.apply(this, arguments);
    };
}
exports.default = after;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6OzV9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function before(times, func) {
    var memo;
    return function() {
        if (--times > 0) memo = func.apply(this, arguments);
        if (times <= 1) func = null;
        return memo;
    };
}
exports.default = before;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g5TYa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _beforeJs = require("./before.js");
var _beforeJsDefault = parcelHelpers.interopDefault(_beforeJs);
exports.default = _partialJsDefault.default(_beforeJsDefault.default, 2);

},{"./partial.js":"hLcX3","./before.js":"6OzV9","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3zqFY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function findKey(obj, predicate, context) {
    predicate = _cbJsDefault.default(predicate, context);
    var _keys = _keysJsDefault.default(obj), key;
    for(var i = 0, length = _keys.length; i < length; i++){
        key = _keys[i];
        if (predicate(obj[key], key, obj)) return key;
    }
}
exports.default = findKey;

},{"./_cb.js":"l45Ig","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"edEuk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createPredicateIndexFinderJs = require("./_createPredicateIndexFinder.js");
var _createPredicateIndexFinderJsDefault = parcelHelpers.interopDefault(_createPredicateIndexFinderJs);
exports.default = _createPredicateIndexFinderJsDefault.default(1);

},{"./_createPredicateIndexFinder.js":"hE3Ft","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hE3Ft":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
        predicate = _cbJsDefault.default(predicate, context);
        var length = _getLengthJsDefault.default(array);
        var index = dir > 0 ? 0 : length - 1;
        for(; index >= 0 && index < length; index += dir){
            if (predicate(array[index], index, array)) return index;
        }
        return -1;
    };
}
exports.default = createPredicateIndexFinder;

},{"./_cb.js":"l45Ig","./_getLength.js":"30FQX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"akOdX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createPredicateIndexFinderJs = require("./_createPredicateIndexFinder.js");
var _createPredicateIndexFinderJsDefault = parcelHelpers.interopDefault(_createPredicateIndexFinderJs);
exports.default = _createPredicateIndexFinderJsDefault.default(-1);

},{"./_createPredicateIndexFinder.js":"hE3Ft","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4zP4e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
function sortedIndex(array, obj, iteratee, context) {
    iteratee = _cbJsDefault.default(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = _getLengthJsDefault.default(array);
    while(low < high){
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1;
        else high = mid;
    }
    return low;
}
exports.default = sortedIndex;

},{"./_cb.js":"l45Ig","./_getLength.js":"30FQX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"krndY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sortedIndexJs = require("./sortedIndex.js");
var _sortedIndexJsDefault = parcelHelpers.interopDefault(_sortedIndexJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _createIndexFinderJs = require("./_createIndexFinder.js");
var _createIndexFinderJsDefault = parcelHelpers.interopDefault(_createIndexFinderJs);
exports.default = _createIndexFinderJsDefault.default(1, _findIndexJsDefault.default, _sortedIndexJsDefault.default);

},{"./sortedIndex.js":"4zP4e","./findIndex.js":"edEuk","./_createIndexFinder.js":"iqbtD","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iqbtD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _setupJs = require("./_setup.js");
var _isNaNJs = require("./isNaN.js");
var _isNaNJsDefault = parcelHelpers.interopDefault(_isNaNJs);
function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
        var i = 0, length = _getLengthJsDefault.default(array);
        if (typeof idx == 'number') {
            if (dir > 0) i = idx >= 0 ? idx : Math.max(idx + length, i);
            else length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        } else if (sortedIndex && idx && length) {
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
            idx = predicateFind(_setupJs.slice.call(array, i, length), _isNaNJsDefault.default);
            return idx >= 0 ? idx + i : -1;
        }
        for(idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir){
            if (array[idx] === item) return idx;
        }
        return -1;
    };
}
exports.default = createIndexFinder;

},{"./_getLength.js":"30FQX","./_setup.js":"bU4rb","./isNaN.js":"3kTfb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4BWXf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findLastIndexJs = require("./findLastIndex.js");
var _findLastIndexJsDefault = parcelHelpers.interopDefault(_findLastIndexJs);
var _createIndexFinderJs = require("./_createIndexFinder.js");
var _createIndexFinderJsDefault = parcelHelpers.interopDefault(_createIndexFinderJs);
exports.default = _createIndexFinderJsDefault.default(-1, _findLastIndexJsDefault.default);

},{"./findLastIndex.js":"akOdX","./_createIndexFinder.js":"iqbtD","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"doTH0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _findKeyJs = require("./findKey.js");
var _findKeyJsDefault = parcelHelpers.interopDefault(_findKeyJs);
function find(obj, predicate, context) {
    var keyFinder = _isArrayLikeJsDefault.default(obj) ? _findIndexJsDefault.default : _findKeyJsDefault.default;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
}
exports.default = find;

},{"./_isArrayLike.js":"5QMnd","./findIndex.js":"edEuk","./findKey.js":"3zqFY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k1pe6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
function findWhere(obj, attrs) {
    return _findJsDefault.default(obj, _matcherJsDefault.default(attrs));
}
exports.default = findWhere;

},{"./find.js":"doTH0","./matcher.js":"ekXoC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ewQpM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function each(obj, iteratee, context) {
    iteratee = _optimizeCbJsDefault.default(iteratee, context);
    var i, length;
    if (_isArrayLikeJsDefault.default(obj)) for(i = 0, length = obj.length; i < length; i++)iteratee(obj[i], i, obj);
    else {
        var _keys = _keysJsDefault.default(obj);
        for(i = 0, length = _keys.length; i < length; i++)iteratee(obj[_keys[i]], _keys[i], obj);
    }
    return obj;
}
exports.default = each;

},{"./_optimizeCb.js":"cAw5c","./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"giPqo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function map(obj, iteratee, context) {
    iteratee = _cbJsDefault.default(iteratee, context);
    var _keys = !_isArrayLikeJsDefault.default(obj) && _keysJsDefault.default(obj), length = (_keys || obj).length, results = Array(length);
    for(var index = 0; index < length; index++){
        var currentKey = _keys ? _keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
}
exports.default = map;

},{"./_cb.js":"l45Ig","./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aPzI9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createReduceJs = require("./_createReduce.js");
var _createReduceJsDefault = parcelHelpers.interopDefault(_createReduceJs);
exports.default = _createReduceJsDefault.default(1);

},{"./_createReduce.js":"a1vBW","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"a1vBW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
function createReduce(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
        var _keys = !_isArrayLikeJsDefault.default(obj) && _keysJsDefault.default(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
        if (!initial) {
            memo = obj[_keys ? _keys[index] : index];
            index += dir;
        }
        for(; index >= 0 && index < length; index += dir){
            var currentKey = _keys ? _keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
    };
    return function(obj, iteratee, memo, context) {
        var initial = arguments.length >= 3;
        return reducer(obj, _optimizeCbJsDefault.default(iteratee, context, 4), memo, initial);
    };
}
exports.default = createReduce;

},{"./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","./_optimizeCb.js":"cAw5c","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1xJDA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createReduceJs = require("./_createReduce.js");
var _createReduceJsDefault = parcelHelpers.interopDefault(_createReduceJs);
exports.default = _createReduceJsDefault.default(-1);

},{"./_createReduce.js":"a1vBW","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eA6Gs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function filter(obj, predicate, context) {
    var results = [];
    predicate = _cbJsDefault.default(predicate, context);
    _eachJsDefault.default(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
    });
    return results;
}
exports.default = filter;

},{"./_cb.js":"l45Ig","./each.js":"ewQpM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bnI9j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
function reject(obj, predicate, context) {
    return _filterJsDefault.default(obj, _negateJsDefault.default(_cbJsDefault.default(predicate)), context);
}
exports.default = reject;

},{"./filter.js":"eA6Gs","./negate.js":"jleQN","./_cb.js":"l45Ig","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cWFVa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function every(obj, predicate, context) {
    predicate = _cbJsDefault.default(predicate, context);
    var _keys = !_isArrayLikeJsDefault.default(obj) && _keysJsDefault.default(obj), length = (_keys || obj).length;
    for(var index = 0; index < length; index++){
        var currentKey = _keys ? _keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
}
exports.default = every;

},{"./_cb.js":"l45Ig","./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Watr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function some(obj, predicate, context) {
    predicate = _cbJsDefault.default(predicate, context);
    var _keys = !_isArrayLikeJsDefault.default(obj) && _keysJsDefault.default(obj), length = (_keys || obj).length;
    for(var index = 0; index < length; index++){
        var currentKey = _keys ? _keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
}
exports.default = some;

},{"./_cb.js":"l45Ig","./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ibLHC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _indexOfJs = require("./indexOf.js");
var _indexOfJsDefault = parcelHelpers.interopDefault(_indexOfJs);
function contains(obj, item, fromIndex, guard) {
    if (!_isArrayLikeJsDefault.default(obj)) obj = _valuesJsDefault.default(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _indexOfJsDefault.default(obj, item, fromIndex) >= 0;
}
exports.default = contains;

},{"./_isArrayLike.js":"5QMnd","./values.js":"gylxe","./indexOf.js":"krndY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2PsTm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _deepGetJs = require("./_deepGet.js");
var _deepGetJsDefault = parcelHelpers.interopDefault(_deepGetJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
exports.default = _restArgumentsJsDefault.default(function(obj, path, args) {
    var contextPath, func;
    if (_isFunctionJsDefault.default(path)) func = path;
    else {
        path = _toPathJsDefault.default(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
    }
    return _mapJsDefault.default(obj, function(context) {
        var method = func;
        if (!method) {
            if (contextPath && contextPath.length) context = _deepGetJsDefault.default(context, contextPath);
            if (context == null) return void 0;
            method = context[path];
        }
        return method == null ? method : method.apply(context, args);
    });
});

},{"./restArguments.js":"aKoU9","./isFunction.js":"kDkjm","./map.js":"giPqo","./_deepGet.js":"9J8i1","./_toPath.js":"2PZbF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"16Uqx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
function pluck(obj, key) {
    return _mapJsDefault.default(obj, _propertyJsDefault.default(key));
}
exports.default = pluck;

},{"./map.js":"giPqo","./property.js":"c6Iih","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"68doq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
function where(obj, attrs) {
    return _filterJsDefault.default(obj, _matcherJsDefault.default(attrs));
}
exports.default = where;

},{"./filter.js":"eA6Gs","./matcher.js":"ekXoC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jGJNf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function max(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity, value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = _isArrayLikeJsDefault.default(obj) ? obj : _valuesJsDefault.default(obj);
        for(var i = 0, length = obj.length; i < length; i++){
            value = obj[i];
            if (value != null && value > result) result = value;
        }
    } else {
        iteratee = _cbJsDefault.default(iteratee, context);
        _eachJsDefault.default(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                result = v;
                lastComputed = computed;
            }
        });
    }
    return result;
}
exports.default = max;

},{"./_isArrayLike.js":"5QMnd","./values.js":"gylxe","./_cb.js":"l45Ig","./each.js":"ewQpM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c6yfU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function min(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity, value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = _isArrayLikeJsDefault.default(obj) ? obj : _valuesJsDefault.default(obj);
        for(var i = 0, length = obj.length; i < length; i++){
            value = obj[i];
            if (value != null && value < result) result = value;
        }
    } else {
        iteratee = _cbJsDefault.default(iteratee, context);
        _eachJsDefault.default(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed < lastComputed || computed === Infinity && result === Infinity) {
                result = v;
                lastComputed = computed;
            }
        });
    }
    return result;
}
exports.default = min;

},{"./_isArrayLike.js":"5QMnd","./values.js":"gylxe","./_cb.js":"l45Ig","./each.js":"ewQpM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7rhS3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sampleJs = require("./sample.js");
var _sampleJsDefault = parcelHelpers.interopDefault(_sampleJs);
function shuffle(obj) {
    return _sampleJsDefault.default(obj, Infinity);
}
exports.default = shuffle;

},{"./sample.js":"1Yno6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1Yno6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _cloneJs = require("./clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
function sample1(obj, n, guard) {
    if (n == null || guard) {
        if (!_isArrayLikeJsDefault.default(obj)) obj = _valuesJsDefault.default(obj);
        return obj[_randomJsDefault.default(obj.length - 1)];
    }
    var sample = _isArrayLikeJsDefault.default(obj) ? _cloneJsDefault.default(obj) : _valuesJsDefault.default(obj);
    var length = _getLengthJsDefault.default(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for(var index = 0; index < n; index++){
        var rand = _randomJsDefault.default(index, last);
        var temp = sample[index];
        sample[index] = sample[rand];
        sample[rand] = temp;
    }
    return sample.slice(0, n);
}
exports.default = sample1;

},{"./_isArrayLike.js":"5QMnd","./clone.js":"agxO3","./values.js":"gylxe","./_getLength.js":"30FQX","./random.js":"jDe0A","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9ldTP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _pluckJs = require("./pluck.js");
var _pluckJsDefault = parcelHelpers.interopDefault(_pluckJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
function sortBy(obj, iteratee, context) {
    var index = 0;
    iteratee = _cbJsDefault.default(iteratee, context);
    return _pluckJsDefault.default(_mapJsDefault.default(obj, function(value, key, list) {
        return {
            value: value,
            index: index++,
            criteria: iteratee(value, key, list)
        };
    }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
    }), 'value');
}
exports.default = sortBy;

},{"./_cb.js":"l45Ig","./pluck.js":"16Uqx","./map.js":"giPqo","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gXyFd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
exports.default = _groupJsDefault.default(function(result, value, key) {
    if (_hasJsDefault.default(result, key)) result[key].push(value);
    else result[key] = [
        value
    ];
});

},{"./_group.js":"ddU4F","./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ddU4F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function group(behavior, partition) {
    return function(obj, iteratee, context) {
        var result = partition ? [
            [],
            []
        ] : {
        };
        iteratee = _cbJsDefault.default(iteratee, context);
        _eachJsDefault.default(obj, function(value, index) {
            var key = iteratee(value, index, obj);
            behavior(result, value, key);
        });
        return result;
    };
}
exports.default = group;

},{"./_cb.js":"l45Ig","./each.js":"ewQpM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8sscK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
exports.default = _groupJsDefault.default(function(result, value, key) {
    result[key] = value;
});

},{"./_group.js":"ddU4F","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"58Fry":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
exports.default = _groupJsDefault.default(function(result, value, key) {
    if (_hasJsDefault.default(result, key)) result[key]++;
    else result[key] = 1;
});

},{"./_group.js":"ddU4F","./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fVFy0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
exports.default = _groupJsDefault.default(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
}, true);

},{"./_group.js":"ddU4F","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9hdGm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _setupJs = require("./_setup.js");
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
    if (!obj) return [];
    if (_isArrayJsDefault.default(obj)) return _setupJs.slice.call(obj);
    if (_isStringJsDefault.default(obj)) // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
    if (_isArrayLikeJsDefault.default(obj)) return _mapJsDefault.default(obj, _identityJsDefault.default);
    return _valuesJsDefault.default(obj);
}
exports.default = toArray;

},{"./isArray.js":"oMlWT","./_setup.js":"bU4rb","./isString.js":"lSLRQ","./_isArrayLike.js":"5QMnd","./map.js":"giPqo","./identity.js":"f05xz","./values.js":"gylxe","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6mXmd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function size(obj) {
    if (obj == null) return 0;
    return _isArrayLikeJsDefault.default(obj) ? obj.length : _keysJsDefault.default(obj).length;
}
exports.default = size;

},{"./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iJky2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
var _keyInObjJs = require("./_keyInObj.js");
var _keyInObjJsDefault = parcelHelpers.interopDefault(_keyInObjJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
exports.default = _restArgumentsJsDefault.default(function(obj, keys) {
    var result = {
    }, iteratee = keys[0];
    if (obj == null) return result;
    if (_isFunctionJsDefault.default(iteratee)) {
        if (keys.length > 1) iteratee = _optimizeCbJsDefault.default(iteratee, keys[1]);
        keys = _allKeysJsDefault.default(obj);
    } else {
        iteratee = _keyInObjJsDefault.default;
        keys = _flattenJsDefault.default(keys, false, false);
        obj = Object(obj);
    }
    for(var i = 0, length = keys.length; i < length; i++){
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
});

},{"./restArguments.js":"aKoU9","./isFunction.js":"kDkjm","./_optimizeCb.js":"cAw5c","./allKeys.js":"gEhlz","./_keyInObj.js":"emMBs","./_flatten.js":"2sSP7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"emMBs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function keyInObj(value, key, obj) {
    return key in obj;
}
exports.default = keyInObj;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7TToI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _pickJs = require("./pick.js");
var _pickJsDefault = parcelHelpers.interopDefault(_pickJs);
exports.default = _restArgumentsJsDefault.default(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_isFunctionJsDefault.default(iteratee)) {
        iteratee = _negateJsDefault.default(iteratee);
        if (keys.length > 1) context = keys[1];
    } else {
        keys = _mapJsDefault.default(_flattenJsDefault.default(keys, false, false), String);
        iteratee = function(value, key) {
            return !_containsJsDefault.default(keys, key);
        };
    }
    return _pickJsDefault.default(obj, iteratee, context);
});

},{"./restArguments.js":"aKoU9","./isFunction.js":"kDkjm","./negate.js":"jleQN","./map.js":"giPqo","./_flatten.js":"2sSP7","./contains.js":"ibLHC","./pick.js":"iJky2","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1fmF2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _initialJs = require("./initial.js");
var _initialJsDefault = parcelHelpers.interopDefault(_initialJs);
function first(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[0];
    return _initialJsDefault.default(array, array.length - n);
}
exports.default = first;

},{"./initial.js":"2Q93K","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2Q93K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function initial(array, n, guard) {
    return _setupJs.slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}
exports.default = initial;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gWLnh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restJs = require("./rest.js");
var _restJsDefault = parcelHelpers.interopDefault(_restJs);
function last(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _restJsDefault.default(array, Math.max(0, array.length - n));
}
exports.default = last;

},{"./rest.js":"l7YiK","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"l7YiK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function rest(array, n, guard) {
    return _setupJs.slice.call(array, n == null || guard ? 1 : n);
}
exports.default = rest;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5geL8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
function compact(array) {
    return _filterJsDefault.default(array, Boolean);
}
exports.default = compact;

},{"./filter.js":"eA6Gs","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kzSeC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
function flatten(array, depth) {
    return _flattenJsDefault.default(array, depth, false);
}
exports.default = flatten;

},{"./_flatten.js":"2sSP7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jGT7e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _differenceJs = require("./difference.js");
var _differenceJsDefault = parcelHelpers.interopDefault(_differenceJs);
exports.default = _restArgumentsJsDefault.default(function(array, otherArrays) {
    return _differenceJsDefault.default(array, otherArrays);
});

},{"./restArguments.js":"aKoU9","./difference.js":"iJk2V","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iJk2V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
exports.default = _restArgumentsJsDefault.default(function(array, rest) {
    rest = _flattenJsDefault.default(rest, true, true);
    return _filterJsDefault.default(array, function(value) {
        return !_containsJsDefault.default(rest, value);
    });
});

},{"./restArguments.js":"aKoU9","./_flatten.js":"2sSP7","./filter.js":"eA6Gs","./contains.js":"ibLHC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ci6Hh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isBooleanJs = require("./isBoolean.js");
var _isBooleanJsDefault = parcelHelpers.interopDefault(_isBooleanJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
function uniq(array, isSorted, iteratee, context) {
    if (!_isBooleanJsDefault.default(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
    }
    if (iteratee != null) iteratee = _cbJsDefault.default(iteratee, context);
    var result = [];
    var seen = [];
    for(var i = 0, length = _getLengthJsDefault.default(array); i < length; i++){
        var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted && !iteratee) {
            if (!i || seen !== computed) result.push(value);
            seen = computed;
        } else if (iteratee) {
            if (!_containsJsDefault.default(seen, computed)) {
                seen.push(computed);
                result.push(value);
            }
        } else if (!_containsJsDefault.default(result, value)) result.push(value);
    }
    return result;
}
exports.default = uniq;

},{"./isBoolean.js":"ffqST","./_cb.js":"l45Ig","./_getLength.js":"30FQX","./contains.js":"ibLHC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9B8VJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _uniqJs = require("./uniq.js");
var _uniqJsDefault = parcelHelpers.interopDefault(_uniqJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
exports.default = _restArgumentsJsDefault.default(function(arrays) {
    return _uniqJsDefault.default(_flattenJsDefault.default(arrays, true, true));
});

},{"./restArguments.js":"aKoU9","./uniq.js":"ci6Hh","./_flatten.js":"2sSP7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9e2VQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
function intersection(array) {
    var result = [];
    var argsLength = arguments.length;
    for(var i = 0, length = _getLengthJsDefault.default(array); i < length; i++){
        var item = array[i];
        if (_containsJsDefault.default(result, item)) continue;
        var j;
        for(j = 1; j < argsLength; j++){
            if (!_containsJsDefault.default(arguments[j], item)) break;
        }
        if (j === argsLength) result.push(item);
    }
    return result;
}
exports.default = intersection;

},{"./_getLength.js":"30FQX","./contains.js":"ibLHC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8xaCn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _maxJs = require("./max.js");
var _maxJsDefault = parcelHelpers.interopDefault(_maxJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _pluckJs = require("./pluck.js");
var _pluckJsDefault = parcelHelpers.interopDefault(_pluckJs);
function unzip(array) {
    var length = array && _maxJsDefault.default(array, _getLengthJsDefault.default).length || 0;
    var result = Array(length);
    for(var index = 0; index < length; index++)result[index] = _pluckJsDefault.default(array, index);
    return result;
}
exports.default = unzip;

},{"./max.js":"jGJNf","./_getLength.js":"30FQX","./pluck.js":"16Uqx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"LKE7e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
exports.default = _restArgumentsJsDefault.default(_unzipJsDefault.default);

},{"./restArguments.js":"aKoU9","./unzip.js":"8xaCn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3kVS9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
function object(list, values) {
    var result = {
    };
    for(var i = 0, length = _getLengthJsDefault.default(list); i < length; i++)if (values) result[list[i]] = values[i];
    else result[list[i][0]] = list[i][1];
    return result;
}
exports.default = object;

},{"./_getLength.js":"30FQX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6d5vI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function range1(start, stop, step) {
    if (stop == null) {
        stop = start || 0;
        start = 0;
    }
    if (!step) step = stop < start ? -1 : 1;
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);
    for(var idx = 0; idx < length; idx++, start += step)range[idx] = start;
    return range;
}
exports.default = range1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bTQIh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function chunk(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while(i < length)result.push(_setupJs.slice.call(array, i, i += count));
    return result;
}
exports.default = chunk;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Jc5x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _functionsJs = require("./functions.js");
var _functionsJsDefault = parcelHelpers.interopDefault(_functionsJs);
var _setupJs = require("./_setup.js");
var _chainResultJs = require("./_chainResult.js");
var _chainResultJsDefault = parcelHelpers.interopDefault(_chainResultJs);
function mixin(obj) {
    _eachJsDefault.default(_functionsJsDefault.default(obj), function(name) {
        var func = _underscoreJsDefault.default[name] = obj[name];
        _underscoreJsDefault.default.prototype[name] = function() {
            var args = [
                this._wrapped
            ];
            _setupJs.push.apply(args, arguments);
            return _chainResultJsDefault.default(this, func.apply(_underscoreJsDefault.default, args));
        };
    });
    return _underscoreJsDefault.default;
}
exports.default = mixin;

},{"./underscore.js":"hjck8","./each.js":"ewQpM","./functions.js":"aQpNB","./_setup.js":"bU4rb","./_chainResult.js":"lic3h","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lic3h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
function chainResult(instance, obj) {
    return instance._chain ? _underscoreJsDefault.default(obj).chain() : obj;
}
exports.default = chainResult;

},{"./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ehthA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _setupJs = require("./_setup.js");
var _chainResultJs = require("./_chainResult.js");
var _chainResultJsDefault = parcelHelpers.interopDefault(_chainResultJs);
// Add all mutator `Array` functions to the wrapper.
_eachJsDefault.default([
    'pop',
    'push',
    'reverse',
    'shift',
    'sort',
    'splice',
    'unshift'
], function(name) {
    var method = _setupJs.ArrayProto[name];
    _underscoreJsDefault.default.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
            method.apply(obj, arguments);
            if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
        }
        return _chainResultJsDefault.default(this, obj);
    };
});
// Add all accessor `Array` functions to the wrapper.
_eachJsDefault.default([
    'concat',
    'join',
    'slice'
], function(name) {
    var method = _setupJs.ArrayProto[name];
    _underscoreJsDefault.default.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) obj = method.apply(obj, arguments);
        return _chainResultJsDefault.default(this, obj);
    };
});
exports.default = _underscoreJsDefault.default;

},{"./underscore.js":"hjck8","./each.js":"ewQpM","./_setup.js":"bU4rb","./_chainResult.js":"lic3h","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6Ena2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sectionHeader", ()=>sectionHeader
);
parcelHelpers.export(exports, "showGraphMinDegree", ()=>showGraphMinDegree
);
parcelHelpers.export(exports, "showGraphMaxDegree", ()=>showGraphMaxDegree
);
parcelHelpers.export(exports, "getVertexId", ()=>getVertexId
);
parcelHelpers.export(exports, "getVertexDegree", ()=>getVertexDegree
);
parcelHelpers.export(exports, "getVertexNeighborhood", ()=>getVertexNeighborhood
);
parcelHelpers.export(exports, "showGraphRegular", ()=>showGraphRegular
);
parcelHelpers.export(exports, "showGroups", ()=>showGroups
);
parcelHelpers.export(exports, "showAdjacencyMatrix", ()=>showAdjacencyMatrix
);
parcelHelpers.export(exports, "greedyColoring", ()=>greedyColoring
);
parcelHelpers.export(exports, "resetColoring", ()=>resetColoring
);
parcelHelpers.export(exports, "showChromaticNumber", ()=>showChromaticNumber
);
parcelHelpers.export(exports, "showBiparte", ()=>showBiparte
);
parcelHelpers.export(exports, "checkComponents", ()=>checkComponents
);
parcelHelpers.export(exports, "showCompleteGraph", ()=>showCompleteGraph
);
parcelHelpers.export(exports, "showTrivialGraph", ()=>showTrivialGraph
);
parcelHelpers.export(exports, "showCycles", ()=>showCycles
);
parcelHelpers.export(exports, "showTrees", ()=>showTrees
);
function sectionHeader(text) {
    var l = "\\[\\large{\\text{" + text + "}} \\]";
    return l;
}
function showGraphMinDegree() {
    var vertices = window.graph.graphVertices;
    var minDeg = Infinity;
    vertices.forEach(function(v) {
        if (v.degree < minDeg) minDeg = v.degree;
    });
    var l = "";
    if (vertices.length) l += "\\[\\delta(G)=" + minDeg + "\\]";
    else l += "\\[G \\hspace{10px} is \\hspace{10px} null\\]";
    return l;
}
function showGraphMaxDegree() {
    var vertices = window.graph.graphVertices;
    var maxDeg = 0;
    vertices.forEach(function(v) {
        if (v.degree > maxDeg) maxDeg = v.degree;
    });
    var l;
    if (vertices.length) l = "\\[\\Delta(G)=" + maxDeg + "\\]";
    else l = "\\[G \\hspace{10px} is \\hspace{10px} null\\]";
    return l;
}
function getVertexId(vertex) {
    var v = "\\[v_{" + vertex.id + "}" + "\\]";
    return v;
}
function getVertexDegree(vertex) {
    var l = "\\[\\delta_{G}(v_{" + vertex.id + "}" + ")=" + vertex.degree + "\\]";
    return l;
}
function vertexNeighborhood(vertex) {
    var edges = vertex.edges || [];
    return edges.map((it)=>it.target.id != vertex.id ? it.target.id : it.source.id
    );
}
function getVertexNeighborhood(vertex) {
    var neighborhood = vertexNeighborhood(vertex);
    // console.log("getVertexNeighborhood", { neighborhood });
    var e = "\\[\\Gamma_{G}(v_{" + vertex.id + "})=\\{";
    for(let i = 0; i < neighborhood.length; i++){
        if (i == neighborhood.length - 1) e += "v_{" + neighborhood[i] + "}";
        else e += "v_{" + neighborhood[i] + "}" + ",";
        //add line break
        if ((i + 1) % 10 == 0) e += "\\\\";
    }
    e += "\\}\\]";
    // console.log("getVertexNeighborhood 2", { neighborhood, e });
    return e;
}
function showGraphRegular() {
    var vertices = window.graph.graphVertices;
    var degSeq = vertices.map(function(v) {
        return v.degree;
    });
    //sort in decreasing order
    degSeq.sort(function(a, b) {
        return b - a;
    });
    //test if graph is regular
    var flag = false;
    if (degSeq.length > 0) flag = true;
    for(var i = 0; i < degSeq.length - 1; i++)if (degSeq[i] != degSeq[i + 1]) {
        flag = false;
        break;
    }
    var l = "";
    // var l = "\\[\\text{Degree Sequence}=(";
    // degSeq.forEach(function(d, i) {
    //     if (i !== degSeq.length - 1) l += d + ",";
    //     else l += d;
    //     if (i % 15 == 14) l += "\\\\";
    // });
    // l += ")\\]";
    if (flag) l += "\\[\\text{Grafo é \\(" + degSeq[0] + "\\)-regular de ordem }" + degSeq.length + "\\]";
    else l += "\\[\\text{Grafo não é k-regular.}\\]";
    return l;
}
function showGroups(vertices, edges) {
    var v = "\\[V=\\{";
    for(let i = 0; i < vertices.length; i++){
        if (i == 0) v += "v_{" + vertices[i].id + "}";
        else v += ",v_{" + vertices[i].id + "}";
        if ((i + 1) % 15 == 0) v += "\\\\";
    }
    v += "\\}\\]";
    var e = "\\[E=\\{";
    for(let i1 = 0; i1 < edges.length; i1++){
        if (i1 == edges.length - 1) e += "(v_{" + edges[i1].source.id + "}" + "v_{" + edges[i1].target.id + "}" + ")";
        else e += "(\\color{0}{v_{" + edges[i1].source.id + "}}" + "v_{" + edges[i1].target.id + "}" + ")" + ",";
        if ((i1 + 1) % 10 == 0) e += "\\\\";
    }
    e += "\\}\\]";
    e += "\\[\\text{|V| = }" + vertices.length + "\\]";
    e += "\\[\\text{|E| = }" + edges.length + "\\]";
    return v + e;
}
function showAdjacencyMatrix() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    var l = "";
    l += "\\[\\text{Matriz de adjacência}\\]";
    l += "\\[\\begin{pmatrix}";
    var a = [];
    for(let i = 0; i < vertices.length; i++){
        for(let j = 0; j < vertices.length; j++){
            var value;
            if (i == j) value = 0;
            else value = vertices[i].edges.filter((e)=>e.source.id == vertices[j].id || e.target.id == vertices[j].id
            ).length > 0 ? 1 : 0;
            var and = j == vertices.length - 1 ? "" : " & ";
            l += "" + value + and;
        }
        l += "\\";
        l += "\\";
    }
    l += "\\end{pmatrix}\\]";
    return l;
}
function greedyColoring(vertices) {
    const colors = vertices.map((it, index)=>index
    );
    const colorsResult = [];
    var result = [];
    vertices.forEach((v)=>{
        const usedColors = [];
        v.edges.forEach((edge, i)=>{
            var neighbour = vertices.find((it, _)=>it.id == edge.target.id || it.id == edge.source.id
            );
            usedColors.push(neighbour.color);
        });
        var color = colors.find((it, _)=>!usedColors.includes(it)
        );
        if (colorsResult.indexOf(color) === -1) colorsResult.push(color);
        v.color = color;
        result.push(v);
    });
    window.graph.graphVertices = result;
    window.graph.chromaticNumber = colorsResult.length;
    // console.log("GREEDY/final", {
    //     result,
    //     colors,
    //     graph: window.graph,
    //     colorsResult,
    // });
    window.graph.restartGraph();
}
function resetColoring(vertices) {
    window.graph.graphVertices = vertices.map((e)=>({
            ...e,
            color: null
        })
    );
    window.graph.restartGraph();
    window.graph.chromaticNumber = 0;
}
function showChromaticNumber(chromaticNumber) {
    // var l = "\\[\\text{Número crômatico é } \\chi = " + chromaticNumber + "\\]";
    var l = "\\[\\chi = " + chromaticNumber + "\\]";
    return l;
}
function showBiparte(isBipartite) {
    var vertices = window.graph.graphVertices;
    var l = "";
    if (isBipartite) {
        var setA = "", setB = "";
        var countA = 0, countB = 0;
        vertices.forEach(function(v) {
            if (v.color % 2 == 0) {
                countA++;
                setA += "v_{" + v.id + "},";
                if (countA % 12 == 0) setA += "\\\\";
            } else if (v.color % 2 == 1) {
                countB++;
                setB += "v_{" + v.id + "},";
                if (countB % 12 == 0) setB += "\\\\";
            }
        });
        //modify sets to make Latex text look nicer
        if (countA % 12 == 0) setA = setA.slice(0, -3);
        else setA = setA.slice(0, -1);
        if (countB % 12 == 0) setB = setB.slice(0, -3);
        else setB = setB.slice(0, -1);
        l += "\\[\\text{O grafo é bipartido!}\\]";
        l += "\\[\\text{Conjunto } A = \\{" + setA + "\\} \\]";
        l += "\\[\\text{Conjunto } B = \\{" + setB + "\\} \\]";
    } else if (isBipartite != false) l = "\\[\\text{O grafo não é bipartido.}\\]";
    else l = "\\[\\text{O grafo não é bipartido.}\\]";
    return l;
}
function checkComponents() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    if (vertices.length == 0) {
        componentCount = 0;
        return showComponents(componentCount);
    }
    componentCount = 1;
    //construct adjacency list of graph
    var adjList = {
    };
    vertices.forEach(function(v) {
        v.visited = false;
        adjList[v.id] = [];
    });
    edges.forEach(function(e) {
        adjList[e.source.id].push(vertices.find((v)=>v.id == e.target.id
        ));
        adjList[e.target.id].push(vertices.find((v)=>v.id == e.source.id
        ));
    });
    //perform DFS on vertices
    var q = [];
    q.push(vertices[0]);
    while(q.length > 0){
        var v1 = q.shift();
        var adj = adjList[v1.id];
        for(let i = 0; i < adj.length; i++){
            var v2 = adj[i];
            if (v2.visited) continue;
            q.push(v2);
        }
        v1.visited = true;
        v1.componentId = componentCount;
        //check for unvisited vertices
        if (q.length == 0) {
            for(let i = 0; i < vertices.length; i++)if (!vertices[i].visited) {
                q.push(vertices[i]);
                componentCount++;
                break;
            }
        }
    } //while ends here
    // vertices.style("fill", function(d) {
    //     return colors[d.componentId % 10];
    // });
    return showComponents(componentCount);
}
function showComponents(componentCount) {
    var l = "";
    if (componentCount == 0) l = "\\[\\text{Grafo não contém nenhum componente.}\\]";
    else if (componentCount == 1) l = "\\[\\text{O grafo tem somente um componente.}\\]";
    else l = "\\[\\text{O grafo tem " + componentCount + " componentes. É um grafo desconexo.}\\]";
    return l;
}
function showCompleteGraph() {
    var l = "";
    var degSeq = window.graph.graphVertices.map(function(v) {
        return v.degree;
    });
    //sort in decreasing order
    degSeq.sort(function(a, b) {
        return b - a;
    });
    var order = window.graph.graphVertices.length, size = window.graph.graphEdges.length;
    if (order > 0 && 2 * size == order * (order - 1)) l += "\\[\\text{\xc9 um grafo completo (}K_{" + degSeq.length + "} \\text{).}\\]";
    else l += "\\[\\text{Não é um grafo completo.}\\]";
    return l;
}
function showTrivialGraph() {
    var vertices = window.graph.graphVertices;
    var isTrivial = vertices.length == 1;
    if (isTrivial) return "\\[\\text{É um grafo trivial.}\\]";
    return "\\[\\text{Não é um grafo trivial.}\\]";
}
function checkCycle() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    if (edges.length == 0) return false;
    //construct adjacency list of graph
    //vis keeps track of visited node ids
    var adjList = {
    }, vis = {
    }, parent = {
    };
    vertices.forEach(function(v) {
        v.visited = false;
        adjList[v.id] = [];
        vis[v.id] = false;
    });
    edges.forEach(function(e) {
        adjList[e.source.id].push(e.target.id);
        adjList[e.target.id].push(e.source.id);
    });
    //perform DFS on vertices
    var q = [
        vertices[0].id
    ];
    //-1 means root
    parent[vertices[0].id] = -1;
    var v1, v2;
    while(q.length > 0){
        v1 = q.shift();
        vis[v1] = true;
        for(let i = 0; i < adjList[v1].length; i++){
            v2 = adjList[v1][i];
            if (vis[v2] && parent[v1] != v2) return true;
            if (!vis[v2]) {
                q.push(v2);
                parent[v2] = v1;
            }
        }
    }
    //check for other components
    if (q.length == 0) {
        for(let v in vis)if (!vis[v]) {
            q.push(v);
            parent[v] = -1;
            break;
        }
    }
    return false;
}
function showCycles() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    var l = "";
    //construct adjacency list of graph
    //vis keeps track of visited node ids
    var adjList = {
    }, vis = {
    }, parent = {
    };
    vertices.forEach(function(v) {
        v.visited = false;
        adjList[v.id] = [];
        vis[v.id] = false;
    });
    edges.forEach(function(e) {
        adjList[e.source.id].push(e.target.id);
        adjList[e.target.id].push(e.source.id);
    });
    //perform DFS on vertices
    var q = [
        vertices[0].id
    ];
    //-1 means root
    parent[vertices[0].id] = -1;
    var v1, v2;
    var cycles = 0;
    while(q.length > 0){
        v1 = q.shift();
        vis[v1] = true;
        for(let i = 0; i < adjList[v1].length; i++){
            v2 = adjList[v1][i];
            if (vis[v2] && parent[v1] != v2) cycles += 1;
            if (!vis[v2]) {
                q.push(v2);
                parent[v2] = v1;
            }
        }
        //check for other components
        if (q.length == 0) {
            for(let v in vis)if (!vis[v]) {
                q.push(v);
                parent[v] = -1;
                break;
            }
        }
    } //while ends here
    if (cycles == 0) l += "\\[\\text{O grafo não tem ciclos}\\]";
    else l += "\\[\\text{O grafo tem " + cycles + " ciclos.}\\]";
    return l;
}
function showTrees() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    var l = "";
    if (vertices.length == 0) l = "\\[\\text{Não é uma árvore.}\\]";
    else if (checkCycle()) l = "\\[\\text{Não é uma árvore. Grafo não é acíclico.}\\]";
    else if (vertices.length == edges.length + 1) l = "\\[\\text{É uma árvore.}\\]";
    else l = "\\[\\text{É uma floresta.}\\]";
    return l;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}]},["5pDwl","iglst"], "iglst", "parcelRequire0215")

</script>
<script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"dwKjh":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "dc8b7a0dcb0576bb";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    var parents = getParents(module.bundle.root, id); // If no parents, the asset is new. Prevent reloading the page.
    if (!parents.length) return true;
    return parents.some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"jQACI":[function(require,module,exports) {
var _mainJs = require("./src/main.js");

},{"./src/main.js":"iJDgK"}],"iJDgK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _underscore = require("underscore");
var _underscoreDefault = parcelHelpers.interopDefault(_underscore);
var _fileService = require("./file_service");
var _graph = require("./graph");
window.ctrlKeyIsPressed = false;
document.addEventListener('keydown', function(event) {
    if (event.key == "Control") window.ctrlKeyIsPressed = true;
});
document.addEventListener('keyup', function(event) {
    if (event.key == "Control") window.ctrlKeyIsPressed = false;
});
function togleProperty(event, propertyType) {
    if (event.target.checked) window.graph.propertiesToShow.push(propertyType);
    else window.graph.propertiesToShow = window.graph.propertiesToShow.filter((e)=>e != propertyType
    );
    window.graph.showGraphInfo();
}
document.getElementById('property_groups').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.GROUPS);
});
document.getElementById('property_adjacency-matrix').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.ADJACENCY_MATRIX);
});
document.getElementById('property_trivial').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.TRIVIAL);
});
document.getElementById('property_complete-graph').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.COMPLETE_GRAPH);
});
document.getElementById('property_min-degree').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.MIN_DEGREE);
});
document.getElementById('property_max-degree').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.MAX_DEGREE);
});
document.getElementById('property_regular-graph').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.REGULAR_GRAPH);
});
document.getElementById('property_chromatic-color').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.CHROMATIC_COLOR);
});
document.getElementById('property_bipartite').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.BIPARTITE);
});
// document.getElementById('property_coloring')
//     .addEventListener('change', function(event) {
//         togleProperty(event, PropertyType.COLORING);
//     });
// document.getElementById('property_cycles')
//     .addEventListener('change', function(event) {
//         togleProperty(event, PropertyType.CYCLES);
//     });
document.getElementById('property_trees').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.TREES);
});
document.getElementById('property_components').addEventListener('change', function(event) {
    togleProperty(event, _graph.PropertyType.COMPONENTS);
});
document.getElementById('toggle-vertex-id-input').addEventListener('change', function(event) {
    if (event.target.checked) {
        document.getElementById("toggle-vertex-id-icon").classList.remove("bi-eye");
        document.getElementById("toggle-vertex-id-icon").classList.add("bi-eye-fill");
    } else {
        document.getElementById("toggle-vertex-id-icon").classList.remove("bi-eye-fill");
        document.getElementById("toggle-vertex-id-icon").classList.add("bi-eye");
    }
    window.graph.toggleVertexId();
});
document.getElementById("export").addEventListener('click', function() {
    _fileService.exportGraphMl(window.graph.graphVertices, window.graph.graphEdges);
});

},{"underscore":"dga04","./file_service":"gYrD3","./graph":"c5U8Z","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dga04":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// ESM Exports
// ===========
// This module is the package entry point for ES module users. In other words,
// it is the module they are interfacing with when they import from the whole
// package instead of from a submodule, like this:
//
// ```js
// import { map } from 'underscore';
// ```
//
// The difference with `./index-default`, which is the package entry point for
// CommonJS, AMD and UMD users, is purely technical. In ES modules, named and
// default exports are considered to be siblings, so when you have a default
// export, its properties are not automatically available as named exports. For
// this reason, we re-export the named exports in addition to providing the same
// default export as in `./index-default`.
parcelHelpers.export(exports, "default", ()=>_indexDefaultJsDefault.default
);
var _indexDefaultJs = require("./index-default.js");
var _indexDefaultJsDefault = parcelHelpers.interopDefault(_indexDefaultJs);
var _indexJs = require("./index.js");
parcelHelpers.exportAll(_indexJs, exports);

},{"./index-default.js":"cVW5k","./index.js":"aPH2r","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cVW5k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Default Export
// ==============
// In this module, we mix our bundled exports into the `_` object and export
// the result. This is analogous to setting `module.exports = _` in CommonJS.
// Hence, this module is also the entry point of our UMD bundle and the package
// entry point for CommonJS and AMD users. In other words, this is (the source
// of) the module you are interfacing with when you do any of the following:
//
// ```js
// // CommonJS
// var _ = require('underscore');
//
// // AMD
// define(['underscore'], function(_) {...});
//
// // UMD in the browser
// // _ is available as a global variable
// ```
var _indexJs = require("./index.js");
// Add all of the Underscore functions to the wrapper object.
var _ = _indexJs.mixin(_indexJs);
// Legacy Node.js API.
_._ = _;
exports.default = _;

},{"./index.js":"aPH2r","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aPH2r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Named Exports
// =============
//     Underscore.js 1.13.1
//     https://underscorejs.org
//     (c) 2009-2021 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
// Baseline setup.
parcelHelpers.export(exports, "VERSION", ()=>_setupJs.VERSION
);
parcelHelpers.export(exports, "restArguments", ()=>_restArgumentsJsDefault.default
);
// Object Functions
// ----------------
// Our most fundamental functions operate on any JavaScript object.
// Most functions in Underscore depend on at least one function in this section.
// A group of functions that check the types of core JavaScript values.
// These are often informally referred to as the "isType" functions.
parcelHelpers.export(exports, "isObject", ()=>_isObjectJsDefault.default
);
parcelHelpers.export(exports, "isNull", ()=>_isNullJsDefault.default
);
parcelHelpers.export(exports, "isUndefined", ()=>_isUndefinedJsDefault.default
);
parcelHelpers.export(exports, "isBoolean", ()=>_isBooleanJsDefault.default
);
parcelHelpers.export(exports, "isElement", ()=>_isElementJsDefault.default
);
parcelHelpers.export(exports, "isString", ()=>_isStringJsDefault.default
);
parcelHelpers.export(exports, "isNumber", ()=>_isNumberJsDefault.default
);
parcelHelpers.export(exports, "isDate", ()=>_isDateJsDefault.default
);
parcelHelpers.export(exports, "isRegExp", ()=>_isRegExpJsDefault.default
);
parcelHelpers.export(exports, "isError", ()=>_isErrorJsDefault.default
);
parcelHelpers.export(exports, "isSymbol", ()=>_isSymbolJsDefault.default
);
parcelHelpers.export(exports, "isArrayBuffer", ()=>_isArrayBufferJsDefault.default
);
parcelHelpers.export(exports, "isDataView", ()=>_isDataViewJsDefault.default
);
parcelHelpers.export(exports, "isArray", ()=>_isArrayJsDefault.default
);
parcelHelpers.export(exports, "isFunction", ()=>_isFunctionJsDefault.default
);
parcelHelpers.export(exports, "isArguments", ()=>_isArgumentsJsDefault.default
);
parcelHelpers.export(exports, "isFinite", ()=>_isFiniteJsDefault.default
);
parcelHelpers.export(exports, "isNaN", ()=>_isNaNJsDefault.default
);
parcelHelpers.export(exports, "isTypedArray", ()=>_isTypedArrayJsDefault.default
);
parcelHelpers.export(exports, "isEmpty", ()=>_isEmptyJsDefault.default
);
parcelHelpers.export(exports, "isMatch", ()=>_isMatchJsDefault.default
);
parcelHelpers.export(exports, "isEqual", ()=>_isEqualJsDefault.default
);
parcelHelpers.export(exports, "isMap", ()=>_isMapJsDefault.default
);
parcelHelpers.export(exports, "isWeakMap", ()=>_isWeakMapJsDefault.default
);
parcelHelpers.export(exports, "isSet", ()=>_isSetJsDefault.default
);
parcelHelpers.export(exports, "isWeakSet", ()=>_isWeakSetJsDefault.default
);
// Functions that treat an object as a dictionary of key-value pairs.
parcelHelpers.export(exports, "keys", ()=>_keysJsDefault.default
);
parcelHelpers.export(exports, "allKeys", ()=>_allKeysJsDefault.default
);
parcelHelpers.export(exports, "values", ()=>_valuesJsDefault.default
);
parcelHelpers.export(exports, "pairs", ()=>_pairsJsDefault.default
);
parcelHelpers.export(exports, "invert", ()=>_invertJsDefault.default
);
parcelHelpers.export(exports, "functions", ()=>_functionsJsDefault.default
);
parcelHelpers.export(exports, "methods", ()=>_functionsJsDefault.default
);
parcelHelpers.export(exports, "extend", ()=>_extendJsDefault.default
);
parcelHelpers.export(exports, "extendOwn", ()=>_extendOwnJsDefault.default
);
parcelHelpers.export(exports, "assign", ()=>_extendOwnJsDefault.default
);
parcelHelpers.export(exports, "defaults", ()=>_defaultsJsDefault.default
);
parcelHelpers.export(exports, "create", ()=>_createJsDefault.default
);
parcelHelpers.export(exports, "clone", ()=>_cloneJsDefault.default
);
parcelHelpers.export(exports, "tap", ()=>_tapJsDefault.default
);
parcelHelpers.export(exports, "get", ()=>_getJsDefault.default
);
parcelHelpers.export(exports, "has", ()=>_hasJsDefault.default
);
parcelHelpers.export(exports, "mapObject", ()=>_mapObjectJsDefault.default
);
// Utility Functions
// -----------------
// A bit of a grab bag: Predicate-generating functions for use with filters and
// loops, string escaping and templating, create random numbers and unique ids,
// and functions that facilitate Underscore's chaining and iteration conventions.
parcelHelpers.export(exports, "identity", ()=>_identityJsDefault.default
);
parcelHelpers.export(exports, "constant", ()=>_constantJsDefault.default
);
parcelHelpers.export(exports, "noop", ()=>_noopJsDefault.default
);
parcelHelpers.export(exports, "toPath", ()=>_toPathJsDefault.default
);
parcelHelpers.export(exports, "property", ()=>_propertyJsDefault.default
);
parcelHelpers.export(exports, "propertyOf", ()=>_propertyOfJsDefault.default
);
parcelHelpers.export(exports, "matcher", ()=>_matcherJsDefault.default
);
parcelHelpers.export(exports, "matches", ()=>_matcherJsDefault.default
);
parcelHelpers.export(exports, "times", ()=>_timesJsDefault.default
);
parcelHelpers.export(exports, "random", ()=>_randomJsDefault.default
);
parcelHelpers.export(exports, "now", ()=>_nowJsDefault.default
);
parcelHelpers.export(exports, "escape", ()=>_escapeJsDefault.default
);
parcelHelpers.export(exports, "unescape", ()=>_unescapeJsDefault.default
);
parcelHelpers.export(exports, "templateSettings", ()=>_templateSettingsJsDefault.default
);
parcelHelpers.export(exports, "template", ()=>_templateJsDefault.default
);
parcelHelpers.export(exports, "result", ()=>_resultJsDefault.default
);
parcelHelpers.export(exports, "uniqueId", ()=>_uniqueIdJsDefault.default
);
parcelHelpers.export(exports, "chain", ()=>_chainJsDefault.default
);
parcelHelpers.export(exports, "iteratee", ()=>_iterateeJsDefault.default
);
// Function (ahem) Functions
// -------------------------
// These functions take a function as an argument and return a new function
// as the result. Also known as higher-order functions.
parcelHelpers.export(exports, "partial", ()=>_partialJsDefault.default
);
parcelHelpers.export(exports, "bind", ()=>_bindJsDefault.default
);
parcelHelpers.export(exports, "bindAll", ()=>_bindAllJsDefault.default
);
parcelHelpers.export(exports, "memoize", ()=>_memoizeJsDefault.default
);
parcelHelpers.export(exports, "delay", ()=>_delayJsDefault.default
);
parcelHelpers.export(exports, "defer", ()=>_deferJsDefault.default
);
parcelHelpers.export(exports, "throttle", ()=>_throttleJsDefault.default
);
parcelHelpers.export(exports, "debounce", ()=>_debounceJsDefault.default
);
parcelHelpers.export(exports, "wrap", ()=>_wrapJsDefault.default
);
parcelHelpers.export(exports, "negate", ()=>_negateJsDefault.default
);
parcelHelpers.export(exports, "compose", ()=>_composeJsDefault.default
);
parcelHelpers.export(exports, "after", ()=>_afterJsDefault.default
);
parcelHelpers.export(exports, "before", ()=>_beforeJsDefault.default
);
parcelHelpers.export(exports, "once", ()=>_onceJsDefault.default
);
// Finders
// -------
// Functions that extract (the position of) a single element from an object
// or array based on some criterion.
parcelHelpers.export(exports, "findKey", ()=>_findKeyJsDefault.default
);
parcelHelpers.export(exports, "findIndex", ()=>_findIndexJsDefault.default
);
parcelHelpers.export(exports, "findLastIndex", ()=>_findLastIndexJsDefault.default
);
parcelHelpers.export(exports, "sortedIndex", ()=>_sortedIndexJsDefault.default
);
parcelHelpers.export(exports, "indexOf", ()=>_indexOfJsDefault.default
);
parcelHelpers.export(exports, "lastIndexOf", ()=>_lastIndexOfJsDefault.default
);
parcelHelpers.export(exports, "find", ()=>_findJsDefault.default
);
parcelHelpers.export(exports, "detect", ()=>_findJsDefault.default
);
parcelHelpers.export(exports, "findWhere", ()=>_findWhereJsDefault.default
);
// Collection Functions
// --------------------
// Functions that work on any collection of elements: either an array, or
// an object of key-value pairs.
parcelHelpers.export(exports, "each", ()=>_eachJsDefault.default
);
parcelHelpers.export(exports, "forEach", ()=>_eachJsDefault.default
);
parcelHelpers.export(exports, "map", ()=>_mapJsDefault.default
);
parcelHelpers.export(exports, "collect", ()=>_mapJsDefault.default
);
parcelHelpers.export(exports, "reduce", ()=>_reduceJsDefault.default
);
parcelHelpers.export(exports, "foldl", ()=>_reduceJsDefault.default
);
parcelHelpers.export(exports, "inject", ()=>_reduceJsDefault.default
);
parcelHelpers.export(exports, "reduceRight", ()=>_reduceRightJsDefault.default
);
parcelHelpers.export(exports, "foldr", ()=>_reduceRightJsDefault.default
);
parcelHelpers.export(exports, "filter", ()=>_filterJsDefault.default
);
parcelHelpers.export(exports, "select", ()=>_filterJsDefault.default
);
parcelHelpers.export(exports, "reject", ()=>_rejectJsDefault.default
);
parcelHelpers.export(exports, "every", ()=>_everyJsDefault.default
);
parcelHelpers.export(exports, "all", ()=>_everyJsDefault.default
);
parcelHelpers.export(exports, "some", ()=>_someJsDefault.default
);
parcelHelpers.export(exports, "any", ()=>_someJsDefault.default
);
parcelHelpers.export(exports, "contains", ()=>_containsJsDefault.default
);
parcelHelpers.export(exports, "includes", ()=>_containsJsDefault.default
);
parcelHelpers.export(exports, "include", ()=>_containsJsDefault.default
);
parcelHelpers.export(exports, "invoke", ()=>_invokeJsDefault.default
);
parcelHelpers.export(exports, "pluck", ()=>_pluckJsDefault.default
);
parcelHelpers.export(exports, "where", ()=>_whereJsDefault.default
);
parcelHelpers.export(exports, "max", ()=>_maxJsDefault.default
);
parcelHelpers.export(exports, "min", ()=>_minJsDefault.default
);
parcelHelpers.export(exports, "shuffle", ()=>_shuffleJsDefault.default
);
parcelHelpers.export(exports, "sample", ()=>_sampleJsDefault.default
);
parcelHelpers.export(exports, "sortBy", ()=>_sortByJsDefault.default
);
parcelHelpers.export(exports, "groupBy", ()=>_groupByJsDefault.default
);
parcelHelpers.export(exports, "indexBy", ()=>_indexByJsDefault.default
);
parcelHelpers.export(exports, "countBy", ()=>_countByJsDefault.default
);
parcelHelpers.export(exports, "partition", ()=>_partitionJsDefault.default
);
parcelHelpers.export(exports, "toArray", ()=>_toArrayJsDefault.default
);
parcelHelpers.export(exports, "size", ()=>_sizeJsDefault.default
);
// `_.pick` and `_.omit` are actually object functions, but we put
// them here in order to create a more natural reading order in the
// monolithic build as they depend on `_.contains`.
parcelHelpers.export(exports, "pick", ()=>_pickJsDefault.default
);
parcelHelpers.export(exports, "omit", ()=>_omitJsDefault.default
);
// Array Functions
// ---------------
// Functions that operate on arrays (and array-likes) only, because they’re
// expressed in terms of operations on an ordered list of values.
parcelHelpers.export(exports, "first", ()=>_firstJsDefault.default
);
parcelHelpers.export(exports, "head", ()=>_firstJsDefault.default
);
parcelHelpers.export(exports, "take", ()=>_firstJsDefault.default
);
parcelHelpers.export(exports, "initial", ()=>_initialJsDefault.default
);
parcelHelpers.export(exports, "last", ()=>_lastJsDefault.default
);
parcelHelpers.export(exports, "rest", ()=>_restJsDefault.default
);
parcelHelpers.export(exports, "tail", ()=>_restJsDefault.default
);
parcelHelpers.export(exports, "drop", ()=>_restJsDefault.default
);
parcelHelpers.export(exports, "compact", ()=>_compactJsDefault.default
);
parcelHelpers.export(exports, "flatten", ()=>_flattenJsDefault.default
);
parcelHelpers.export(exports, "without", ()=>_withoutJsDefault.default
);
parcelHelpers.export(exports, "uniq", ()=>_uniqJsDefault.default
);
parcelHelpers.export(exports, "unique", ()=>_uniqJsDefault.default
);
parcelHelpers.export(exports, "union", ()=>_unionJsDefault.default
);
parcelHelpers.export(exports, "intersection", ()=>_intersectionJsDefault.default
);
parcelHelpers.export(exports, "difference", ()=>_differenceJsDefault.default
);
parcelHelpers.export(exports, "unzip", ()=>_unzipJsDefault.default
);
parcelHelpers.export(exports, "transpose", ()=>_unzipJsDefault.default
);
parcelHelpers.export(exports, "zip", ()=>_zipJsDefault.default
);
parcelHelpers.export(exports, "object", ()=>_objectJsDefault.default
);
parcelHelpers.export(exports, "range", ()=>_rangeJsDefault.default
);
parcelHelpers.export(exports, "chunk", ()=>_chunkJsDefault.default
);
// OOP
// ---
// These modules support the "object-oriented" calling style. See also
// `underscore.js` and `index-default.js`.
parcelHelpers.export(exports, "mixin", ()=>_mixinJsDefault.default
);
parcelHelpers.export(exports, "default", ()=>_underscoreArrayMethodsJsDefault.default
);
var _setupJs = require("./_setup.js");
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isNullJs = require("./isNull.js");
var _isNullJsDefault = parcelHelpers.interopDefault(_isNullJs);
var _isUndefinedJs = require("./isUndefined.js");
var _isUndefinedJsDefault = parcelHelpers.interopDefault(_isUndefinedJs);
var _isBooleanJs = require("./isBoolean.js");
var _isBooleanJsDefault = parcelHelpers.interopDefault(_isBooleanJs);
var _isElementJs = require("./isElement.js");
var _isElementJsDefault = parcelHelpers.interopDefault(_isElementJs);
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isNumberJs = require("./isNumber.js");
var _isNumberJsDefault = parcelHelpers.interopDefault(_isNumberJs);
var _isDateJs = require("./isDate.js");
var _isDateJsDefault = parcelHelpers.interopDefault(_isDateJs);
var _isRegExpJs = require("./isRegExp.js");
var _isRegExpJsDefault = parcelHelpers.interopDefault(_isRegExpJs);
var _isErrorJs = require("./isError.js");
var _isErrorJsDefault = parcelHelpers.interopDefault(_isErrorJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
var _isArrayBufferJs = require("./isArrayBuffer.js");
var _isArrayBufferJsDefault = parcelHelpers.interopDefault(_isArrayBufferJs);
var _isDataViewJs = require("./isDataView.js");
var _isDataViewJsDefault = parcelHelpers.interopDefault(_isDataViewJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isFiniteJs = require("./isFinite.js");
var _isFiniteJsDefault = parcelHelpers.interopDefault(_isFiniteJs);
var _isNaNJs = require("./isNaN.js");
var _isNaNJsDefault = parcelHelpers.interopDefault(_isNaNJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
var _isEmptyJs = require("./isEmpty.js");
var _isEmptyJsDefault = parcelHelpers.interopDefault(_isEmptyJs);
var _isMatchJs = require("./isMatch.js");
var _isMatchJsDefault = parcelHelpers.interopDefault(_isMatchJs);
var _isEqualJs = require("./isEqual.js");
var _isEqualJsDefault = parcelHelpers.interopDefault(_isEqualJs);
var _isMapJs = require("./isMap.js");
var _isMapJsDefault = parcelHelpers.interopDefault(_isMapJs);
var _isWeakMapJs = require("./isWeakMap.js");
var _isWeakMapJsDefault = parcelHelpers.interopDefault(_isWeakMapJs);
var _isSetJs = require("./isSet.js");
var _isSetJsDefault = parcelHelpers.interopDefault(_isSetJs);
var _isWeakSetJs = require("./isWeakSet.js");
var _isWeakSetJsDefault = parcelHelpers.interopDefault(_isWeakSetJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _pairsJs = require("./pairs.js");
var _pairsJsDefault = parcelHelpers.interopDefault(_pairsJs);
var _invertJs = require("./invert.js");
var _invertJsDefault = parcelHelpers.interopDefault(_invertJs);
var _functionsJs = require("./functions.js");
var _functionsJsDefault = parcelHelpers.interopDefault(_functionsJs);
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _extendOwnJs = require("./extendOwn.js");
var _extendOwnJsDefault = parcelHelpers.interopDefault(_extendOwnJs);
var _defaultsJs = require("./defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _createJs = require("./create.js");
var _createJsDefault = parcelHelpers.interopDefault(_createJs);
var _cloneJs = require("./clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _tapJs = require("./tap.js");
var _tapJsDefault = parcelHelpers.interopDefault(_tapJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
var _hasJs = require("./has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _mapObjectJs = require("./mapObject.js");
var _mapObjectJsDefault = parcelHelpers.interopDefault(_mapObjectJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _toPathJs = require("./toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _propertyOfJs = require("./propertyOf.js");
var _propertyOfJsDefault = parcelHelpers.interopDefault(_propertyOfJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
var _timesJs = require("./times.js");
var _timesJsDefault = parcelHelpers.interopDefault(_timesJs);
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
var _escapeJs = require("./escape.js");
var _escapeJsDefault = parcelHelpers.interopDefault(_escapeJs);
var _unescapeJs = require("./unescape.js");
var _unescapeJsDefault = parcelHelpers.interopDefault(_unescapeJs);
var _templateSettingsJs = require("./templateSettings.js");
var _templateSettingsJsDefault = parcelHelpers.interopDefault(_templateSettingsJs);
var _templateJs = require("./template.js");
var _templateJsDefault = parcelHelpers.interopDefault(_templateJs);
var _resultJs = require("./result.js");
var _resultJsDefault = parcelHelpers.interopDefault(_resultJs);
var _uniqueIdJs = require("./uniqueId.js");
var _uniqueIdJsDefault = parcelHelpers.interopDefault(_uniqueIdJs);
var _chainJs = require("./chain.js");
var _chainJsDefault = parcelHelpers.interopDefault(_chainJs);
var _iterateeJs = require("./iteratee.js");
var _iterateeJsDefault = parcelHelpers.interopDefault(_iterateeJs);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _bindJs = require("./bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _bindAllJs = require("./bindAll.js");
var _bindAllJsDefault = parcelHelpers.interopDefault(_bindAllJs);
var _memoizeJs = require("./memoize.js");
var _memoizeJsDefault = parcelHelpers.interopDefault(_memoizeJs);
var _delayJs = require("./delay.js");
var _delayJsDefault = parcelHelpers.interopDefault(_delayJs);
var _deferJs = require("./defer.js");
var _deferJsDefault = parcelHelpers.interopDefault(_deferJs);
var _throttleJs = require("./throttle.js");
var _throttleJsDefault = parcelHelpers.interopDefault(_throttleJs);
var _debounceJs = require("./debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _wrapJs = require("./wrap.js");
var _wrapJsDefault = parcelHelpers.interopDefault(_wrapJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _composeJs = require("./compose.js");
var _composeJsDefault = parcelHelpers.interopDefault(_composeJs);
var _afterJs = require("./after.js");
var _afterJsDefault = parcelHelpers.interopDefault(_afterJs);
var _beforeJs = require("./before.js");
var _beforeJsDefault = parcelHelpers.interopDefault(_beforeJs);
var _onceJs = require("./once.js");
var _onceJsDefault = parcelHelpers.interopDefault(_onceJs);
var _findKeyJs = require("./findKey.js");
var _findKeyJsDefault = parcelHelpers.interopDefault(_findKeyJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _findLastIndexJs = require("./findLastIndex.js");
var _findLastIndexJsDefault = parcelHelpers.interopDefault(_findLastIndexJs);
var _sortedIndexJs = require("./sortedIndex.js");
var _sortedIndexJsDefault = parcelHelpers.interopDefault(_sortedIndexJs);
var _indexOfJs = require("./indexOf.js");
var _indexOfJsDefault = parcelHelpers.interopDefault(_indexOfJs);
var _lastIndexOfJs = require("./lastIndexOf.js");
var _lastIndexOfJsDefault = parcelHelpers.interopDefault(_lastIndexOfJs);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _findWhereJs = require("./findWhere.js");
var _findWhereJsDefault = parcelHelpers.interopDefault(_findWhereJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _reduceJs = require("./reduce.js");
var _reduceJsDefault = parcelHelpers.interopDefault(_reduceJs);
var _reduceRightJs = require("./reduceRight.js");
var _reduceRightJsDefault = parcelHelpers.interopDefault(_reduceRightJs);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _rejectJs = require("./reject.js");
var _rejectJsDefault = parcelHelpers.interopDefault(_rejectJs);
var _everyJs = require("./every.js");
var _everyJsDefault = parcelHelpers.interopDefault(_everyJs);
var _someJs = require("./some.js");
var _someJsDefault = parcelHelpers.interopDefault(_someJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _invokeJs = require("./invoke.js");
var _invokeJsDefault = parcelHelpers.interopDefault(_invokeJs);
var _pluckJs = require("./pluck.js");
var _pluckJsDefault = parcelHelpers.interopDefault(_pluckJs);
var _whereJs = require("./where.js");
var _whereJsDefault = parcelHelpers.interopDefault(_whereJs);
var _maxJs = require("./max.js");
var _maxJsDefault = parcelHelpers.interopDefault(_maxJs);
var _minJs = require("./min.js");
var _minJsDefault = parcelHelpers.interopDefault(_minJs);
var _shuffleJs = require("./shuffle.js");
var _shuffleJsDefault = parcelHelpers.interopDefault(_shuffleJs);
var _sampleJs = require("./sample.js");
var _sampleJsDefault = parcelHelpers.interopDefault(_sampleJs);
var _sortByJs = require("./sortBy.js");
var _sortByJsDefault = parcelHelpers.interopDefault(_sortByJs);
var _groupByJs = require("./groupBy.js");
var _groupByJsDefault = parcelHelpers.interopDefault(_groupByJs);
var _indexByJs = require("./indexBy.js");
var _indexByJsDefault = parcelHelpers.interopDefault(_indexByJs);
var _countByJs = require("./countBy.js");
var _countByJsDefault = parcelHelpers.interopDefault(_countByJs);
var _partitionJs = require("./partition.js");
var _partitionJsDefault = parcelHelpers.interopDefault(_partitionJs);
var _toArrayJs = require("./toArray.js");
var _toArrayJsDefault = parcelHelpers.interopDefault(_toArrayJs);
var _sizeJs = require("./size.js");
var _sizeJsDefault = parcelHelpers.interopDefault(_sizeJs);
var _pickJs = require("./pick.js");
var _pickJsDefault = parcelHelpers.interopDefault(_pickJs);
var _omitJs = require("./omit.js");
var _omitJsDefault = parcelHelpers.interopDefault(_omitJs);
var _firstJs = require("./first.js");
var _firstJsDefault = parcelHelpers.interopDefault(_firstJs);
var _initialJs = require("./initial.js");
var _initialJsDefault = parcelHelpers.interopDefault(_initialJs);
var _lastJs = require("./last.js");
var _lastJsDefault = parcelHelpers.interopDefault(_lastJs);
var _restJs = require("./rest.js");
var _restJsDefault = parcelHelpers.interopDefault(_restJs);
var _compactJs = require("./compact.js");
var _compactJsDefault = parcelHelpers.interopDefault(_compactJs);
var _flattenJs = require("./flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _withoutJs = require("./without.js");
var _withoutJsDefault = parcelHelpers.interopDefault(_withoutJs);
var _uniqJs = require("./uniq.js");
var _uniqJsDefault = parcelHelpers.interopDefault(_uniqJs);
var _unionJs = require("./union.js");
var _unionJsDefault = parcelHelpers.interopDefault(_unionJs);
var _intersectionJs = require("./intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
var _differenceJs = require("./difference.js");
var _differenceJsDefault = parcelHelpers.interopDefault(_differenceJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
var _zipJs = require("./zip.js");
var _zipJsDefault = parcelHelpers.interopDefault(_zipJs);
var _objectJs = require("./object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _rangeJs = require("./range.js");
var _rangeJsDefault = parcelHelpers.interopDefault(_rangeJs);
var _chunkJs = require("./chunk.js");
var _chunkJsDefault = parcelHelpers.interopDefault(_chunkJs);
var _mixinJs = require("./mixin.js");
var _mixinJsDefault = parcelHelpers.interopDefault(_mixinJs);
var _underscoreArrayMethodsJs = require("./underscore-array-methods.js");
var _underscoreArrayMethodsJsDefault = parcelHelpers.interopDefault(_underscoreArrayMethodsJs);

},{"./_setup.js":"bU4rb","./restArguments.js":"aKoU9","./isObject.js":"fewdV","./isNull.js":"5IXoW","./isUndefined.js":"1rdlx","./isBoolean.js":"ffqST","./isElement.js":"bgiPo","./isString.js":"lSLRQ","./isNumber.js":"jtK5H","./isDate.js":"7OIGk","./isRegExp.js":"3gbYP","./isError.js":"dRdPu","./isSymbol.js":"05hWy","./isArrayBuffer.js":"fz1w4","./isDataView.js":"kiEXp","./isArray.js":"oMlWT","./isFunction.js":"kDkjm","./isArguments.js":"ccahD","./isFinite.js":"1QPhO","./isNaN.js":"3kTfb","./isTypedArray.js":"96nwS","./isEmpty.js":"bWwBk","./isMatch.js":"lVx0T","./isEqual.js":"4Y7Ng","./isMap.js":"btbMz","./isWeakMap.js":"3nLaV","./isSet.js":"fmko9","./isWeakSet.js":"1WWW6","./keys.js":"l8Krv","./allKeys.js":"gEhlz","./values.js":"gylxe","./pairs.js":"5eJgq","./invert.js":"hY4ge","./functions.js":"aQpNB","./extend.js":"56G2o","./extendOwn.js":"aFcJ0","./defaults.js":"fFxIE","./create.js":"heZD5","./clone.js":"agxO3","./tap.js":"7c8Mk","./get.js":"jpYyN","./has.js":"dc692","./mapObject.js":"jTjJs","./identity.js":"f05xz","./constant.js":"akQkN","./noop.js":"eVJ12","./toPath.js":"afZr1","./property.js":"c6Iih","./propertyOf.js":"cHCOK","./matcher.js":"ekXoC","./times.js":"9U23S","./random.js":"jDe0A","./now.js":"fZ1Zl","./escape.js":"21f6N","./unescape.js":"brBbv","./templateSettings.js":"69goE","./template.js":"hyJUN","./result.js":"jjeXL","./uniqueId.js":"aS6hE","./chain.js":"h8Igg","./iteratee.js":"hFOL3","./partial.js":"hLcX3","./bind.js":"48NsZ","./bindAll.js":"9u5NU","./memoize.js":"ceNZR","./delay.js":"k0bcV","./defer.js":"5pRfB","./throttle.js":"87yq2","./debounce.js":"1Csjh","./wrap.js":"luJbh","./negate.js":"jleQN","./compose.js":"NhC2V","./after.js":"hdEPt","./before.js":"6OzV9","./once.js":"g5TYa","./findKey.js":"3zqFY","./findIndex.js":"edEuk","./findLastIndex.js":"akOdX","./sortedIndex.js":"4zP4e","./indexOf.js":"krndY","./lastIndexOf.js":"4BWXf","./find.js":"doTH0","./findWhere.js":"k1pe6","./each.js":"ewQpM","./map.js":"giPqo","./reduce.js":"aPzI9","./reduceRight.js":"1xJDA","./filter.js":"eA6Gs","./reject.js":"bnI9j","./every.js":"cWFVa","./some.js":"3Watr","./contains.js":"ibLHC","./invoke.js":"2PsTm","./pluck.js":"16Uqx","./where.js":"68doq","./max.js":"jGJNf","./min.js":"c6yfU","./shuffle.js":"7rhS3","./sample.js":"1Yno6","./sortBy.js":"9ldTP","./groupBy.js":"gXyFd","./indexBy.js":"8sscK","./countBy.js":"58Fry","./partition.js":"fVFy0","./toArray.js":"9hdGm","./size.js":"6mXmd","./pick.js":"iJky2","./omit.js":"7TToI","./first.js":"1fmF2","./initial.js":"2Q93K","./last.js":"gWLnh","./rest.js":"l7YiK","./compact.js":"5geL8","./flatten.js":"kzSeC","./without.js":"jGT7e","./uniq.js":"ci6Hh","./union.js":"9B8VJ","./intersection.js":"9e2VQ","./difference.js":"iJk2V","./unzip.js":"8xaCn","./zip.js":"LKE7e","./object.js":"3kVS9","./range.js":"6d5vI","./chunk.js":"bTQIh","./mixin.js":"3Jc5x","./underscore-array-methods.js":"ehthA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bU4rb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION
);
parcelHelpers.export(exports, "root", ()=>root
);
parcelHelpers.export(exports, "ArrayProto", ()=>ArrayProto
);
parcelHelpers.export(exports, "ObjProto", ()=>ObjProto
);
parcelHelpers.export(exports, "SymbolProto", ()=>SymbolProto
);
parcelHelpers.export(exports, "push", ()=>push
);
parcelHelpers.export(exports, "slice", ()=>slice
);
parcelHelpers.export(exports, "toString", ()=>toString
);
parcelHelpers.export(exports, "hasOwnProperty", ()=>hasOwnProperty
);
parcelHelpers.export(exports, "supportsArrayBuffer", ()=>supportsArrayBuffer
);
parcelHelpers.export(exports, "supportsDataView", ()=>supportsDataView
);
parcelHelpers.export(exports, "nativeIsArray", ()=>nativeIsArray
);
parcelHelpers.export(exports, "nativeKeys", ()=>nativeKeys
);
parcelHelpers.export(exports, "nativeCreate", ()=>nativeCreate
);
parcelHelpers.export(exports, "nativeIsView", ()=>nativeIsView
);
parcelHelpers.export(exports, "_isNaN", ()=>_isNaN
);
parcelHelpers.export(exports, "_isFinite", ()=>_isFinite
);
parcelHelpers.export(exports, "hasEnumBug", ()=>hasEnumBug
);
parcelHelpers.export(exports, "nonEnumerableProps", ()=>nonEnumerableProps
);
parcelHelpers.export(exports, "MAX_ARRAY_INDEX", ()=>MAX_ARRAY_INDEX
);
var global = arguments[3];
var VERSION = '1.13.1';
var root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || Function('return this')() || {
};
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;
var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined', supportsDataView = typeof DataView !== 'undefined';
var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
var _isNaN = isNaN, _isFinite = isFinite;
var hasEnumBug = !({
    toString: null
}).propertyIsEnumerable('toString');
var nonEnumerableProps = [
    'valueOf',
    'isPrototypeOf',
    'toString',
    'propertyIsEnumerable',
    'hasOwnProperty',
    'toLocaleString'
];
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"aKoU9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
        var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0;
        for(; index < length; index++)rest[index] = arguments[index + startIndex];
        switch(startIndex){
            case 0:
                return func.call(this, rest);
            case 1:
                return func.call(this, arguments[0], rest);
            case 2:
                return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for(index = 0; index < startIndex; index++)args[index] = arguments[index];
        args[startIndex] = rest;
        return func.apply(this, args);
    };
}
exports.default = restArguments;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fewdV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isObject(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
}
exports.default = isObject;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5IXoW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isNull(obj) {
    return obj === null;
}
exports.default = isNull;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1rdlx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isUndefined(obj) {
    return obj === void 0;
}
exports.default = isUndefined;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ffqST":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function isBoolean(obj) {
    return obj === true || obj === false || _setupJs.toString.call(obj) === '[object Boolean]';
}
exports.default = isBoolean;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bgiPo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isElement(obj) {
    return !!(obj && obj.nodeType === 1);
}
exports.default = isElement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lSLRQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('String');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9L0lE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function tagTester(name) {
    var tag = '[object ' + name + ']';
    return function(obj) {
        return _setupJs.toString.call(obj) === tag;
    };
}
exports.default = tagTester;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jtK5H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Number');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7OIGk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Date');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3gbYP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('RegExp');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dRdPu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Error');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"05hWy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Symbol');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fz1w4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('ArrayBuffer');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kiEXp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isArrayBufferJs = require("./isArrayBuffer.js");
var _isArrayBufferJsDefault = parcelHelpers.interopDefault(_isArrayBufferJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var isDataView = _tagTesterJsDefault.default('DataView');
// In IE 10 - Edge 13, we need a different heuristic
// to determine whether an object is a `DataView`.
function ie10IsDataView(obj) {
    return obj != null && _isFunctionJsDefault.default(obj.getInt8) && _isArrayBufferJsDefault.default(obj.buffer);
}
exports.default = _stringTagBugJs.hasStringTagBug ? ie10IsDataView : isDataView;

},{"./_tagTester.js":"9L0lE","./isFunction.js":"kDkjm","./isArrayBuffer.js":"fz1w4","./_stringTagBug.js":"liky0","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kDkjm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _setupJs = require("./_setup.js");
var isFunction = _tagTesterJsDefault.default('Function');
// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = _setupJs.root.document && _setupJs.root.document.childNodes;
if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') isFunction = function(obj) {
    return typeof obj == 'function' || false;
};
exports.default = isFunction;

},{"./_tagTester.js":"9L0lE","./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"liky0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasStringTagBug", ()=>hasStringTagBug
);
parcelHelpers.export(exports, "isIE11", ()=>isIE11
);
var _setupJs = require("./_setup.js");
var _hasObjectTagJs = require("./_hasObjectTag.js");
var _hasObjectTagJsDefault = parcelHelpers.interopDefault(_hasObjectTagJs);
var hasStringTagBug = _setupJs.supportsDataView && _hasObjectTagJsDefault.default(new DataView(new ArrayBuffer(8))), isIE11 = typeof Map !== 'undefined' && _hasObjectTagJsDefault.default(new Map);

},{"./_setup.js":"bU4rb","./_hasObjectTag.js":"fxe6G","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fxe6G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('Object');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"oMlWT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _setupJs.nativeIsArray || _tagTesterJsDefault.default('Array');

},{"./_setup.js":"bU4rb","./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ccahD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var isArguments = _tagTesterJsDefault.default('Arguments');
(function() {
    if (!isArguments(arguments)) isArguments = function(obj) {
        return _hasJsDefault.default(obj, 'callee');
    };
})();
exports.default = isArguments;

},{"./_tagTester.js":"9L0lE","./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aSS50":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function has(obj, key) {
    return obj != null && _setupJs.hasOwnProperty.call(obj, key);
}
exports.default = has;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1QPhO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
function isFinite(obj) {
    return !_isSymbolJsDefault.default(obj) && _setupJs._isFinite(obj) && !isNaN(parseFloat(obj));
}
exports.default = isFinite;

},{"./_setup.js":"bU4rb","./isSymbol.js":"05hWy","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3kTfb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _isNumberJs = require("./isNumber.js");
var _isNumberJsDefault = parcelHelpers.interopDefault(_isNumberJs);
function isNaN(obj) {
    return _isNumberJsDefault.default(obj) && _setupJs._isNaN(obj);
}
exports.default = isNaN;

},{"./_setup.js":"bU4rb","./isNumber.js":"jtK5H","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"96nwS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _isDataViewJs = require("./isDataView.js");
var _isDataViewJsDefault = parcelHelpers.interopDefault(_isDataViewJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _isBufferLikeJs = require("./_isBufferLike.js");
var _isBufferLikeJsDefault = parcelHelpers.interopDefault(_isBufferLikeJs);
// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
    // `ArrayBuffer.isView` is the most future-proof, so use it when available.
    // Otherwise, fall back on the above regular expression.
    return _setupJs.nativeIsView ? _setupJs.nativeIsView(obj) && !_isDataViewJsDefault.default(obj) : _isBufferLikeJsDefault.default(obj) && typedArrayPattern.test(_setupJs.toString.call(obj));
}
exports.default = _setupJs.supportsArrayBuffer ? isTypedArray : _constantJsDefault.default(false);

},{"./_setup.js":"bU4rb","./isDataView.js":"kiEXp","./constant.js":"akQkN","./_isBufferLike.js":"kJLYf","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"akQkN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function constant(value) {
    return function() {
        return value;
    };
}
exports.default = constant;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kJLYf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createSizePropertyCheckJs = require("./_createSizePropertyCheck.js");
var _createSizePropertyCheckJsDefault = parcelHelpers.interopDefault(_createSizePropertyCheckJs);
var _getByteLengthJs = require("./_getByteLength.js");
var _getByteLengthJsDefault = parcelHelpers.interopDefault(_getByteLengthJs);
exports.default = _createSizePropertyCheckJsDefault.default(_getByteLengthJsDefault.default);

},{"./_createSizePropertyCheck.js":"b727b","./_getByteLength.js":"8j0nM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"b727b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function createSizePropertyCheck(getSizeProperty) {
    return function(collection) {
        var sizeProperty = getSizeProperty(collection);
        return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= _setupJs.MAX_ARRAY_INDEX;
    };
}
exports.default = createSizePropertyCheck;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8j0nM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _shallowPropertyJs = require("./_shallowProperty.js");
var _shallowPropertyJsDefault = parcelHelpers.interopDefault(_shallowPropertyJs);
exports.default = _shallowPropertyJsDefault.default('byteLength');

},{"./_shallowProperty.js":"28HTj","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"28HTj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function shallowProperty(key) {
    return function(obj) {
        return obj == null ? void 0 : obj[key];
    };
}
exports.default = shallowProperty;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bWwBk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function isEmpty(obj) {
    if (obj == null) return true;
    // Skip the more expensive `toString`-based type checks if `obj` has no
    // `.length`.
    var length = _getLengthJsDefault.default(obj);
    if (typeof length == 'number' && (_isArrayJsDefault.default(obj) || _isStringJsDefault.default(obj) || _isArgumentsJsDefault.default(obj))) return length === 0;
    return _getLengthJsDefault.default(_keysJsDefault.default(obj)) === 0;
}
exports.default = isEmpty;

},{"./_getLength.js":"30FQX","./isArray.js":"oMlWT","./isString.js":"lSLRQ","./isArguments.js":"ccahD","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"30FQX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _shallowPropertyJs = require("./_shallowProperty.js");
var _shallowPropertyJsDefault = parcelHelpers.interopDefault(_shallowPropertyJs);
exports.default = _shallowPropertyJsDefault.default('length');

},{"./_shallowProperty.js":"28HTj","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"l8Krv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _setupJs = require("./_setup.js");
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _collectNonEnumPropsJs = require("./_collectNonEnumProps.js");
var _collectNonEnumPropsJsDefault = parcelHelpers.interopDefault(_collectNonEnumPropsJs);
function keys1(obj) {
    if (!_isObjectJsDefault.default(obj)) return [];
    if (_setupJs.nativeKeys) return _setupJs.nativeKeys(obj);
    var keys = [];
    for(var key in obj)if (_hasJsDefault.default(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (_setupJs.hasEnumBug) _collectNonEnumPropsJsDefault.default(obj, keys);
    return keys;
}
exports.default = keys1;

},{"./isObject.js":"fewdV","./_setup.js":"bU4rb","./_has.js":"aSS50","./_collectNonEnumProps.js":"bdCpc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bdCpc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
    var hash = {
    };
    for(var l = keys.length, i = 0; i < l; ++i)hash[keys[i]] = true;
    return {
        contains: function(key) {
            return hash[key];
        },
        push: function(key) {
            hash[key] = true;
            return keys.push(key);
        }
    };
}
function collectNonEnumProps(obj, keys) {
    keys = emulatedSet(keys);
    var nonEnumIdx = _setupJs.nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _isFunctionJsDefault.default(constructor) && constructor.prototype || _setupJs.ObjProto;
    // Constructor is a special case.
    var prop = 'constructor';
    if (_hasJsDefault.default(obj, prop) && !keys.contains(prop)) keys.push(prop);
    while(nonEnumIdx--){
        prop = _setupJs.nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) keys.push(prop);
    }
}
exports.default = collectNonEnumProps;

},{"./_setup.js":"bU4rb","./isFunction.js":"kDkjm","./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lVx0T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function isMatch(object, attrs) {
    var _keys = _keysJsDefault.default(attrs), length = _keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for(var i = 0; i < length; i++){
        var key = _keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
}
exports.default = isMatch;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4Y7Ng":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _setupJs = require("./_setup.js");
var _getByteLengthJs = require("./_getByteLength.js");
var _getByteLengthJsDefault = parcelHelpers.interopDefault(_getByteLengthJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _isDataViewJs = require("./isDataView.js");
var _isDataViewJsDefault = parcelHelpers.interopDefault(_isDataViewJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _toBufferViewJs = require("./_toBufferView.js");
var _toBufferViewJsDefault = parcelHelpers.interopDefault(_toBufferViewJs);
// We use this string twice, so give it a name for minification.
var tagDataView = '[object DataView]';
// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
}
// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _underscoreJsDefault.default) a = a._wrapped;
    if (b instanceof _underscoreJsDefault.default) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = _setupJs.toString.call(a);
    if (className !== _setupJs.toString.call(b)) return false;
    // Work around a bug in IE 10 - Edge 13.
    if (_stringTagBugJs.hasStringTagBug && className == '[object Object]' && _isDataViewJsDefault.default(a)) {
        if (!_isDataViewJsDefault.default(b)) return false;
        className = tagDataView;
    }
    switch(className){
        // These types are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
        case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        case '[object Symbol]':
            return _setupJs.SymbolProto.valueOf.call(a) === _setupJs.SymbolProto.valueOf.call(b);
        case '[object ArrayBuffer]':
        case tagDataView:
            // Coerce to typed array so we can fall through.
            return deepEq(_toBufferViewJsDefault.default(a), _toBufferViewJsDefault.default(b), aStack, bStack);
    }
    var areArrays = className === '[object Array]';
    if (!areArrays && _isTypedArrayJsDefault.default(a)) {
        var byteLength = _getByteLengthJsDefault.default(a);
        if (byteLength !== _getByteLengthJsDefault.default(b)) return false;
        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
        areArrays = true;
    }
    if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object') return false;
        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(_isFunctionJsDefault.default(aCtor) && aCtor instanceof aCtor && _isFunctionJsDefault.default(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) return false;
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while(length--){
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while(length--){
            if (!eq(a[length], b[length], aStack, bStack)) return false;
        }
    } else {
        // Deep compare objects.
        var _keys = _keysJsDefault.default(a), key;
        length = _keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (_keysJsDefault.default(b).length !== length) return false;
        while(length--){
            // Deep compare each member
            key = _keys[length];
            if (!(_hasJsDefault.default(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
}
function isEqual(a, b) {
    return eq(a, b);
}
exports.default = isEqual;

},{"./underscore.js":"hjck8","./_setup.js":"bU4rb","./_getByteLength.js":"8j0nM","./isTypedArray.js":"96nwS","./isFunction.js":"kDkjm","./_stringTagBug.js":"liky0","./isDataView.js":"kiEXp","./keys.js":"l8Krv","./_has.js":"aSS50","./_toBufferView.js":"6NZHV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hjck8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function _(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
}
exports.default = _;
_.VERSION = _setupJs.VERSION;
// Extracts the result from a wrapped and chained object.
_.prototype.value = function() {
    return this._wrapped;
};
// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
_.prototype.toString = function() {
    return String(this._wrapped);
};

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6NZHV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getByteLengthJs = require("./_getByteLength.js");
var _getByteLengthJsDefault = parcelHelpers.interopDefault(_getByteLengthJs);
function toBufferView(bufferSource) {
    return new Uint8Array(bufferSource.buffer || bufferSource, bufferSource.byteOffset || 0, _getByteLengthJsDefault.default(bufferSource));
}
exports.default = toBufferView;

},{"./_getByteLength.js":"8j0nM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"btbMz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _methodFingerprintJs = require("./_methodFingerprint.js");
exports.default = _stringTagBugJs.isIE11 ? _methodFingerprintJs.ie11fingerprint(_methodFingerprintJs.mapMethods) : _tagTesterJsDefault.default('Map');

},{"./_tagTester.js":"9L0lE","./_stringTagBug.js":"liky0","./_methodFingerprint.js":"enYoA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"enYoA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Since the regular `Object.prototype.toString` type tests don't work for
// some types in IE 11, we use a fingerprinting heuristic instead, based
// on the methods. It's not great, but it's the best we got.
// The fingerprint method lists are defined below.
parcelHelpers.export(exports, "ie11fingerprint", ()=>ie11fingerprint
);
parcelHelpers.export(exports, "mapMethods", ()=>mapMethods
);
parcelHelpers.export(exports, "weakMapMethods", ()=>weakMapMethods
);
parcelHelpers.export(exports, "setMethods", ()=>setMethods
);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
function ie11fingerprint(methods) {
    var length = _getLengthJsDefault.default(methods);
    return function(obj) {
        if (obj == null) return false;
        // `Map`, `WeakMap` and `Set` have no enumerable keys.
        var keys = _allKeysJsDefault.default(obj);
        if (_getLengthJsDefault.default(keys)) return false;
        for(var i = 0; i < length; i++){
            if (!_isFunctionJsDefault.default(obj[methods[i]])) return false;
        }
        // If we are testing against `WeakMap`, we need to ensure that
        // `obj` doesn't have a `forEach` method in order to distinguish
        // it from a regular `Map`.
        return methods !== weakMapMethods || !_isFunctionJsDefault.default(obj[forEachName]);
    };
}
// In the interest of compact minification, we write
// each string in the fingerprints only once.
var forEachName = 'forEach', hasName = 'has', commonInit = [
    'clear',
    'delete'
], mapTail = [
    'get',
    hasName,
    'set'
];
var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = [
    'add'
].concat(commonInit, forEachName, hasName);

},{"./_getLength.js":"30FQX","./isFunction.js":"kDkjm","./allKeys.js":"gEhlz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gEhlz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _setupJs = require("./_setup.js");
var _collectNonEnumPropsJs = require("./_collectNonEnumProps.js");
var _collectNonEnumPropsJsDefault = parcelHelpers.interopDefault(_collectNonEnumPropsJs);
function allKeys(obj) {
    if (!_isObjectJsDefault.default(obj)) return [];
    var keys = [];
    for(var key in obj)keys.push(key);
    // Ahem, IE < 9.
    if (_setupJs.hasEnumBug) _collectNonEnumPropsJsDefault.default(obj, keys);
    return keys;
}
exports.default = allKeys;

},{"./isObject.js":"fewdV","./_setup.js":"bU4rb","./_collectNonEnumProps.js":"bdCpc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3nLaV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _methodFingerprintJs = require("./_methodFingerprint.js");
exports.default = _stringTagBugJs.isIE11 ? _methodFingerprintJs.ie11fingerprint(_methodFingerprintJs.weakMapMethods) : _tagTesterJsDefault.default('WeakMap');

},{"./_tagTester.js":"9L0lE","./_stringTagBug.js":"liky0","./_methodFingerprint.js":"enYoA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fmko9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _methodFingerprintJs = require("./_methodFingerprint.js");
exports.default = _stringTagBugJs.isIE11 ? _methodFingerprintJs.ie11fingerprint(_methodFingerprintJs.setMethods) : _tagTesterJsDefault.default('Set');

},{"./_tagTester.js":"9L0lE","./_stringTagBug.js":"liky0","./_methodFingerprint.js":"enYoA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1WWW6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = _tagTesterJsDefault.default('WeakSet');

},{"./_tagTester.js":"9L0lE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gylxe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function values1(obj) {
    var _keys = _keysJsDefault.default(obj);
    var length = _keys.length;
    var values = Array(length);
    for(var i = 0; i < length; i++)values[i] = obj[_keys[i]];
    return values;
}
exports.default = values1;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5eJgq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function pairs1(obj) {
    var _keys = _keysJsDefault.default(obj);
    var length = _keys.length;
    var pairs = Array(length);
    for(var i = 0; i < length; i++)pairs[i] = [
        _keys[i],
        obj[_keys[i]]
    ];
    return pairs;
}
exports.default = pairs1;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hY4ge":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function invert(obj) {
    var result = {
    };
    var _keys = _keysJsDefault.default(obj);
    for(var i = 0, length = _keys.length; i < length; i++)result[obj[_keys[i]]] = _keys[i];
    return result;
}
exports.default = invert;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aQpNB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
function functions(obj) {
    var names = [];
    for(var key in obj)if (_isFunctionJsDefault.default(obj[key])) names.push(key);
    return names.sort();
}
exports.default = functions;

},{"./isFunction.js":"kDkjm","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"56G2o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createAssignerJs = require("./_createAssigner.js");
var _createAssignerJsDefault = parcelHelpers.interopDefault(_createAssignerJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
exports.default = _createAssignerJsDefault.default(_allKeysJsDefault.default);

},{"./_createAssigner.js":"6Ww9s","./allKeys.js":"gEhlz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6Ww9s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function createAssigner(keysFunc, defaults) {
    return function(obj) {
        var length = arguments.length;
        if (defaults) obj = Object(obj);
        if (length < 2 || obj == null) return obj;
        for(var index = 1; index < length; index++){
            var source = arguments[index], keys = keysFunc(source), l = keys.length;
            for(var i = 0; i < l; i++){
                var key = keys[i];
                if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
        }
        return obj;
    };
}
exports.default = createAssigner;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aFcJ0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createAssignerJs = require("./_createAssigner.js");
var _createAssignerJsDefault = parcelHelpers.interopDefault(_createAssignerJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
exports.default = _createAssignerJsDefault.default(_keysJsDefault.default);

},{"./_createAssigner.js":"6Ww9s","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fFxIE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createAssignerJs = require("./_createAssigner.js");
var _createAssignerJsDefault = parcelHelpers.interopDefault(_createAssignerJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
exports.default = _createAssignerJsDefault.default(_allKeysJsDefault.default, true);

},{"./_createAssigner.js":"6Ww9s","./allKeys.js":"gEhlz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"heZD5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _extendOwnJs = require("./extendOwn.js");
var _extendOwnJsDefault = parcelHelpers.interopDefault(_extendOwnJs);
function create(prototype, props) {
    var result = _baseCreateJsDefault.default(prototype);
    if (props) _extendOwnJsDefault.default(result, props);
    return result;
}
exports.default = create;

},{"./_baseCreate.js":"3vxk9","./extendOwn.js":"aFcJ0","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3vxk9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _setupJs = require("./_setup.js");
// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
    return function() {
    };
}
function baseCreate(prototype) {
    if (!_isObjectJsDefault.default(prototype)) return {
    };
    if (_setupJs.nativeCreate) return _setupJs.nativeCreate(prototype);
    var Ctor = ctor();
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
}
exports.default = baseCreate;

},{"./isObject.js":"fewdV","./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"agxO3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
function clone(obj) {
    if (!_isObjectJsDefault.default(obj)) return obj;
    return _isArrayJsDefault.default(obj) ? obj.slice() : _extendJsDefault.default({
    }, obj);
}
exports.default = clone;

},{"./isObject.js":"fewdV","./isArray.js":"oMlWT","./extend.js":"56G2o","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7c8Mk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function tap(obj, interceptor) {
    interceptor(obj);
    return obj;
}
exports.default = tap;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jpYyN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
var _deepGetJs = require("./_deepGet.js");
var _deepGetJsDefault = parcelHelpers.interopDefault(_deepGetJs);
var _isUndefinedJs = require("./isUndefined.js");
var _isUndefinedJsDefault = parcelHelpers.interopDefault(_isUndefinedJs);
function get(object, path, defaultValue) {
    var value = _deepGetJsDefault.default(object, _toPathJsDefault.default(path));
    return _isUndefinedJsDefault.default(value) ? defaultValue : value;
}
exports.default = get;

},{"./_toPath.js":"2PZbF","./_deepGet.js":"9J8i1","./isUndefined.js":"1rdlx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2PZbF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _toPathJs = require("./toPath.js");
function toPath(path) {
    return _underscoreJsDefault.default.toPath(path);
}
exports.default = toPath;

},{"./underscore.js":"hjck8","./toPath.js":"afZr1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"afZr1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
function toPath(path) {
    return _isArrayJsDefault.default(path) ? path : [
        path
    ];
}
exports.default = toPath;
_underscoreJsDefault.default.toPath = toPath;

},{"./underscore.js":"hjck8","./isArray.js":"oMlWT","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9J8i1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function deepGet(obj, path) {
    var length = path.length;
    for(var i = 0; i < length; i++){
        if (obj == null) return void 0;
        obj = obj[path[i]];
    }
    return length ? obj : void 0;
}
exports.default = deepGet;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dc692":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
function has(obj, path) {
    path = _toPathJsDefault.default(path);
    var length = path.length;
    for(var i = 0; i < length; i++){
        var key = path[i];
        if (!_hasJsDefault.default(obj, key)) return false;
        obj = obj[key];
    }
    return !!length;
}
exports.default = has;

},{"./_has.js":"aSS50","./_toPath.js":"2PZbF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jTjJs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function mapObject(obj, iteratee, context) {
    iteratee = _cbJsDefault.default(iteratee, context);
    var _keys = _keysJsDefault.default(obj), length = _keys.length, results = {
    };
    for(var index = 0; index < length; index++){
        var currentKey = _keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
}
exports.default = mapObject;

},{"./_cb.js":"l45Ig","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"l45Ig":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
var _iterateeJs = require("./iteratee.js");
var _iterateeJsDefault = parcelHelpers.interopDefault(_iterateeJs);
function cb(value, context, argCount) {
    if (_underscoreJsDefault.default.iteratee !== _iterateeJsDefault.default) return _underscoreJsDefault.default.iteratee(value, context);
    return _baseIterateeJsDefault.default(value, context, argCount);
}
exports.default = cb;

},{"./underscore.js":"hjck8","./_baseIteratee.js":"aNHi1","./iteratee.js":"hFOL3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aNHi1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
function baseIteratee(value, context, argCount) {
    if (value == null) return _identityJsDefault.default;
    if (_isFunctionJsDefault.default(value)) return _optimizeCbJsDefault.default(value, context, argCount);
    if (_isObjectJsDefault.default(value) && !_isArrayJsDefault.default(value)) return _matcherJsDefault.default(value);
    return _propertyJsDefault.default(value);
}
exports.default = baseIteratee;

},{"./identity.js":"f05xz","./isFunction.js":"kDkjm","./isObject.js":"fewdV","./isArray.js":"oMlWT","./matcher.js":"ekXoC","./property.js":"c6Iih","./_optimizeCb.js":"cAw5c","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"f05xz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function identity(value) {
    return value;
}
exports.default = identity;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ekXoC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extendOwnJs = require("./extendOwn.js");
var _extendOwnJsDefault = parcelHelpers.interopDefault(_extendOwnJs);
var _isMatchJs = require("./isMatch.js");
var _isMatchJsDefault = parcelHelpers.interopDefault(_isMatchJs);
function matcher(attrs) {
    attrs = _extendOwnJsDefault.default({
    }, attrs);
    return function(obj) {
        return _isMatchJsDefault.default(obj, attrs);
    };
}
exports.default = matcher;

},{"./extendOwn.js":"aFcJ0","./isMatch.js":"lVx0T","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c6Iih":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _deepGetJs = require("./_deepGet.js");
var _deepGetJsDefault = parcelHelpers.interopDefault(_deepGetJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
function property(path) {
    path = _toPathJsDefault.default(path);
    return function(obj) {
        return _deepGetJsDefault.default(obj, path);
    };
}
exports.default = property;

},{"./_deepGet.js":"9J8i1","./_toPath.js":"2PZbF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cAw5c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function optimizeCb(func, context, argCount) {
    if (context === void 0) return func;
    switch(argCount == null ? 3 : argCount){
        case 1:
            return function(value) {
                return func.call(context, value);
            };
        // The 2-argument case is omitted because we’re not using it.
        case 3:
            return function(value, index, collection) {
                return func.call(context, value, index, collection);
            };
        case 4:
            return function(accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection);
            };
    }
    return function() {
        return func.apply(context, arguments);
    };
}
exports.default = optimizeCb;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hFOL3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
function iteratee(value, context) {
    return _baseIterateeJsDefault.default(value, context, Infinity);
}
exports.default = iteratee;
_underscoreJsDefault.default.iteratee = iteratee;

},{"./underscore.js":"hjck8","./_baseIteratee.js":"aNHi1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eVJ12":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function noop() {
}
exports.default = noop;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cHCOK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
function propertyOf(obj) {
    if (obj == null) return _noopJsDefault.default;
    return function(path) {
        return _getJsDefault.default(obj, path);
    };
}
exports.default = propertyOf;

},{"./noop.js":"eVJ12","./get.js":"jpYyN","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9U23S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
function times(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = _optimizeCbJsDefault.default(iteratee, context, 1);
    for(var i = 0; i < n; i++)accum[i] = iteratee(i);
    return accum;
}
exports.default = times;

},{"./_optimizeCb.js":"cAw5c","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jDe0A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function random(min, max) {
    if (max == null) {
        max = min;
        min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
}
exports.default = random;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fZ1Zl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = Date.now || function() {
    return new Date().getTime();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"21f6N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createEscaperJs = require("./_createEscaper.js");
var _createEscaperJsDefault = parcelHelpers.interopDefault(_createEscaperJs);
var _escapeMapJs = require("./_escapeMap.js");
var _escapeMapJsDefault = parcelHelpers.interopDefault(_escapeMapJs);
exports.default = _createEscaperJsDefault.default(_escapeMapJsDefault.default);

},{"./_createEscaper.js":"521Gb","./_escapeMap.js":"fPOAI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"521Gb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function createEscaper(map) {
    var escaper = function(match) {
        return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _keysJsDefault.default(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
}
exports.default = createEscaper;

},{"./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fPOAI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"brBbv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createEscaperJs = require("./_createEscaper.js");
var _createEscaperJsDefault = parcelHelpers.interopDefault(_createEscaperJs);
var _unescapeMapJs = require("./_unescapeMap.js");
var _unescapeMapJsDefault = parcelHelpers.interopDefault(_unescapeMapJs);
exports.default = _createEscaperJsDefault.default(_unescapeMapJsDefault.default);

},{"./_createEscaper.js":"521Gb","./_unescapeMap.js":"e8pRT","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e8pRT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _invertJs = require("./invert.js");
var _invertJsDefault = parcelHelpers.interopDefault(_invertJs);
var _escapeMapJs = require("./_escapeMap.js");
var _escapeMapJsDefault = parcelHelpers.interopDefault(_escapeMapJs);
exports.default = _invertJsDefault.default(_escapeMapJsDefault.default);

},{"./invert.js":"hY4ge","./_escapeMap.js":"fPOAI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"69goE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
exports.default = _underscoreJsDefault.default.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
};

},{"./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hyJUN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defaultsJs = require("./defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _templateSettingsJs = require("./templateSettings.js");
// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;
// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
};
var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match) {
    return '\\' + escapes[match];
}
// In order to prevent third-party code injection through
// `_.templateSettings.variable`, we test it against the following regular
// expression. It is intentionally a bit more liberal than just matching valid
// identifiers, but still prevents possible loopholes through defaults or
// destructuring assignment.
var bareIdentifier = /^\s*(\w|\$)+\s*$/;
function template1(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _defaultsJsDefault.default({
    }, settings, _underscoreJsDefault.default.templateSettings);
    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');
    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
        index = offset + match.length;
        if (escape) source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        else if (interpolate) source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        else if (evaluate) source += "';\n" + evaluate + "\n__p+='";
        // Adobe VMs need the match returned to produce the correct offset.
        return match;
    });
    source += "';\n";
    var argument = settings.variable;
    if (argument) {
        // Insure against third-party code injection. (CVE-2021-23358)
        if (!bareIdentifier.test(argument)) throw new Error('variable is not a bare identifier: ' + argument);
    } else {
        // If a variable is not specified, place data values in local scope.
        source = 'with(obj||{}){\n' + source + '}\n';
        argument = 'obj';
    }
    source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
    var render;
    try {
        render = new Function(argument, '_', source);
    } catch (e) {
        e.source = source;
        throw e;
    }
    var template = function(data) {
        return render.call(this, data, _underscoreJsDefault.default);
    };
    // Provide the compiled source as a convenience for precompilation.
    template.source = 'function(' + argument + '){\n' + source + '}';
    return template;
}
exports.default = template1;

},{"./defaults.js":"fFxIE","./underscore.js":"hjck8","./templateSettings.js":"69goE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jjeXL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
function result(obj, path, fallback) {
    path = _toPathJsDefault.default(path);
    var length = path.length;
    if (!length) return _isFunctionJsDefault.default(fallback) ? fallback.call(obj) : fallback;
    for(var i = 0; i < length; i++){
        var prop = obj == null ? void 0 : obj[path[i]];
        if (prop === void 0) {
            prop = fallback;
            i = length; // Ensure we don't continue iterating.
        }
        obj = _isFunctionJsDefault.default(prop) ? prop.call(obj) : prop;
    }
    return obj;
}
exports.default = result;

},{"./isFunction.js":"kDkjm","./_toPath.js":"2PZbF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aS6hE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
function uniqueId(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
}
exports.default = uniqueId;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"h8Igg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
function chain(obj) {
    var instance = _underscoreJsDefault.default(obj);
    instance._chain = true;
    return instance;
}
exports.default = chain;

},{"./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hLcX3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _executeBoundJs = require("./_executeBound.js");
var _executeBoundJsDefault = parcelHelpers.interopDefault(_executeBoundJs);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = _restArgumentsJsDefault.default(function(func, boundArgs) {
    var placeholder = partial.placeholder;
    var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for(var i = 0; i < length; i++)args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        while(position < arguments.length)args.push(arguments[position++]);
        return _executeBoundJsDefault.default(func, bound, this, this, args);
    };
    return bound;
});
partial.placeholder = _underscoreJsDefault.default;
exports.default = partial;

},{"./restArguments.js":"aKoU9","./_executeBound.js":"bOLKm","./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bOLKm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = _baseCreateJsDefault.default(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_isObjectJsDefault.default(result)) return result;
    return self;
}
exports.default = executeBound;

},{"./_baseCreate.js":"3vxk9","./isObject.js":"fewdV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"48NsZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _executeBoundJs = require("./_executeBound.js");
var _executeBoundJsDefault = parcelHelpers.interopDefault(_executeBoundJs);
exports.default = _restArgumentsJsDefault.default(function(func, context, args) {
    if (!_isFunctionJsDefault.default(func)) throw new TypeError('Bind must be called on a function');
    var bound = _restArgumentsJsDefault.default(function(callArgs) {
        return _executeBoundJsDefault.default(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
});

},{"./restArguments.js":"aKoU9","./isFunction.js":"kDkjm","./_executeBound.js":"bOLKm","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9u5NU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _bindJs = require("./bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
exports.default = _restArgumentsJsDefault.default(function(obj, keys) {
    keys = _flattenJsDefault.default(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while(index--){
        var key = keys[index];
        obj[key] = _bindJsDefault.default(obj[key], obj);
    }
    return obj;
});

},{"./restArguments.js":"aKoU9","./_flatten.js":"2sSP7","./bind.js":"48NsZ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2sSP7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
function flatten(input, depth, strict, output) {
    output = output || [];
    if (!depth && depth !== 0) depth = Infinity;
    else if (depth <= 0) return output.concat(input);
    var idx = output.length;
    for(var i = 0, length = _getLengthJsDefault.default(input); i < length; i++){
        var value = input[i];
        if (_isArrayLikeJsDefault.default(value) && (_isArrayJsDefault.default(value) || _isArgumentsJsDefault.default(value))) {
            // Flatten current level of array or arguments object.
            if (depth > 1) {
                flatten(value, depth - 1, strict, output);
                idx = output.length;
            } else {
                var j = 0, len = value.length;
                while(j < len)output[idx++] = value[j++];
            }
        } else if (!strict) output[idx++] = value;
    }
    return output;
}
exports.default = flatten;

},{"./_getLength.js":"30FQX","./_isArrayLike.js":"5QMnd","./isArray.js":"oMlWT","./isArguments.js":"ccahD","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5QMnd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createSizePropertyCheckJs = require("./_createSizePropertyCheck.js");
var _createSizePropertyCheckJsDefault = parcelHelpers.interopDefault(_createSizePropertyCheckJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
exports.default = _createSizePropertyCheckJsDefault.default(_getLengthJsDefault.default);

},{"./_createSizePropertyCheck.js":"b727b","./_getLength.js":"30FQX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ceNZR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
function memoize1(func, hasher) {
    var memoize = function(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!_hasJsDefault.default(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
    };
    memoize.cache = {
    };
    return memoize;
}
exports.default = memoize1;

},{"./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k0bcV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
exports.default = _restArgumentsJsDefault.default(function(func, wait, args) {
    return setTimeout(function() {
        return func.apply(null, args);
    }, wait);
});

},{"./restArguments.js":"aKoU9","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5pRfB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _delayJs = require("./delay.js");
var _delayJsDefault = parcelHelpers.interopDefault(_delayJs);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
exports.default = _partialJsDefault.default(_delayJsDefault.default, _underscoreJsDefault.default, 1);

},{"./partial.js":"hLcX3","./delay.js":"k0bcV","./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"87yq2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {
    };
    var later = function() {
        previous = options.leading === false ? 0 : _nowJsDefault.default();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
    };
    var throttled = function() {
        var _now = _nowJsDefault.default();
        if (!previous && options.leading === false) previous = _now;
        var remaining = wait - (_now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = _now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);
        return result;
    };
    throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
    };
    return throttled;
}
exports.default = throttle;

},{"./now.js":"fZ1Zl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1Csjh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
function debounce(func, wait, immediate) {
    var timeout, previous, args, result, context;
    var later = function() {
        var passed = _nowJsDefault.default() - previous;
        if (wait > passed) timeout = setTimeout(later, wait - passed);
        else {
            timeout = null;
            if (!immediate) result = func.apply(context, args);
            // This check is needed because `func` can recursively invoke `debounced`.
            if (!timeout) args = context = null;
        }
    };
    var debounced = _restArgumentsJsDefault.default(function(_args) {
        context = this;
        args = _args;
        previous = _nowJsDefault.default();
        if (!timeout) {
            timeout = setTimeout(later, wait);
            if (immediate) result = func.apply(context, args);
        }
        return result;
    });
    debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = args = context = null;
    };
    return debounced;
}
exports.default = debounce;

},{"./restArguments.js":"aKoU9","./now.js":"fZ1Zl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"luJbh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
function wrap(func, wrapper) {
    return _partialJsDefault.default(wrapper, func);
}
exports.default = wrap;

},{"./partial.js":"hLcX3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jleQN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function negate(predicate) {
    return function() {
        return !predicate.apply(this, arguments);
    };
}
exports.default = negate;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"NhC2V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while(i--)result = args[i].call(this, result);
        return result;
    };
}
exports.default = compose;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hdEPt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function after(times, func) {
    return function() {
        if (--times < 1) return func.apply(this, arguments);
    };
}
exports.default = after;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6OzV9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function before(times, func) {
    var memo;
    return function() {
        if (--times > 0) memo = func.apply(this, arguments);
        if (times <= 1) func = null;
        return memo;
    };
}
exports.default = before;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g5TYa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _beforeJs = require("./before.js");
var _beforeJsDefault = parcelHelpers.interopDefault(_beforeJs);
exports.default = _partialJsDefault.default(_beforeJsDefault.default, 2);

},{"./partial.js":"hLcX3","./before.js":"6OzV9","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3zqFY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function findKey(obj, predicate, context) {
    predicate = _cbJsDefault.default(predicate, context);
    var _keys = _keysJsDefault.default(obj), key;
    for(var i = 0, length = _keys.length; i < length; i++){
        key = _keys[i];
        if (predicate(obj[key], key, obj)) return key;
    }
}
exports.default = findKey;

},{"./_cb.js":"l45Ig","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"edEuk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createPredicateIndexFinderJs = require("./_createPredicateIndexFinder.js");
var _createPredicateIndexFinderJsDefault = parcelHelpers.interopDefault(_createPredicateIndexFinderJs);
exports.default = _createPredicateIndexFinderJsDefault.default(1);

},{"./_createPredicateIndexFinder.js":"hE3Ft","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hE3Ft":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
        predicate = _cbJsDefault.default(predicate, context);
        var length = _getLengthJsDefault.default(array);
        var index = dir > 0 ? 0 : length - 1;
        for(; index >= 0 && index < length; index += dir){
            if (predicate(array[index], index, array)) return index;
        }
        return -1;
    };
}
exports.default = createPredicateIndexFinder;

},{"./_cb.js":"l45Ig","./_getLength.js":"30FQX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"akOdX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createPredicateIndexFinderJs = require("./_createPredicateIndexFinder.js");
var _createPredicateIndexFinderJsDefault = parcelHelpers.interopDefault(_createPredicateIndexFinderJs);
exports.default = _createPredicateIndexFinderJsDefault.default(-1);

},{"./_createPredicateIndexFinder.js":"hE3Ft","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4zP4e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
function sortedIndex(array, obj, iteratee, context) {
    iteratee = _cbJsDefault.default(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = _getLengthJsDefault.default(array);
    while(low < high){
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1;
        else high = mid;
    }
    return low;
}
exports.default = sortedIndex;

},{"./_cb.js":"l45Ig","./_getLength.js":"30FQX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"krndY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sortedIndexJs = require("./sortedIndex.js");
var _sortedIndexJsDefault = parcelHelpers.interopDefault(_sortedIndexJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _createIndexFinderJs = require("./_createIndexFinder.js");
var _createIndexFinderJsDefault = parcelHelpers.interopDefault(_createIndexFinderJs);
exports.default = _createIndexFinderJsDefault.default(1, _findIndexJsDefault.default, _sortedIndexJsDefault.default);

},{"./sortedIndex.js":"4zP4e","./findIndex.js":"edEuk","./_createIndexFinder.js":"iqbtD","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iqbtD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _setupJs = require("./_setup.js");
var _isNaNJs = require("./isNaN.js");
var _isNaNJsDefault = parcelHelpers.interopDefault(_isNaNJs);
function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
        var i = 0, length = _getLengthJsDefault.default(array);
        if (typeof idx == 'number') {
            if (dir > 0) i = idx >= 0 ? idx : Math.max(idx + length, i);
            else length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        } else if (sortedIndex && idx && length) {
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
            idx = predicateFind(_setupJs.slice.call(array, i, length), _isNaNJsDefault.default);
            return idx >= 0 ? idx + i : -1;
        }
        for(idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir){
            if (array[idx] === item) return idx;
        }
        return -1;
    };
}
exports.default = createIndexFinder;

},{"./_getLength.js":"30FQX","./_setup.js":"bU4rb","./isNaN.js":"3kTfb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4BWXf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findLastIndexJs = require("./findLastIndex.js");
var _findLastIndexJsDefault = parcelHelpers.interopDefault(_findLastIndexJs);
var _createIndexFinderJs = require("./_createIndexFinder.js");
var _createIndexFinderJsDefault = parcelHelpers.interopDefault(_createIndexFinderJs);
exports.default = _createIndexFinderJsDefault.default(-1, _findLastIndexJsDefault.default);

},{"./findLastIndex.js":"akOdX","./_createIndexFinder.js":"iqbtD","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"doTH0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _findKeyJs = require("./findKey.js");
var _findKeyJsDefault = parcelHelpers.interopDefault(_findKeyJs);
function find(obj, predicate, context) {
    var keyFinder = _isArrayLikeJsDefault.default(obj) ? _findIndexJsDefault.default : _findKeyJsDefault.default;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
}
exports.default = find;

},{"./_isArrayLike.js":"5QMnd","./findIndex.js":"edEuk","./findKey.js":"3zqFY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k1pe6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
function findWhere(obj, attrs) {
    return _findJsDefault.default(obj, _matcherJsDefault.default(attrs));
}
exports.default = findWhere;

},{"./find.js":"doTH0","./matcher.js":"ekXoC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ewQpM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function each(obj, iteratee, context) {
    iteratee = _optimizeCbJsDefault.default(iteratee, context);
    var i, length;
    if (_isArrayLikeJsDefault.default(obj)) for(i = 0, length = obj.length; i < length; i++)iteratee(obj[i], i, obj);
    else {
        var _keys = _keysJsDefault.default(obj);
        for(i = 0, length = _keys.length; i < length; i++)iteratee(obj[_keys[i]], _keys[i], obj);
    }
    return obj;
}
exports.default = each;

},{"./_optimizeCb.js":"cAw5c","./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"giPqo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function map(obj, iteratee, context) {
    iteratee = _cbJsDefault.default(iteratee, context);
    var _keys = !_isArrayLikeJsDefault.default(obj) && _keysJsDefault.default(obj), length = (_keys || obj).length, results = Array(length);
    for(var index = 0; index < length; index++){
        var currentKey = _keys ? _keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
}
exports.default = map;

},{"./_cb.js":"l45Ig","./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aPzI9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createReduceJs = require("./_createReduce.js");
var _createReduceJsDefault = parcelHelpers.interopDefault(_createReduceJs);
exports.default = _createReduceJsDefault.default(1);

},{"./_createReduce.js":"a1vBW","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"a1vBW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
function createReduce(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
        var _keys = !_isArrayLikeJsDefault.default(obj) && _keysJsDefault.default(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
        if (!initial) {
            memo = obj[_keys ? _keys[index] : index];
            index += dir;
        }
        for(; index >= 0 && index < length; index += dir){
            var currentKey = _keys ? _keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
    };
    return function(obj, iteratee, memo, context) {
        var initial = arguments.length >= 3;
        return reducer(obj, _optimizeCbJsDefault.default(iteratee, context, 4), memo, initial);
    };
}
exports.default = createReduce;

},{"./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","./_optimizeCb.js":"cAw5c","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1xJDA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createReduceJs = require("./_createReduce.js");
var _createReduceJsDefault = parcelHelpers.interopDefault(_createReduceJs);
exports.default = _createReduceJsDefault.default(-1);

},{"./_createReduce.js":"a1vBW","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eA6Gs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function filter(obj, predicate, context) {
    var results = [];
    predicate = _cbJsDefault.default(predicate, context);
    _eachJsDefault.default(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
    });
    return results;
}
exports.default = filter;

},{"./_cb.js":"l45Ig","./each.js":"ewQpM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bnI9j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
function reject(obj, predicate, context) {
    return _filterJsDefault.default(obj, _negateJsDefault.default(_cbJsDefault.default(predicate)), context);
}
exports.default = reject;

},{"./filter.js":"eA6Gs","./negate.js":"jleQN","./_cb.js":"l45Ig","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cWFVa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function every(obj, predicate, context) {
    predicate = _cbJsDefault.default(predicate, context);
    var _keys = !_isArrayLikeJsDefault.default(obj) && _keysJsDefault.default(obj), length = (_keys || obj).length;
    for(var index = 0; index < length; index++){
        var currentKey = _keys ? _keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
}
exports.default = every;

},{"./_cb.js":"l45Ig","./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Watr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function some(obj, predicate, context) {
    predicate = _cbJsDefault.default(predicate, context);
    var _keys = !_isArrayLikeJsDefault.default(obj) && _keysJsDefault.default(obj), length = (_keys || obj).length;
    for(var index = 0; index < length; index++){
        var currentKey = _keys ? _keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
}
exports.default = some;

},{"./_cb.js":"l45Ig","./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ibLHC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _indexOfJs = require("./indexOf.js");
var _indexOfJsDefault = parcelHelpers.interopDefault(_indexOfJs);
function contains(obj, item, fromIndex, guard) {
    if (!_isArrayLikeJsDefault.default(obj)) obj = _valuesJsDefault.default(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _indexOfJsDefault.default(obj, item, fromIndex) >= 0;
}
exports.default = contains;

},{"./_isArrayLike.js":"5QMnd","./values.js":"gylxe","./indexOf.js":"krndY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2PsTm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _deepGetJs = require("./_deepGet.js");
var _deepGetJsDefault = parcelHelpers.interopDefault(_deepGetJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
exports.default = _restArgumentsJsDefault.default(function(obj, path, args) {
    var contextPath, func;
    if (_isFunctionJsDefault.default(path)) func = path;
    else {
        path = _toPathJsDefault.default(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
    }
    return _mapJsDefault.default(obj, function(context) {
        var method = func;
        if (!method) {
            if (contextPath && contextPath.length) context = _deepGetJsDefault.default(context, contextPath);
            if (context == null) return void 0;
            method = context[path];
        }
        return method == null ? method : method.apply(context, args);
    });
});

},{"./restArguments.js":"aKoU9","./isFunction.js":"kDkjm","./map.js":"giPqo","./_deepGet.js":"9J8i1","./_toPath.js":"2PZbF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"16Uqx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
function pluck(obj, key) {
    return _mapJsDefault.default(obj, _propertyJsDefault.default(key));
}
exports.default = pluck;

},{"./map.js":"giPqo","./property.js":"c6Iih","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"68doq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
function where(obj, attrs) {
    return _filterJsDefault.default(obj, _matcherJsDefault.default(attrs));
}
exports.default = where;

},{"./filter.js":"eA6Gs","./matcher.js":"ekXoC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jGJNf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function max(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity, value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = _isArrayLikeJsDefault.default(obj) ? obj : _valuesJsDefault.default(obj);
        for(var i = 0, length = obj.length; i < length; i++){
            value = obj[i];
            if (value != null && value > result) result = value;
        }
    } else {
        iteratee = _cbJsDefault.default(iteratee, context);
        _eachJsDefault.default(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                result = v;
                lastComputed = computed;
            }
        });
    }
    return result;
}
exports.default = max;

},{"./_isArrayLike.js":"5QMnd","./values.js":"gylxe","./_cb.js":"l45Ig","./each.js":"ewQpM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c6yfU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function min(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity, value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = _isArrayLikeJsDefault.default(obj) ? obj : _valuesJsDefault.default(obj);
        for(var i = 0, length = obj.length; i < length; i++){
            value = obj[i];
            if (value != null && value < result) result = value;
        }
    } else {
        iteratee = _cbJsDefault.default(iteratee, context);
        _eachJsDefault.default(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed < lastComputed || computed === Infinity && result === Infinity) {
                result = v;
                lastComputed = computed;
            }
        });
    }
    return result;
}
exports.default = min;

},{"./_isArrayLike.js":"5QMnd","./values.js":"gylxe","./_cb.js":"l45Ig","./each.js":"ewQpM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7rhS3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sampleJs = require("./sample.js");
var _sampleJsDefault = parcelHelpers.interopDefault(_sampleJs);
function shuffle(obj) {
    return _sampleJsDefault.default(obj, Infinity);
}
exports.default = shuffle;

},{"./sample.js":"1Yno6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1Yno6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _cloneJs = require("./clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
function sample1(obj, n, guard) {
    if (n == null || guard) {
        if (!_isArrayLikeJsDefault.default(obj)) obj = _valuesJsDefault.default(obj);
        return obj[_randomJsDefault.default(obj.length - 1)];
    }
    var sample = _isArrayLikeJsDefault.default(obj) ? _cloneJsDefault.default(obj) : _valuesJsDefault.default(obj);
    var length = _getLengthJsDefault.default(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for(var index = 0; index < n; index++){
        var rand = _randomJsDefault.default(index, last);
        var temp = sample[index];
        sample[index] = sample[rand];
        sample[rand] = temp;
    }
    return sample.slice(0, n);
}
exports.default = sample1;

},{"./_isArrayLike.js":"5QMnd","./clone.js":"agxO3","./values.js":"gylxe","./_getLength.js":"30FQX","./random.js":"jDe0A","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9ldTP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _pluckJs = require("./pluck.js");
var _pluckJsDefault = parcelHelpers.interopDefault(_pluckJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
function sortBy(obj, iteratee, context) {
    var index = 0;
    iteratee = _cbJsDefault.default(iteratee, context);
    return _pluckJsDefault.default(_mapJsDefault.default(obj, function(value, key, list) {
        return {
            value: value,
            index: index++,
            criteria: iteratee(value, key, list)
        };
    }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
    }), 'value');
}
exports.default = sortBy;

},{"./_cb.js":"l45Ig","./pluck.js":"16Uqx","./map.js":"giPqo","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gXyFd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
exports.default = _groupJsDefault.default(function(result, value, key) {
    if (_hasJsDefault.default(result, key)) result[key].push(value);
    else result[key] = [
        value
    ];
});

},{"./_group.js":"ddU4F","./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ddU4F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function group(behavior, partition) {
    return function(obj, iteratee, context) {
        var result = partition ? [
            [],
            []
        ] : {
        };
        iteratee = _cbJsDefault.default(iteratee, context);
        _eachJsDefault.default(obj, function(value, index) {
            var key = iteratee(value, index, obj);
            behavior(result, value, key);
        });
        return result;
    };
}
exports.default = group;

},{"./_cb.js":"l45Ig","./each.js":"ewQpM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8sscK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
exports.default = _groupJsDefault.default(function(result, value, key) {
    result[key] = value;
});

},{"./_group.js":"ddU4F","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"58Fry":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
exports.default = _groupJsDefault.default(function(result, value, key) {
    if (_hasJsDefault.default(result, key)) result[key]++;
    else result[key] = 1;
});

},{"./_group.js":"ddU4F","./_has.js":"aSS50","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fVFy0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
exports.default = _groupJsDefault.default(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
}, true);

},{"./_group.js":"ddU4F","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9hdGm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _setupJs = require("./_setup.js");
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
    if (!obj) return [];
    if (_isArrayJsDefault.default(obj)) return _setupJs.slice.call(obj);
    if (_isStringJsDefault.default(obj)) // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
    if (_isArrayLikeJsDefault.default(obj)) return _mapJsDefault.default(obj, _identityJsDefault.default);
    return _valuesJsDefault.default(obj);
}
exports.default = toArray;

},{"./isArray.js":"oMlWT","./_setup.js":"bU4rb","./isString.js":"lSLRQ","./_isArrayLike.js":"5QMnd","./map.js":"giPqo","./identity.js":"f05xz","./values.js":"gylxe","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6mXmd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function size(obj) {
    if (obj == null) return 0;
    return _isArrayLikeJsDefault.default(obj) ? obj.length : _keysJsDefault.default(obj).length;
}
exports.default = size;

},{"./_isArrayLike.js":"5QMnd","./keys.js":"l8Krv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iJky2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
var _keyInObjJs = require("./_keyInObj.js");
var _keyInObjJsDefault = parcelHelpers.interopDefault(_keyInObjJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
exports.default = _restArgumentsJsDefault.default(function(obj, keys) {
    var result = {
    }, iteratee = keys[0];
    if (obj == null) return result;
    if (_isFunctionJsDefault.default(iteratee)) {
        if (keys.length > 1) iteratee = _optimizeCbJsDefault.default(iteratee, keys[1]);
        keys = _allKeysJsDefault.default(obj);
    } else {
        iteratee = _keyInObjJsDefault.default;
        keys = _flattenJsDefault.default(keys, false, false);
        obj = Object(obj);
    }
    for(var i = 0, length = keys.length; i < length; i++){
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
});

},{"./restArguments.js":"aKoU9","./isFunction.js":"kDkjm","./_optimizeCb.js":"cAw5c","./allKeys.js":"gEhlz","./_keyInObj.js":"emMBs","./_flatten.js":"2sSP7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"emMBs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function keyInObj(value, key, obj) {
    return key in obj;
}
exports.default = keyInObj;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7TToI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _pickJs = require("./pick.js");
var _pickJsDefault = parcelHelpers.interopDefault(_pickJs);
exports.default = _restArgumentsJsDefault.default(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_isFunctionJsDefault.default(iteratee)) {
        iteratee = _negateJsDefault.default(iteratee);
        if (keys.length > 1) context = keys[1];
    } else {
        keys = _mapJsDefault.default(_flattenJsDefault.default(keys, false, false), String);
        iteratee = function(value, key) {
            return !_containsJsDefault.default(keys, key);
        };
    }
    return _pickJsDefault.default(obj, iteratee, context);
});

},{"./restArguments.js":"aKoU9","./isFunction.js":"kDkjm","./negate.js":"jleQN","./map.js":"giPqo","./_flatten.js":"2sSP7","./contains.js":"ibLHC","./pick.js":"iJky2","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1fmF2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _initialJs = require("./initial.js");
var _initialJsDefault = parcelHelpers.interopDefault(_initialJs);
function first(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[0];
    return _initialJsDefault.default(array, array.length - n);
}
exports.default = first;

},{"./initial.js":"2Q93K","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2Q93K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function initial(array, n, guard) {
    return _setupJs.slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}
exports.default = initial;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gWLnh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restJs = require("./rest.js");
var _restJsDefault = parcelHelpers.interopDefault(_restJs);
function last(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _restJsDefault.default(array, Math.max(0, array.length - n));
}
exports.default = last;

},{"./rest.js":"l7YiK","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"l7YiK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function rest(array, n, guard) {
    return _setupJs.slice.call(array, n == null || guard ? 1 : n);
}
exports.default = rest;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5geL8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
function compact(array) {
    return _filterJsDefault.default(array, Boolean);
}
exports.default = compact;

},{"./filter.js":"eA6Gs","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kzSeC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
function flatten(array, depth) {
    return _flattenJsDefault.default(array, depth, false);
}
exports.default = flatten;

},{"./_flatten.js":"2sSP7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jGT7e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _differenceJs = require("./difference.js");
var _differenceJsDefault = parcelHelpers.interopDefault(_differenceJs);
exports.default = _restArgumentsJsDefault.default(function(array, otherArrays) {
    return _differenceJsDefault.default(array, otherArrays);
});

},{"./restArguments.js":"aKoU9","./difference.js":"iJk2V","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iJk2V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
exports.default = _restArgumentsJsDefault.default(function(array, rest) {
    rest = _flattenJsDefault.default(rest, true, true);
    return _filterJsDefault.default(array, function(value) {
        return !_containsJsDefault.default(rest, value);
    });
});

},{"./restArguments.js":"aKoU9","./_flatten.js":"2sSP7","./filter.js":"eA6Gs","./contains.js":"ibLHC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ci6Hh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isBooleanJs = require("./isBoolean.js");
var _isBooleanJsDefault = parcelHelpers.interopDefault(_isBooleanJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
function uniq(array, isSorted, iteratee, context) {
    if (!_isBooleanJsDefault.default(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
    }
    if (iteratee != null) iteratee = _cbJsDefault.default(iteratee, context);
    var result = [];
    var seen = [];
    for(var i = 0, length = _getLengthJsDefault.default(array); i < length; i++){
        var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted && !iteratee) {
            if (!i || seen !== computed) result.push(value);
            seen = computed;
        } else if (iteratee) {
            if (!_containsJsDefault.default(seen, computed)) {
                seen.push(computed);
                result.push(value);
            }
        } else if (!_containsJsDefault.default(result, value)) result.push(value);
    }
    return result;
}
exports.default = uniq;

},{"./isBoolean.js":"ffqST","./_cb.js":"l45Ig","./_getLength.js":"30FQX","./contains.js":"ibLHC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9B8VJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _uniqJs = require("./uniq.js");
var _uniqJsDefault = parcelHelpers.interopDefault(_uniqJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
exports.default = _restArgumentsJsDefault.default(function(arrays) {
    return _uniqJsDefault.default(_flattenJsDefault.default(arrays, true, true));
});

},{"./restArguments.js":"aKoU9","./uniq.js":"ci6Hh","./_flatten.js":"2sSP7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9e2VQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
function intersection(array) {
    var result = [];
    var argsLength = arguments.length;
    for(var i = 0, length = _getLengthJsDefault.default(array); i < length; i++){
        var item = array[i];
        if (_containsJsDefault.default(result, item)) continue;
        var j;
        for(j = 1; j < argsLength; j++){
            if (!_containsJsDefault.default(arguments[j], item)) break;
        }
        if (j === argsLength) result.push(item);
    }
    return result;
}
exports.default = intersection;

},{"./_getLength.js":"30FQX","./contains.js":"ibLHC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8xaCn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _maxJs = require("./max.js");
var _maxJsDefault = parcelHelpers.interopDefault(_maxJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _pluckJs = require("./pluck.js");
var _pluckJsDefault = parcelHelpers.interopDefault(_pluckJs);
function unzip(array) {
    var length = array && _maxJsDefault.default(array, _getLengthJsDefault.default).length || 0;
    var result = Array(length);
    for(var index = 0; index < length; index++)result[index] = _pluckJsDefault.default(array, index);
    return result;
}
exports.default = unzip;

},{"./max.js":"jGJNf","./_getLength.js":"30FQX","./pluck.js":"16Uqx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"LKE7e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
exports.default = _restArgumentsJsDefault.default(_unzipJsDefault.default);

},{"./restArguments.js":"aKoU9","./unzip.js":"8xaCn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3kVS9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
function object(list, values) {
    var result = {
    };
    for(var i = 0, length = _getLengthJsDefault.default(list); i < length; i++)if (values) result[list[i]] = values[i];
    else result[list[i][0]] = list[i][1];
    return result;
}
exports.default = object;

},{"./_getLength.js":"30FQX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6d5vI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function range1(start, stop, step) {
    if (stop == null) {
        stop = start || 0;
        start = 0;
    }
    if (!step) step = stop < start ? -1 : 1;
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);
    for(var idx = 0; idx < length; idx++, start += step)range[idx] = start;
    return range;
}
exports.default = range1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bTQIh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
function chunk(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while(i < length)result.push(_setupJs.slice.call(array, i, i += count));
    return result;
}
exports.default = chunk;

},{"./_setup.js":"bU4rb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Jc5x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _functionsJs = require("./functions.js");
var _functionsJsDefault = parcelHelpers.interopDefault(_functionsJs);
var _setupJs = require("./_setup.js");
var _chainResultJs = require("./_chainResult.js");
var _chainResultJsDefault = parcelHelpers.interopDefault(_chainResultJs);
function mixin(obj) {
    _eachJsDefault.default(_functionsJsDefault.default(obj), function(name) {
        var func = _underscoreJsDefault.default[name] = obj[name];
        _underscoreJsDefault.default.prototype[name] = function() {
            var args = [
                this._wrapped
            ];
            _setupJs.push.apply(args, arguments);
            return _chainResultJsDefault.default(this, func.apply(_underscoreJsDefault.default, args));
        };
    });
    return _underscoreJsDefault.default;
}
exports.default = mixin;

},{"./underscore.js":"hjck8","./each.js":"ewQpM","./functions.js":"aQpNB","./_setup.js":"bU4rb","./_chainResult.js":"lic3h","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lic3h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
function chainResult(instance, obj) {
    return instance._chain ? _underscoreJsDefault.default(obj).chain() : obj;
}
exports.default = chainResult;

},{"./underscore.js":"hjck8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ehthA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _setupJs = require("./_setup.js");
var _chainResultJs = require("./_chainResult.js");
var _chainResultJsDefault = parcelHelpers.interopDefault(_chainResultJs);
// Add all mutator `Array` functions to the wrapper.
_eachJsDefault.default([
    'pop',
    'push',
    'reverse',
    'shift',
    'sort',
    'splice',
    'unshift'
], function(name) {
    var method = _setupJs.ArrayProto[name];
    _underscoreJsDefault.default.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
            method.apply(obj, arguments);
            if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
        }
        return _chainResultJsDefault.default(this, obj);
    };
});
// Add all accessor `Array` functions to the wrapper.
_eachJsDefault.default([
    'concat',
    'join',
    'slice'
], function(name) {
    var method = _setupJs.ArrayProto[name];
    _underscoreJsDefault.default.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) obj = method.apply(obj, arguments);
        return _chainResultJsDefault.default(this, obj);
    };
});
exports.default = _underscoreJsDefault.default;

},{"./underscore.js":"hjck8","./each.js":"ewQpM","./_setup.js":"bU4rb","./_chainResult.js":"lic3h","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gYrD3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "importGraphMl", ()=>importGraphMl
);
parcelHelpers.export(exports, "exportGraphMl", ()=>exportGraphMl
);
var _graphmlJs = require("graphml-js");
var _xmlJs = require("xml-js");
var _xmlJsDefault = parcelHelpers.interopDefault(_xmlJs);
const inputElement = document.getElementById("inputElement");
inputElement.onchange = importGraphMl;
function importGraphMl(_) {
    const file = inputElement.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e)=>{
        const textContent = e.target.result;
        var parser = new _graphmlJs.GraphMLParser();
        parser.parse(textContent, function(err, graphml) {
            var graphVertices = mapGraphMlToVertices(graphml);
            var graphEdges = mapGraphMlToEdges(graphml, graphVertices);
            window.graph.importGraph(graphVertices, graphEdges);
        });
    };
    reader.onerror = (e)=>{
        const error = e.target.error;
        console.error(`Error occured while reading ${file.name}`, error);
    };
    reader.readAsText(file);
}
function mapGraphMlToVertices(graphml) {
    var nodes = graphml.nodes;
    var graphVertices = [];
    nodes.forEach((node, index)=>{
        var newVertice = {
            id: index,
            title: node["_id"]
        };
        graphVertices.push(newVertice);
    });
    return graphVertices;
}
function mapGraphMlToEdges(graphml, graphVertices) {
    var edges = graphml.edges;
    var graphEdges = [];
    edges.forEach((edge)=>{
        var newEdge = {
            source: graphVertices.findIndex((v)=>v.title == edge["_source"]
            ),
            target: graphVertices.findIndex((v)=>v.title == edge["_target"]
            )
        };
        graphEdges.push(newEdge);
    });
    return graphEdges;
}
function verticesToGraphMl(vertices) {
    return vertices.map((v)=>({
            "_attributes": {
                id: v["id"]
            }
        })
    );
}
function edgesToGraphMl(edges) {
    return edges.map((e)=>({
            "_attributes": {
                source: e["source"]["id"],
                target: e["target"]["id"]
            }
        })
    );
}
function exportGraphMl(vertices, edges) {
    var json = {
        "_declaration": {
            "_attributes": {
                "version": "1.0",
                "encoding": "UTF-8"
            }
        },
        "graphml": {
            "graph": {
                "node": verticesToGraphMl(vertices),
                "edge": edgesToGraphMl(edges)
            }
        }
    };
    var options = {
        compact: true,
        ignoreComment: true,
        spaces: 4
    };
    var resultJson = _xmlJsDefault.default.js2xml(json, options);
    download(resultJson, "graph.graphml", "text/plain");
}
function download(data, filename, type) {
    var file = new Blob([
        data
    ], {
        type: type
    });
    if (window.navigator.msSaveOrOpenBlob) window.navigator.msSaveOrOpenBlob(file, filename);
    else {
        var a = document.createElement("a"), url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    }
}

},{"graphml-js":"26k9B","xml-js":"a22RV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"26k9B":[function(require,module,exports) {
/// <reference path="../typings/index.d.ts" />
"use strict";
var __extends = this && this.__extends || function(d, b) {
    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var xml2js_1 = require('xml2js');
var GraphElement1 = function() {
    function GraphElement(id) {
        this.id = id;
        this.attributes = {
        };
    }
    Object.defineProperty(GraphElement.prototype, "id", {
        get: function() {
            return this._id;
        },
        set: function(id) {
            this._id = id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphElement.prototype, "attributes", {
        get: function() {
            return this._attributes;
        },
        set: function(attributes) {
            this._attributes = attributes;
        },
        enumerable: true,
        configurable: true
    });
    return GraphElement;
}();
exports.GraphElement = GraphElement1;
var Node1 = function(_super) {
    __extends(Node, _super);
    function Node(id) {
        _super.call(this, id);
    }
    return Node;
}(GraphElement1);
exports.Node = Node1;
var Edge1 = function(_super) {
    __extends(Edge, _super);
    function Edge(id, source, target) {
        _super.call(this, id);
        this.source = source;
        this.target = target;
    }
    Object.defineProperty(Edge.prototype, "source", {
        get: function() {
            return this._source;
        },
        set: function(source) {
            this._source = source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Edge.prototype, "target", {
        get: function() {
            return this._target;
        },
        set: function(target) {
            this._target = target;
        },
        enumerable: true,
        configurable: true
    });
    return Edge;
}(GraphElement1);
exports.Edge = Edge1;
var Graph1 = function() {
    function Graph() {
        this.nodes = new Array();
        this.edges = new Array();
    }
    return Graph;
}();
exports.Graph = Graph1;
var AttributeKey1 = function() {
    function AttributeKey(name, dataType) {
        this.name = name;
        this.dataType = dataType;
    }
    return AttributeKey;
}();
var GraphMLParser1 = function() {
    function GraphMLParser() {
        this.keys = {
        };
        this.graph = new Graph1();
    }
    GraphMLParser.prototype.parse = function(text, cb) {
        var _this = this;
        var parser = new xml2js_1.Parser();
        parser.parseString(text, function(err, data) {
            _this.buildKeys(data);
            _this.buildNodes(data);
            _this.buildEdges(data);
            cb(err, _this.graph);
        });
    };
    GraphMLParser.prototype.buildKeys = function(data) {
        for(var i in data.graphml.key){
            var key = data.graphml.key[i]['$'];
            var keyId = key.id;
            var name_1 = key['attr.name'];
            var dataType = key['attr.type'];
            var newKey = new AttributeKey1(name_1, dataType);
            this.keys[keyId] = newKey;
        }
    };
    GraphMLParser.prototype.buildNodes = function(data) {
        var nodes = data.graphml.graph[0].node;
        for(var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++){
            var node = nodes_1[_i];
            var id = node['$'].id;
            var newNode = new Node1(id);
            if (node.data !== undefined) this.buildAttributes(newNode.attributes, node.data);
            this.graph.nodes.push(newNode);
        }
    };
    GraphMLParser.prototype.buildEdges = function(data) {
        var edges = data.graphml.graph[0].edge;
        for(var _i = 0, edges_1 = edges; _i < edges_1.length; _i++){
            var edge = edges_1[_i];
            var id = edge['$'].id;
            var source = edge['$'].source;
            var target = edge['$'].target;
            var newEdge = new Edge1(id, source, target);
            if (edge.data !== undefined) this.buildAttributes(newEdge.attributes, edge.data);
            this.graph.edges.push(newEdge);
        }
    };
    GraphMLParser.prototype.buildAttributes = function(newAttr, attributes) {
        for(var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++){
            var attribute = attributes_1[_i];
            var attributeKey = attribute['$'].key;
            var attributeName = this.keys[attributeKey].name;
            var attributeValue = attribute['_'];
            var attributeDataType = this.keys[attributeKey].dataType;
            if (attributeDataType === 'int' || attributeDataType === 'long' || attributeDataType === 'float' || attributeDataType === 'double') newAttr[attributeName] = Number(attributeValue);
            else newAttr[attributeName] = attributeValue;
        }
    };
    return GraphMLParser;
}();
exports.GraphMLParser = GraphMLParser1;

},{"xml2js":"3dvPL"}],"3dvPL":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var builder, defaults, parser, processors, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    defaults = require('./defaults');
    builder = require('./builder');
    parser = require('./parser');
    processors = require('./processors');
    exports.defaults = defaults.defaults;
    exports.processors = processors;
    exports.ValidationError = (function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
            this.message = message;
        }
        return ValidationError;
    })(Error);
    exports.Builder = builder.Builder;
    exports.Parser = parser.Parser;
    exports.parseString = parser.parseString;
    exports.parseStringPromise = parser.parseStringPromise;
}).call(this);

},{"./defaults":"fDk2h","./builder":"hB728","./parser":"8Wy45","./processors":"ckxC8"}],"fDk2h":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    exports.defaults = {
        "0.1": {
            explicitCharkey: false,
            trim: true,
            normalize: true,
            normalizeTags: false,
            attrkey: "@",
            charkey: "#",
            explicitArray: false,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: false,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            childkey: '@@',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ''
        },
        "0.2": {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            charkey: "_",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: '$$',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: 'root',
            xmldec: {
                'version': '1.0',
                'encoding': 'UTF-8',
                'standalone': true
            },
            doctype: null,
            renderOpts: {
                'pretty': true,
                'indent': '  ',
                'newline': '\n'
            },
            headless: false,
            chunkSize: 10000,
            emptyTag: '',
            cdata: false
        }
    };
}).call(this);

},{}],"hB728":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {
    }.hasOwnProperty;
    builder = require('xmlbuilder');
    defaults = require('./defaults').defaults;
    requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
    };
    wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };
    escapeCDATA = function(entry) {
        return entry.replace(']]>', ']]]]><![CDATA[>');
    };
    exports.Builder = (function() {
        function Builder(opts) {
            var key, ref, value;
            this.options = {
            };
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
        }
        Builder.prototype.buildObject = function(rootObj) {
            var attrkey, charkey, render, rootElement, rootName;
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults['0.2'].rootName) {
                rootName = Object.keys(rootObj)[0];
                rootObj = rootObj[rootName];
            } else rootName = this.options.rootName;
            render = (function(_this) {
                return function(element, obj) {
                    var attr, child, entry, index, key, value;
                    if (typeof obj !== 'object') {
                        if (_this.options.cdata && requiresCDATA(obj)) element.raw(wrapCDATA(obj));
                        else element.txt(obj);
                    } else if (Array.isArray(obj)) for(index in obj){
                        if (!hasProp.call(obj, index)) continue;
                        child = obj[index];
                        for(key in child){
                            entry = child[key];
                            element = render(element.ele(key), entry).up();
                        }
                    }
                    else for(key in obj){
                        if (!hasProp.call(obj, key)) continue;
                        child = obj[key];
                        if (key === attrkey) {
                            if (typeof child === "object") for(attr in child){
                                value = child[attr];
                                element = element.att(attr, value);
                            }
                        } else if (key === charkey) {
                            if (_this.options.cdata && requiresCDATA(child)) element = element.raw(wrapCDATA(child));
                            else element = element.txt(child);
                        } else if (Array.isArray(child)) for(index in child){
                            if (!hasProp.call(child, index)) continue;
                            entry = child[index];
                            if (typeof entry === 'string') {
                                if (_this.options.cdata && requiresCDATA(entry)) element = element.ele(key).raw(wrapCDATA(entry)).up();
                                else element = element.ele(key, entry).up();
                            } else element = render(element.ele(key), entry).up();
                        }
                        else if (typeof child === "object") element = render(element.ele(key), child).up();
                        else if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) element = element.ele(key).raw(wrapCDATA(child)).up();
                        else {
                            if (child == null) child = '';
                            element = element.ele(key, child.toString()).up();
                        }
                    }
                    return element;
                };
            })(this);
            rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                headless: this.options.headless,
                allowSurrogateChars: this.options.allowSurrogateChars
            });
            return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
    })();
}).call(this);

},{"xmlbuilder":"hA8zs","./defaults":"fDk2h"}],"hA8zs":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
    ref = require('./Utility'), assign = ref.assign, isFunction = ref.isFunction;
    XMLDOMImplementation = require('./XMLDOMImplementation');
    XMLDocument = require('./XMLDocument');
    XMLDocumentCB = require('./XMLDocumentCB');
    XMLStringWriter = require('./XMLStringWriter');
    XMLStreamWriter = require('./XMLStreamWriter');
    NodeType = require('./NodeType');
    WriterState = require('./WriterState');
    module.exports.create = function(name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) throw new Error("Root element needs a name.");
        options = assign({
        }, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name);
        if (!options.headless) {
            doc.declaration(options);
            if (options.pubID != null || options.sysID != null) doc.dtd(options);
        }
        return root;
    };
    module.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
            ref1 = [
                options,
                onData
            ], onData = ref1[0], onEnd = ref1[1];
            options = {
            };
        }
        if (onData) return new XMLDocumentCB(options, onData, onEnd);
        else return new XMLDocument(options);
    };
    module.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
    };
    module.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
    };
    module.exports.implementation = new XMLDOMImplementation();
    module.exports.nodeType = NodeType;
    module.exports.writerState = WriterState;
}).call(this);

},{"./Utility":"3gpwT","./XMLDOMImplementation":"9wwaI","./XMLDocument":"8Zx5L","./XMLDocumentCB":"aJkVd","./XMLStringWriter":"WCwh2","./XMLStreamWriter":"8vRPE","./NodeType":"bHsfv","./WriterState":"psDCU"}],"3gpwT":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {
    }.hasOwnProperty;
    assign = function() {
        var i, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) Object.assign.apply(null, arguments);
        else for(i = 0, len = sources.length; i < len; i++){
            source = sources[i];
            if (source != null) for(key in source){
                if (!hasProp.call(source, key)) continue;
                target[key] = source[key];
            }
        }
        return target;
    };
    isFunction = function(val) {
        return !!val && Object.prototype.toString.call(val) === '[object Function]';
    };
    isObject = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === 'function' || ref === 'object');
    };
    isArray = function(val) {
        if (isFunction(Array.isArray)) return Array.isArray(val);
        else return Object.prototype.toString.call(val) === '[object Array]';
    };
    isEmpty = function(val) {
        var key;
        if (isArray(val)) return !val.length;
        else {
            for(key in val){
                if (!hasProp.call(val, key)) continue;
                return false;
            }
            return true;
        }
    };
    isPlainObject = function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === 'function' && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    };
    getValue = function(obj) {
        if (isFunction(obj.valueOf)) return obj.valueOf();
        else return obj;
    };
    module.exports.assign = assign;
    module.exports.isFunction = isFunction;
    module.exports.isObject = isObject;
    module.exports.isArray = isArray;
    module.exports.isEmpty = isEmpty;
    module.exports.isPlainObject = isPlainObject;
    module.exports.getValue = getValue;
}).call(this);

},{}],"9wwaI":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMImplementation1;
    module.exports = XMLDOMImplementation1 = (function() {
        function XMLDOMImplementation() {
        }
        XMLDOMImplementation.prototype.hasFeature = function(feature, version) {
            return true;
        };
        XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented.");
        };
        return XMLDOMImplementation;
    })();
}).call(this);

},{}],"8Zx5L":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument1, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    isPlainObject = require('./Utility').isPlainObject;
    XMLDOMImplementation = require('./XMLDOMImplementation');
    XMLDOMConfiguration = require('./XMLDOMConfiguration');
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    XMLStringifier = require('./XMLStringifier');
    XMLStringWriter = require('./XMLStringWriter');
    module.exports = XMLDocument1 = (function(superClass) {
        extend(XMLDocument, superClass);
        function XMLDocument(options) {
            XMLDocument.__super__.constructor.call(this, null);
            this.name = "#document";
            this.type = NodeType.Document;
            this.documentURI = null;
            this.domConfig = new XMLDOMConfiguration();
            options || (options = {
            });
            if (!options.writer) options.writer = new XMLStringWriter();
            this.options = options;
            this.stringify = new XMLStringifier(options);
        }
        Object.defineProperty(XMLDocument.prototype, 'implementation', {
            value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument.prototype, 'doctype', {
            get: function() {
                var child, i, len, ref;
                ref = this.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.DocType) return child;
                }
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'documentElement', {
            get: function() {
                return this.rootObject || null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {
            get: function() {
                return false;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {
            get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].encoding;
                else return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {
            get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].standalone === 'yes';
                else return false;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {
            get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].version;
                else return "1.0";
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'URL', {
            get: function() {
                return this.documentURI;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'origin', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'compatMode', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'characterSet', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'contentType', {
            get: function() {
                return null;
            }
        });
        XMLDocument.prototype.end = function(writer) {
            var writerOptions;
            writerOptions = {
            };
            if (!writer) writer = this.options.writer;
            else if (isPlainObject(writer)) {
                writerOptions = writer;
                writer = this.options.writer;
            }
            return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument.prototype.toString = function(options) {
            return this.options.writer.document(this, this.options.writer.filterOptions(options));
        };
        XMLDocument.prototype.createElement = function(tagName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createDocumentFragment = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createTextNode = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createComment = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createCDATASection = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createProcessingInstruction = function(target, data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createAttribute = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createEntityReference = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.importNode = function(importedNode, deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementById = function(elementId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.adoptNode = function(source) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.normalizeDocument = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createEvent = function(eventInterface) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createRange = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLDocument;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLDOMImplementation":"9wwaI","./XMLDOMConfiguration":"as1md","./XMLNode":"9Mxux","./NodeType":"bHsfv","./XMLStringifier":"i909L","./XMLStringWriter":"WCwh2"}],"as1md":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMConfiguration1, XMLDOMErrorHandler, XMLDOMStringList;
    XMLDOMErrorHandler = require('./XMLDOMErrorHandler');
    XMLDOMStringList = require('./XMLDOMStringList');
    module.exports = XMLDOMConfiguration1 = (function() {
        function XMLDOMConfiguration() {
            var clonedSelf;
            this.defaultParams = {
                "canonical-form": false,
                "cdata-sections": false,
                "comments": false,
                "datatype-normalization": false,
                "element-content-whitespace": true,
                "entities": true,
                "error-handler": new XMLDOMErrorHandler(),
                "infoset": true,
                "validate-if-schema": false,
                "namespaces": true,
                "namespace-declarations": true,
                "normalize-characters": false,
                "schema-location": '',
                "schema-type": '',
                "split-cdata-sections": true,
                "validate": false,
                "well-formed": true
            };
            this.params = clonedSelf = Object.create(this.defaultParams);
        }
        Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {
            get: function() {
                return new XMLDOMStringList(Object.keys(this.defaultParams));
            }
        });
        XMLDOMConfiguration.prototype.getParameter = function(name) {
            if (this.params.hasOwnProperty(name)) return this.params[name];
            else return null;
        };
        XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
            return true;
        };
        XMLDOMConfiguration.prototype.setParameter = function(name, value) {
            if (value != null) return this.params[name] = value;
            else return delete this.params[name];
        };
        return XMLDOMConfiguration;
    })();
}).call(this);

},{"./XMLDOMErrorHandler":"kyoOB","./XMLDOMStringList":"h1tRX"}],"kyoOB":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMErrorHandler1;
    module.exports = XMLDOMErrorHandler1 = (function() {
        function XMLDOMErrorHandler() {
        }
        XMLDOMErrorHandler.prototype.handleError = function(error) {
            throw new Error(error);
        };
        return XMLDOMErrorHandler;
    })();
}).call(this);

},{}],"h1tRX":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMStringList1;
    module.exports = XMLDOMStringList1 = (function() {
        function XMLDOMStringList(arr) {
            this.arr = arr || [];
        }
        Object.defineProperty(XMLDOMStringList.prototype, 'length', {
            get: function() {
                return this.arr.length;
            }
        });
        XMLDOMStringList.prototype.item = function(index) {
            return this.arr[index] || null;
        };
        XMLDOMStringList.prototype.contains = function(str) {
            return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList;
    })();
}).call(this);

},{}],"9Mxux":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode1, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {
    }.hasOwnProperty;
    ref1 = require('./Utility'), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
    XMLElement = null;
    XMLCData = null;
    XMLComment = null;
    XMLDeclaration = null;
    XMLDocType = null;
    XMLRaw = null;
    XMLText = null;
    XMLProcessingInstruction = null;
    XMLDummy = null;
    NodeType = null;
    XMLNodeList = null;
    XMLNamedNodeMap = null;
    DocumentPosition = null;
    module.exports = XMLNode1 = (function() {
        function XMLNode(parent1) {
            this.parent = parent1;
            if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
            }
            this.value = null;
            this.children = [];
            this.baseURI = null;
            if (!XMLElement) {
                XMLElement = require('./XMLElement');
                XMLCData = require('./XMLCData');
                XMLComment = require('./XMLComment');
                XMLDeclaration = require('./XMLDeclaration');
                XMLDocType = require('./XMLDocType');
                XMLRaw = require('./XMLRaw');
                XMLText = require('./XMLText');
                XMLProcessingInstruction = require('./XMLProcessingInstruction');
                XMLDummy = require('./XMLDummy');
                NodeType = require('./NodeType');
                XMLNodeList = require('./XMLNodeList');
                XMLNamedNodeMap = require('./XMLNamedNodeMap');
                DocumentPosition = require('./DocumentPosition');
            }
        }
        Object.defineProperty(XMLNode.prototype, 'nodeName', {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'nodeType', {
            get: function() {
                return this.type;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'nodeValue', {
            get: function() {
                return this.value;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'parentNode', {
            get: function() {
                return this.parent;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'childNodes', {
            get: function() {
                if (!this.childNodeList || !this.childNodeList.nodes) this.childNodeList = new XMLNodeList(this.children);
                return this.childNodeList;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'firstChild', {
            get: function() {
                return this.children[0] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'lastChild', {
            get: function() {
                return this.children[this.children.length - 1] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'previousSibling', {
            get: function() {
                var i;
                i = this.parent.children.indexOf(this);
                return this.parent.children[i - 1] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'nextSibling', {
            get: function() {
                var i;
                i = this.parent.children.indexOf(this);
                return this.parent.children[i + 1] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'ownerDocument', {
            get: function() {
                return this.document() || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'textContent', {
            get: function() {
                var child, j, len, ref2, str;
                if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
                    str = '';
                    ref2 = this.children;
                    for(j = 0, len = ref2.length; j < len; j++){
                        child = ref2[j];
                        if (child.textContent) str += child.textContent;
                    }
                    return str;
                } else return null;
            },
            set: function(value) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        XMLNode.prototype.setParent = function(parent) {
            var child, j, len, ref2, results;
            this.parent = parent;
            if (parent) {
                this.options = parent.options;
                this.stringify = parent.stringify;
            }
            ref2 = this.children;
            results = [];
            for(j = 0, len = ref2.length; j < len; j++){
                child = ref2[j];
                results.push(child.setParent(this));
            }
            return results;
        };
        XMLNode.prototype.element = function(name, attributes, text) {
            var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
            lastChild = null;
            if (attributes === null && text == null) ref2 = [
                {
                },
                null
            ], attributes = ref2[0], text = ref2[1];
            if (attributes == null) attributes = {
            };
            attributes = getValue(attributes);
            if (!isObject(attributes)) ref3 = [
                attributes,
                text
            ], text = ref3[0], attributes = ref3[1];
            if (name != null) name = getValue(name);
            if (Array.isArray(name)) for(j = 0, len = name.length; j < len; j++){
                item = name[j];
                lastChild = this.element(item);
            }
            else if (isFunction(name)) lastChild = this.element(name.apply());
            else if (isObject(name)) for(key in name){
                if (!hasProp.call(name, key)) continue;
                val = name[key];
                if (isFunction(val)) val = val.apply();
                if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) lastChild = this.dummy();
                else if (isObject(val) && isEmpty(val)) lastChild = this.element(key);
                else if (!this.options.keepNullNodes && val == null) lastChild = this.dummy();
                else if (!this.options.separateArrayItems && Array.isArray(val)) for(k = 0, len1 = val.length; k < len1; k++){
                    item = val[k];
                    childNode = {
                    };
                    childNode[key] = item;
                    lastChild = this.element(childNode);
                }
                else if (isObject(val)) {
                    if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) lastChild = this.element(val);
                    else {
                        lastChild = this.element(key);
                        lastChild.element(val);
                    }
                } else lastChild = this.element(key, val);
            }
            else if (!this.options.keepNullNodes && text === null) lastChild = this.dummy();
            else {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) lastChild = this.text(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) lastChild = this.cdata(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) lastChild = this.comment(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) lastChild = this.raw(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
                else lastChild = this.node(name, attributes, text);
            }
            if (lastChild == null) throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
            return lastChild;
        };
        XMLNode.prototype.insertBefore = function(name, attributes, text) {
            var child, i, newChild, refChild, removed;
            if (name != null ? name.type : void 0) {
                newChild = name;
                refChild = attributes;
                newChild.setParent(this);
                if (refChild) {
                    i = children.indexOf(refChild);
                    removed = children.splice(i);
                    children.push(newChild);
                    Array.prototype.push.apply(children, removed);
                } else children.push(newChild);
                return newChild;
            } else {
                if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                i = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i);
                child = this.parent.element(name, attributes, text);
                Array.prototype.push.apply(this.parent.children, removed);
                return child;
            }
        };
        XMLNode.prototype.insertAfter = function(name, attributes, text) {
            var child, i, removed;
            if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
        };
        XMLNode.prototype.remove = function() {
            var i, ref2;
            if (this.isRoot) throw new Error("Cannot remove the root element. " + this.debugInfo());
            i = this.parent.children.indexOf(this);
            [].splice.apply(this.parent.children, [
                i,
                i - i + 1
            ].concat(ref2 = []));
            return this.parent;
        };
        XMLNode.prototype.node = function(name, attributes, text) {
            var child, ref2;
            if (name != null) name = getValue(name);
            attributes || (attributes = {
            });
            attributes = getValue(attributes);
            if (!isObject(attributes)) ref2 = [
                attributes,
                text
            ], text = ref2[0], attributes = ref2[1];
            child = new XMLElement(this, name, attributes);
            if (text != null) child.text(text);
            this.children.push(child);
            return child;
        };
        XMLNode.prototype.text = function(value) {
            var child;
            if (isObject(value)) this.element(value);
            child = new XMLText(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.cdata = function(value) {
            var child;
            child = new XMLCData(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.comment = function(value) {
            var child;
            child = new XMLComment(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.commentBefore = function(value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.commentAfter = function(value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.raw = function(value) {
            var child;
            child = new XMLRaw(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.dummy = function() {
            var child;
            child = new XMLDummy(this);
            return child;
        };
        XMLNode.prototype.instruction = function(target, value) {
            var insTarget, insValue, instruction, j, len;
            if (target != null) target = getValue(target);
            if (value != null) value = getValue(value);
            if (Array.isArray(target)) for(j = 0, len = target.length; j < len; j++){
                insTarget = target[j];
                this.instruction(insTarget);
            }
            else if (isObject(target)) for(insTarget in target){
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                instruction = new XMLProcessingInstruction(this, target, value);
                this.children.push(instruction);
            }
            return this;
        };
        XMLNode.prototype.instructionBefore = function(target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.instructionAfter = function(target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.declaration = function(version, encoding, standalone) {
            var doc, xmldec;
            doc = this.document();
            xmldec = new XMLDeclaration(doc, version, encoding, standalone);
            if (doc.children.length === 0) doc.children.unshift(xmldec);
            else if (doc.children[0].type === NodeType.Declaration) doc.children[0] = xmldec;
            else doc.children.unshift(xmldec);
            return doc.root() || doc;
        };
        XMLNode.prototype.dtd = function(pubID, sysID) {
            var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
            doc = this.document();
            doctype = new XMLDocType(doc, pubID, sysID);
            ref2 = doc.children;
            for(i = j = 0, len = ref2.length; j < len; i = ++j){
                child = ref2[i];
                if (child.type === NodeType.DocType) {
                    doc.children[i] = doctype;
                    return doctype;
                }
            }
            ref3 = doc.children;
            for(i = k = 0, len1 = ref3.length; k < len1; i = ++k){
                child = ref3[i];
                if (child.isRoot) {
                    doc.children.splice(i, 0, doctype);
                    return doctype;
                }
            }
            doc.children.push(doctype);
            return doctype;
        };
        XMLNode.prototype.up = function() {
            if (this.isRoot) throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            return this.parent;
        };
        XMLNode.prototype.root = function() {
            var node;
            node = this;
            while(node){
                if (node.type === NodeType.Document) return node.rootObject;
                else if (node.isRoot) return node;
                else node = node.parent;
            }
        };
        XMLNode.prototype.document = function() {
            var node;
            node = this;
            while(node){
                if (node.type === NodeType.Document) return node;
                else node = node.parent;
            }
        };
        XMLNode.prototype.end = function(options) {
            return this.document().end(options);
        };
        XMLNode.prototype.prev = function() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i < 1) throw new Error("Already at the first node. " + this.debugInfo());
            return this.parent.children[i - 1];
        };
        XMLNode.prototype.next = function() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i === -1 || i === this.parent.children.length - 1) throw new Error("Already at the last node. " + this.debugInfo());
            return this.parent.children[i + 1];
        };
        XMLNode.prototype.importDocument = function(doc) {
            var clonedRoot;
            clonedRoot = doc.root().clone();
            clonedRoot.parent = this;
            clonedRoot.isRoot = false;
            this.children.push(clonedRoot);
            return this;
        };
        XMLNode.prototype.debugInfo = function(name) {
            var ref2, ref3;
            name = name || this.name;
            if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) return "";
            else if (name == null) return "parent: <" + this.parent.name + ">";
            else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) return "node: <" + name + ">";
            else return "node: <" + name + ">, parent: <" + this.parent.name + ">";
        };
        XMLNode.prototype.ele = function(name, attributes, text) {
            return this.element(name, attributes, text);
        };
        XMLNode.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLNode.prototype.txt = function(value) {
            return this.text(value);
        };
        XMLNode.prototype.dat = function(value) {
            return this.cdata(value);
        };
        XMLNode.prototype.com = function(value) {
            return this.comment(value);
        };
        XMLNode.prototype.ins = function(target, value) {
            return this.instruction(target, value);
        };
        XMLNode.prototype.doc = function() {
            return this.document();
        };
        XMLNode.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
        };
        XMLNode.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
        };
        XMLNode.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLNode.prototype.t = function(value) {
            return this.text(value);
        };
        XMLNode.prototype.d = function(value) {
            return this.cdata(value);
        };
        XMLNode.prototype.c = function(value) {
            return this.comment(value);
        };
        XMLNode.prototype.r = function(value) {
            return this.raw(value);
        };
        XMLNode.prototype.i = function(target, value) {
            return this.instruction(target, value);
        };
        XMLNode.prototype.u = function() {
            return this.up();
        };
        XMLNode.prototype.importXMLBuilder = function(doc) {
            return this.importDocument(doc);
        };
        XMLNode.prototype.replaceChild = function(newChild, oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.removeChild = function(oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.appendChild = function(newChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.hasChildNodes = function() {
            return this.children.length !== 0;
        };
        XMLNode.prototype.cloneNode = function(deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.normalize = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.isSupported = function(feature, version) {
            return true;
        };
        XMLNode.prototype.hasAttributes = function() {
            return this.attribs.length !== 0;
        };
        XMLNode.prototype.compareDocumentPosition = function(other) {
            var ref, res;
            ref = this;
            if (ref === other) return 0;
            else if (this.document() !== other.document()) {
                res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
                if (Math.random() < 0.5) res |= DocumentPosition.Preceding;
                else res |= DocumentPosition.Following;
                return res;
            } else if (ref.isAncestor(other)) return DocumentPosition.Contains | DocumentPosition.Preceding;
            else if (ref.isDescendant(other)) return DocumentPosition.Contains | DocumentPosition.Following;
            else if (ref.isPreceding(other)) return DocumentPosition.Preceding;
            else return DocumentPosition.Following;
        };
        XMLNode.prototype.isSameNode = function(other) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.lookupPrefix = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.lookupNamespaceURI = function(prefix) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.isEqualNode = function(node) {
            var i, j, ref2;
            if (node.nodeType !== this.nodeType) return false;
            if (node.children.length !== this.children.length) return false;
            for(i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j){
                if (!this.children[i].isEqualNode(node.children[i])) return false;
            }
            return true;
        };
        XMLNode.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.setUserData = function(key, data, handler) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.getUserData = function(key) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.contains = function(other) {
            if (!other) return false;
            return other === this || this.isDescendant(other);
        };
        XMLNode.prototype.isDescendant = function(node) {
            var child, isDescendantChild, j, len, ref2;
            ref2 = this.children;
            for(j = 0, len = ref2.length; j < len; j++){
                child = ref2[j];
                if (node === child) return true;
                isDescendantChild = child.isDescendant(node);
                if (isDescendantChild) return true;
            }
            return false;
        };
        XMLNode.prototype.isAncestor = function(node) {
            return node.isDescendant(this);
        };
        XMLNode.prototype.isPreceding = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) return false;
            else return nodePos < thisPos;
        };
        XMLNode.prototype.isFollowing = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) return false;
            else return nodePos > thisPos;
        };
        XMLNode.prototype.treePosition = function(node) {
            var found, pos;
            pos = 0;
            found = false;
            this.foreachTreeNode(this.document(), function(childNode) {
                pos++;
                if (!found && childNode === node) return found = true;
            });
            if (found) return pos;
            else return -1;
        };
        XMLNode.prototype.foreachTreeNode = function(node, func) {
            var child, j, len, ref2, res;
            node || (node = this.document());
            ref2 = node.children;
            for(j = 0, len = ref2.length; j < len; j++){
                child = ref2[j];
                if (res = func(child)) return res;
                else {
                    res = this.foreachTreeNode(child, func);
                    if (res) return res;
                }
            }
        };
        return XMLNode;
    })();
}).call(this);

},{"./Utility":"3gpwT","./XMLElement":"4FyHi","./XMLCData":"bJsP2","./XMLComment":"457jq","./XMLDeclaration":"jSij2","./XMLDocType":"cVmkM","./XMLRaw":"kQIkd","./XMLText":"bU2bi","./XMLProcessingInstruction":"caXGK","./XMLDummy":"hsJt1","./NodeType":"bHsfv","./XMLNodeList":"dWyE7","./XMLNamedNodeMap":"19z2B","./DocumentPosition":"aDJjD"}],"4FyHi":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLAttribute, XMLElement1, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    XMLAttribute = require('./XMLAttribute');
    XMLNamedNodeMap = require('./XMLNamedNodeMap');
    module.exports = XMLElement1 = (function(superClass) {
        extend(XMLElement, superClass);
        function XMLElement(parent, name, attributes) {
            var child, j, len, ref1;
            XMLElement.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing element name. " + this.debugInfo());
            this.name = this.stringify.name(name);
            this.type = NodeType.Element;
            this.attribs = {
            };
            this.schemaTypeInfo = null;
            if (attributes != null) this.attribute(attributes);
            if (parent.type === NodeType.Document) {
                this.isRoot = true;
                this.documentObject = parent;
                parent.rootObject = this;
                if (parent.children) {
                    ref1 = parent.children;
                    for(j = 0, len = ref1.length; j < len; j++){
                        child = ref1[j];
                        if (child.type === NodeType.DocType) {
                            child.name = this.name;
                            break;
                        }
                    }
                }
            }
        }
        Object.defineProperty(XMLElement.prototype, 'tagName', {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLElement.prototype, 'namespaceURI', {
            get: function() {
                return '';
            }
        });
        Object.defineProperty(XMLElement.prototype, 'prefix', {
            get: function() {
                return '';
            }
        });
        Object.defineProperty(XMLElement.prototype, 'localName', {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLElement.prototype, 'id', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLElement.prototype, 'className', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLElement.prototype, 'classList', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLElement.prototype, 'attributes', {
            get: function() {
                if (!this.attributeMap || !this.attributeMap.nodes) this.attributeMap = new XMLNamedNodeMap(this.attribs);
                return this.attributeMap;
            }
        });
        XMLElement.prototype.clone = function() {
            var att, attName, clonedSelf, ref1;
            clonedSelf = Object.create(this);
            if (clonedSelf.isRoot) clonedSelf.documentObject = null;
            clonedSelf.attribs = {
            };
            ref1 = this.attribs;
            for(attName in ref1){
                if (!hasProp.call(ref1, attName)) continue;
                att = ref1[attName];
                clonedSelf.attribs[attName] = att.clone();
            }
            clonedSelf.children = [];
            this.children.forEach(function(child) {
                var clonedChild;
                clonedChild = child.clone();
                clonedChild.parent = clonedSelf;
                return clonedSelf.children.push(clonedChild);
            });
            return clonedSelf;
        };
        XMLElement.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (name != null) name = getValue(name);
            if (isObject(name)) for(attName in name){
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                if (this.options.keepNullAttributes && value == null) this.attribs[name] = new XMLAttribute(this, name, "");
                else if (value != null) this.attribs[name] = new XMLAttribute(this, name, value);
            }
            return this;
        };
        XMLElement.prototype.removeAttribute = function(name) {
            var attName, j, len;
            if (name == null) throw new Error("Missing attribute name. " + this.debugInfo());
            name = getValue(name);
            if (Array.isArray(name)) for(j = 0, len = name.length; j < len; j++){
                attName = name[j];
                delete this.attribs[attName];
            }
            else delete this.attribs[name];
            return this;
        };
        XMLElement.prototype.toString = function(options) {
            return this.options.writer.element(this, this.options.writer.filterOptions(options));
        };
        XMLElement.prototype.att = function(name, value) {
            return this.attribute(name, value);
        };
        XMLElement.prototype.a = function(name, value) {
            return this.attribute(name, value);
        };
        XMLElement.prototype.getAttribute = function(name) {
            if (this.attribs.hasOwnProperty(name)) return this.attribs[name].value;
            else return null;
        };
        XMLElement.prototype.setAttribute = function(name, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getAttributeNode = function(name) {
            if (this.attribs.hasOwnProperty(name)) return this.attribs[name];
            else return null;
        };
        XMLElement.prototype.setAttributeNode = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.removeAttributeNode = function(oldAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagName = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.hasAttribute = function(name) {
            return this.attribs.hasOwnProperty(name);
        };
        XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setIdAttribute = function(name, isId) {
            if (this.attribs.hasOwnProperty(name)) return this.attribs[name].isId;
            else return isId;
        };
        XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.isEqualNode = function(node) {
            var i, j, ref1;
            if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.namespaceURI !== this.namespaceURI) return false;
            if (node.prefix !== this.prefix) return false;
            if (node.localName !== this.localName) return false;
            if (node.attribs.length !== this.attribs.length) return false;
            for(i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j){
                if (!this.attribs[i].isEqualNode(node.attribs[i])) return false;
            }
            return true;
        };
        return XMLElement;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLNode":"9Mxux","./NodeType":"bHsfv","./XMLAttribute":"4geFW","./XMLNamedNodeMap":"19z2B"}],"bHsfv":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    module.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
    };
}).call(this);

},{}],"4geFW":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLAttribute1, XMLNode;
    NodeType = require('./NodeType');
    XMLNode = require('./XMLNode');
    module.exports = XMLAttribute1 = (function() {
        function XMLAttribute(parent, name, value) {
            this.parent = parent;
            if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
            }
            if (name == null) throw new Error("Missing attribute name. " + this.debugInfo(name));
            this.name = this.stringify.name(name);
            this.value = this.stringify.attValue(value);
            this.type = NodeType.Attribute;
            this.isId = false;
            this.schemaTypeInfo = null;
        }
        Object.defineProperty(XMLAttribute.prototype, 'nodeType', {
            get: function() {
                return this.type;
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {
            get: function() {
                return this.parent;
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'textContent', {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || '';
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {
            get: function() {
                return '';
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'prefix', {
            get: function() {
                return '';
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'localName', {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'specified', {
            get: function() {
                return true;
            }
        });
        XMLAttribute.prototype.clone = function() {
            return Object.create(this);
        };
        XMLAttribute.prototype.toString = function(options) {
            return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        };
        XMLAttribute.prototype.debugInfo = function(name) {
            name = name || this.name;
            if (name == null) return "parent: <" + this.parent.name + ">";
            else return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        };
        XMLAttribute.prototype.isEqualNode = function(node) {
            if (node.namespaceURI !== this.namespaceURI) return false;
            if (node.prefix !== this.prefix) return false;
            if (node.localName !== this.localName) return false;
            if (node.value !== this.value) return false;
            return true;
        };
        return XMLAttribute;
    })();
}).call(this);

},{"./NodeType":"bHsfv","./XMLNode":"9Mxux"}],"19z2B":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLNamedNodeMap1;
    module.exports = XMLNamedNodeMap1 = (function() {
        function XMLNamedNodeMap(nodes) {
            this.nodes = nodes;
        }
        Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {
            get: function() {
                return Object.keys(this.nodes).length || 0;
            }
        });
        XMLNamedNodeMap.prototype.clone = function() {
            return this.nodes = null;
        };
        XMLNamedNodeMap.prototype.getNamedItem = function(name) {
            return this.nodes[name];
        };
        XMLNamedNodeMap.prototype.setNamedItem = function(node) {
            var oldNode;
            oldNode = this.nodes[node.nodeName];
            this.nodes[node.nodeName] = node;
            return oldNode || null;
        };
        XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
            var oldNode;
            oldNode = this.nodes[name];
            delete this.nodes[name];
            return oldNode || null;
        };
        XMLNamedNodeMap.prototype.item = function(index) {
            return this.nodes[Object.keys(this.nodes)[index]] || null;
        };
        XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
        };
        return XMLNamedNodeMap;
    })();
}).call(this);

},{}],"bJsP2":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCData1, XMLCharacterData, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLCharacterData = require('./XMLCharacterData');
    module.exports = XMLCData1 = (function(superClass) {
        extend(XMLCData, superClass);
        function XMLCData(parent, text) {
            XMLCData.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing CDATA text. " + this.debugInfo());
            this.name = "#cdata-section";
            this.type = NodeType.CData;
            this.value = this.stringify.cdata(text);
        }
        XMLCData.prototype.clone = function() {
            return Object.create(this);
        };
        XMLCData.prototype.toString = function(options) {
            return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        };
        return XMLCData;
    })(XMLCharacterData);
}).call(this);

},{"./NodeType":"bHsfv","./XMLCharacterData":"iKivp"}],"iKivp":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLCharacterData1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    module.exports = XMLCharacterData1 = (function(superClass) {
        extend(XMLCharacterData, superClass);
        function XMLCharacterData(parent) {
            XMLCharacterData.__super__.constructor.call(this, parent);
            this.value = '';
        }
        Object.defineProperty(XMLCharacterData.prototype, 'data', {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || '';
            }
        });
        Object.defineProperty(XMLCharacterData.prototype, 'length', {
            get: function() {
                return this.value.length;
            }
        });
        Object.defineProperty(XMLCharacterData.prototype, 'textContent', {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || '';
            }
        });
        XMLCharacterData.prototype.clone = function() {
            return Object.create(this);
        };
        XMLCharacterData.prototype.substringData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.appendData = function(arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.insertData = function(offset, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.deleteData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.replaceData = function(offset, count, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.isEqualNode = function(node) {
            if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.data !== this.data) return false;
            return true;
        };
        return XMLCharacterData;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux"}],"457jq":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCharacterData, XMLComment1, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLCharacterData = require('./XMLCharacterData');
    module.exports = XMLComment1 = (function(superClass) {
        extend(XMLComment, superClass);
        function XMLComment(parent, text) {
            XMLComment.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing comment text. " + this.debugInfo());
            this.name = "#comment";
            this.type = NodeType.Comment;
            this.value = this.stringify.comment(text);
        }
        XMLComment.prototype.clone = function() {
            return Object.create(this);
        };
        XMLComment.prototype.toString = function(options) {
            return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        };
        return XMLComment;
    })(XMLCharacterData);
}).call(this);

},{"./NodeType":"bHsfv","./XMLCharacterData":"iKivp"}],"jSij2":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDeclaration1, XMLNode, isObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    isObject = require('./Utility').isObject;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDeclaration1 = (function(superClass) {
        extend(XMLDeclaration, superClass);
        function XMLDeclaration(parent, version, encoding, standalone) {
            var ref;
            XMLDeclaration.__super__.constructor.call(this, parent);
            if (isObject(version)) ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
            if (!version) version = '1.0';
            this.type = NodeType.Declaration;
            this.version = this.stringify.xmlVersion(version);
            if (encoding != null) this.encoding = this.stringify.xmlEncoding(encoding);
            if (standalone != null) this.standalone = this.stringify.xmlStandalone(standalone);
        }
        XMLDeclaration.prototype.toString = function(options) {
            return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        };
        return XMLDeclaration;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"cVmkM":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType1, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    isObject = require('./Utility').isObject;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    XMLDTDAttList = require('./XMLDTDAttList');
    XMLDTDEntity = require('./XMLDTDEntity');
    XMLDTDElement = require('./XMLDTDElement');
    XMLDTDNotation = require('./XMLDTDNotation');
    XMLNamedNodeMap = require('./XMLNamedNodeMap');
    module.exports = XMLDocType1 = (function(superClass) {
        extend(XMLDocType, superClass);
        function XMLDocType(parent, pubID, sysID) {
            var child, i, len, ref, ref1, ref2;
            XMLDocType.__super__.constructor.call(this, parent);
            this.type = NodeType.DocType;
            if (parent.children) {
                ref = parent.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.Element) {
                        this.name = child.name;
                        break;
                    }
                }
            }
            this.documentObject = parent;
            if (isObject(pubID)) ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
            if (sysID == null) ref2 = [
                pubID,
                sysID
            ], sysID = ref2[0], pubID = ref2[1];
            if (pubID != null) this.pubID = this.stringify.dtdPubID(pubID);
            if (sysID != null) this.sysID = this.stringify.dtdSysID(sysID);
        }
        Object.defineProperty(XMLDocType.prototype, 'entities', {
            get: function() {
                var child, i, len, nodes, ref;
                nodes = {
                };
                ref = this.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.EntityDeclaration && !child.pe) nodes[child.name] = child;
                }
                return new XMLNamedNodeMap(nodes);
            }
        });
        Object.defineProperty(XMLDocType.prototype, 'notations', {
            get: function() {
                var child, i, len, nodes, ref;
                nodes = {
                };
                ref = this.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.NotationDeclaration) nodes[child.name] = child;
                }
                return new XMLNamedNodeMap(nodes);
            }
        });
        Object.defineProperty(XMLDocType.prototype, 'publicId', {
            get: function() {
                return this.pubID;
            }
        });
        Object.defineProperty(XMLDocType.prototype, 'systemId', {
            get: function() {
                return this.sysID;
            }
        });
        Object.defineProperty(XMLDocType.prototype, 'internalSubset', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        XMLDocType.prototype.element = function(name, value) {
            var child;
            child = new XMLDTDElement(this, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var child;
            child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.entity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, false, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.pEntity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, true, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.notation = function(name, value) {
            var child;
            child = new XMLDTDNotation(this, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.toString = function(options) {
            return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        };
        XMLDocType.prototype.ele = function(name, value) {
            return this.element(name, value);
        };
        XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType.prototype.ent = function(name, value) {
            return this.entity(name, value);
        };
        XMLDocType.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
        };
        XMLDocType.prototype.not = function(name, value) {
            return this.notation(name, value);
        };
        XMLDocType.prototype.up = function() {
            return this.root() || this.documentObject;
        };
        XMLDocType.prototype.isEqualNode = function(node) {
            if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.name !== this.name) return false;
            if (node.publicId !== this.publicId) return false;
            if (node.systemId !== this.systemId) return false;
            return true;
        };
        return XMLDocType;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLNode":"9Mxux","./NodeType":"bHsfv","./XMLDTDAttList":"388gh","./XMLDTDEntity":"3zIKf","./XMLDTDElement":"dW7eI","./XMLDTDNotation":"gZJiZ","./XMLNamedNodeMap":"19z2B"}],"388gh":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDAttList1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDTDAttList1 = (function(superClass) {
        extend(XMLDTDAttList, superClass);
        function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            XMLDTDAttList.__super__.constructor.call(this, parent);
            if (elementName == null) throw new Error("Missing DTD element name. " + this.debugInfo());
            if (attributeName == null) throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
            if (!attributeType) throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
            if (!defaultValueType) throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
            if (defaultValueType.indexOf('#') !== 0) defaultValueType = '#' + defaultValueType;
            if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            this.elementName = this.stringify.name(elementName);
            this.type = NodeType.AttributeDeclaration;
            this.attributeName = this.stringify.name(attributeName);
            this.attributeType = this.stringify.dtdAttType(attributeType);
            if (defaultValue) this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
            this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList.prototype.toString = function(options) {
            return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDAttList;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"3zIKf":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDEntity1, XMLNode, isObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    isObject = require('./Utility').isObject;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDTDEntity1 = (function(superClass) {
        extend(XMLDTDEntity, superClass);
        function XMLDTDEntity(parent, pe, name, value) {
            XMLDTDEntity.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing DTD entity name. " + this.debugInfo(name));
            if (value == null) throw new Error("Missing DTD entity value. " + this.debugInfo(name));
            this.pe = !!pe;
            this.name = this.stringify.name(name);
            this.type = NodeType.EntityDeclaration;
            if (!isObject(value)) {
                this.value = this.stringify.dtdEntityValue(value);
                this.internal = true;
            } else {
                if (!value.pubID && !value.sysID) throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
                if (value.pubID && !value.sysID) throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
                this.internal = false;
                if (value.pubID != null) this.pubID = this.stringify.dtdPubID(value.pubID);
                if (value.sysID != null) this.sysID = this.stringify.dtdSysID(value.sysID);
                if (value.nData != null) this.nData = this.stringify.dtdNData(value.nData);
                if (this.pe && this.nData) throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            }
        }
        Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {
            get: function() {
                return this.pubID;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {
            get: function() {
                return this.sysID;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {
            get: function() {
                return this.nData || null;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {
            get: function() {
                return null;
            }
        });
        XMLDTDEntity.prototype.toString = function(options) {
            return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDEntity;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"dW7eI":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDElement1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDTDElement1 = (function(superClass) {
        extend(XMLDTDElement, superClass);
        function XMLDTDElement(parent, name, value) {
            XMLDTDElement.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing DTD element name. " + this.debugInfo());
            if (!value) value = '(#PCDATA)';
            if (Array.isArray(value)) value = '(' + value.join(',') + ')';
            this.name = this.stringify.name(name);
            this.type = NodeType.ElementDeclaration;
            this.value = this.stringify.dtdElementValue(value);
        }
        XMLDTDElement.prototype.toString = function(options) {
            return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDElement;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"gZJiZ":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDNotation1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDTDNotation1 = (function(superClass) {
        extend(XMLDTDNotation, superClass);
        function XMLDTDNotation(parent, name, value) {
            XMLDTDNotation.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing DTD notation name. " + this.debugInfo(name));
            if (!value.pubID && !value.sysID) throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
            this.name = this.stringify.name(name);
            this.type = NodeType.NotationDeclaration;
            if (value.pubID != null) this.pubID = this.stringify.dtdPubID(value.pubID);
            if (value.sysID != null) this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {
            get: function() {
                return this.pubID;
            }
        });
        Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {
            get: function() {
                return this.sysID;
            }
        });
        XMLDTDNotation.prototype.toString = function(options) {
            return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDNotation;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"kQIkd":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLNode, XMLRaw1, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLNode = require('./XMLNode');
    module.exports = XMLRaw1 = (function(superClass) {
        extend(XMLRaw, superClass);
        function XMLRaw(parent, text) {
            XMLRaw.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing raw text. " + this.debugInfo());
            this.type = NodeType.Raw;
            this.value = this.stringify.raw(text);
        }
        XMLRaw.prototype.clone = function() {
            return Object.create(this);
        };
        XMLRaw.prototype.toString = function(options) {
            return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        };
        return XMLRaw;
    })(XMLNode);
}).call(this);

},{"./NodeType":"bHsfv","./XMLNode":"9Mxux"}],"bU2bi":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCharacterData, XMLText1, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLCharacterData = require('./XMLCharacterData');
    module.exports = XMLText1 = (function(superClass) {
        extend(XMLText, superClass);
        function XMLText(parent, text) {
            XMLText.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing element text. " + this.debugInfo());
            this.name = "#text";
            this.type = NodeType.Text;
            this.value = this.stringify.text(text);
        }
        Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLText.prototype, 'wholeText', {
            get: function() {
                var next, prev, str;
                str = '';
                prev = this.previousSibling;
                while(prev){
                    str = prev.data + str;
                    prev = prev.previousSibling;
                }
                str += this.data;
                next = this.nextSibling;
                while(next){
                    str = str + next.data;
                    next = next.nextSibling;
                }
                return str;
            }
        });
        XMLText.prototype.clone = function() {
            return Object.create(this);
        };
        XMLText.prototype.toString = function(options) {
            return this.options.writer.text(this, this.options.writer.filterOptions(options));
        };
        XMLText.prototype.splitText = function(offset) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLText.prototype.replaceWholeText = function(content) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLText;
    })(XMLCharacterData);
}).call(this);

},{"./NodeType":"bHsfv","./XMLCharacterData":"iKivp"}],"caXGK":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCharacterData, XMLProcessingInstruction1, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLCharacterData = require('./XMLCharacterData');
    module.exports = XMLProcessingInstruction1 = (function(superClass) {
        extend(XMLProcessingInstruction, superClass);
        function XMLProcessingInstruction(parent, target, value) {
            XMLProcessingInstruction.__super__.constructor.call(this, parent);
            if (target == null) throw new Error("Missing instruction target. " + this.debugInfo());
            this.type = NodeType.ProcessingInstruction;
            this.target = this.stringify.insTarget(target);
            this.name = this.target;
            if (value) this.value = this.stringify.insValue(value);
        }
        XMLProcessingInstruction.prototype.clone = function() {
            return Object.create(this);
        };
        XMLProcessingInstruction.prototype.toString = function(options) {
            return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        };
        XMLProcessingInstruction.prototype.isEqualNode = function(node) {
            if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.target !== this.target) return false;
            return true;
        };
        return XMLProcessingInstruction;
    })(XMLCharacterData);
}).call(this);

},{"./NodeType":"bHsfv","./XMLCharacterData":"iKivp"}],"hsJt1":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDummy1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDummy1 = (function(superClass) {
        extend(XMLDummy, superClass);
        function XMLDummy(parent) {
            XMLDummy.__super__.constructor.call(this, parent);
            this.type = NodeType.Dummy;
        }
        XMLDummy.prototype.clone = function() {
            return Object.create(this);
        };
        XMLDummy.prototype.toString = function(options) {
            return '';
        };
        return XMLDummy;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"dWyE7":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLNodeList1;
    module.exports = XMLNodeList1 = (function() {
        function XMLNodeList(nodes) {
            this.nodes = nodes;
        }
        Object.defineProperty(XMLNodeList.prototype, 'length', {
            get: function() {
                return this.nodes.length || 0;
            }
        });
        XMLNodeList.prototype.clone = function() {
            return this.nodes = null;
        };
        XMLNodeList.prototype.item = function(index) {
            return this.nodes[index] || null;
        };
        return XMLNodeList;
    })();
}).call(this);

},{}],"aDJjD":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    module.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
    };
}).call(this);

},{}],"i909L":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLStringifier1, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, hasProp = {
    }.hasOwnProperty;
    module.exports = XMLStringifier1 = (function() {
        function XMLStringifier(options) {
            this.assertLegalName = bind(this.assertLegalName, this);
            this.assertLegalChar = bind(this.assertLegalChar, this);
            var key, ref, value;
            options || (options = {
            });
            this.options = options;
            if (!this.options.version) this.options.version = '1.0';
            ref = options.stringify || {
            };
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this[key] = value;
            }
        }
        XMLStringifier.prototype.name = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalName('' + val || '');
        };
        XMLStringifier.prototype.text = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar(this.textEscape('' + val || ''));
        };
        XMLStringifier.prototype.cdata = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            val = val.replace(']]>', ']]]]><![CDATA[>');
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.comment = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            if (val.match(/--/)) throw new Error("Comment text cannot contain double-hypen: " + val);
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.raw = function(val) {
            if (this.options.noValidation) return val;
            return '' + val || '';
        };
        XMLStringifier.prototype.attValue = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar(this.attEscape(val = '' + val || ''));
        };
        XMLStringifier.prototype.insTarget = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.insValue = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            if (val.match(/\?>/)) throw new Error("Invalid processing instruction value: " + val);
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.xmlVersion = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            if (!val.match(/1\.[0-9]+/)) throw new Error("Invalid version number: " + val);
            return val;
        };
        XMLStringifier.prototype.xmlEncoding = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) throw new Error("Invalid encoding: " + val);
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.xmlStandalone = function(val) {
            if (this.options.noValidation) return val;
            if (val) return "yes";
            else return "no";
        };
        XMLStringifier.prototype.dtdPubID = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdSysID = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdElementValue = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdAttType = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdAttDefault = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdEntityValue = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdNData = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.convertAttKey = '@';
        XMLStringifier.prototype.convertPIKey = '?';
        XMLStringifier.prototype.convertTextKey = '#text';
        XMLStringifier.prototype.convertCDataKey = '#cdata';
        XMLStringifier.prototype.convertCommentKey = '#comment';
        XMLStringifier.prototype.convertRawKey = '#raw';
        XMLStringifier.prototype.assertLegalChar = function(str) {
            var regex, res;
            if (this.options.noValidation) return str;
            regex = '';
            if (this.options.version === '1.0') {
                regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
            } else if (this.options.version === '1.1') {
                regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
            return str;
        };
        XMLStringifier.prototype.assertLegalName = function(str) {
            var regex;
            if (this.options.noValidation) return str;
            this.assertLegalChar(str);
            regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
            if (!str.match(regex)) throw new Error("Invalid character in name");
            return str;
        };
        XMLStringifier.prototype.textEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) return str;
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
        };
        XMLStringifier.prototype.attEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) return str;
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
        };
        return XMLStringifier;
    })();
}).call(this);

},{}],"WCwh2":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLStringWriter1, XMLWriterBase, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLWriterBase = require('./XMLWriterBase');
    module.exports = XMLStringWriter1 = (function(superClass) {
        extend(XMLStringWriter, superClass);
        function XMLStringWriter(options) {
            XMLStringWriter.__super__.constructor.call(this, options);
        }
        XMLStringWriter.prototype.document = function(doc, options) {
            var child, i, len, r, ref;
            options = this.filterOptions(options);
            r = '';
            ref = doc.children;
            for(i = 0, len = ref.length; i < len; i++){
                child = ref[i];
                r += this.writeChildNode(child, options, 0);
            }
            if (options.pretty && r.slice(-options.newline.length) === options.newline) r = r.slice(0, -options.newline.length);
            return r;
        };
        return XMLStringWriter;
    })(XMLWriterBase);
}).call(this);

},{"./XMLWriterBase":"epzCv"}],"epzCv":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase1, assign, hasProp = {
    }.hasOwnProperty;
    assign = require('./Utility').assign;
    NodeType = require('./NodeType');
    XMLDeclaration = require('./XMLDeclaration');
    XMLDocType = require('./XMLDocType');
    XMLCData = require('./XMLCData');
    XMLComment = require('./XMLComment');
    XMLElement = require('./XMLElement');
    XMLRaw = require('./XMLRaw');
    XMLText = require('./XMLText');
    XMLProcessingInstruction = require('./XMLProcessingInstruction');
    XMLDummy = require('./XMLDummy');
    XMLDTDAttList = require('./XMLDTDAttList');
    XMLDTDElement = require('./XMLDTDElement');
    XMLDTDEntity = require('./XMLDTDEntity');
    XMLDTDNotation = require('./XMLDTDNotation');
    WriterState = require('./WriterState');
    module.exports = XMLWriterBase1 = (function() {
        function XMLWriterBase(options) {
            var key, ref, value;
            options || (options = {
            });
            this.options = options;
            ref = options.writer || {
            };
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this["_" + key] = this[key];
                this[key] = value;
            }
        }
        XMLWriterBase.prototype.filterOptions = function(options) {
            var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
            options || (options = {
            });
            options = assign({
            }, this.options, options);
            filteredOptions = {
                writer: this
            };
            filteredOptions.pretty = options.pretty || false;
            filteredOptions.allowEmpty = options.allowEmpty || false;
            filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
            filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\n';
            filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
            filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
            filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';
            if (filteredOptions.spaceBeforeSlash === true) filteredOptions.spaceBeforeSlash = ' ';
            filteredOptions.suppressPrettyCount = 0;
            filteredOptions.user = {
            };
            filteredOptions.state = WriterState.None;
            return filteredOptions;
        };
        XMLWriterBase.prototype.indent = function(node, options, level) {
            var indentLevel;
            if (!options.pretty || options.suppressPrettyCount) return '';
            else if (options.pretty) {
                indentLevel = (level || 0) + options.offset + 1;
                if (indentLevel > 0) return new Array(indentLevel).join(options.indent);
            }
            return '';
        };
        XMLWriterBase.prototype.endline = function(node, options, level) {
            if (!options.pretty || options.suppressPrettyCount) return '';
            else return options.newline;
        };
        XMLWriterBase.prototype.attribute = function(att, options, level) {
            var r;
            this.openAttribute(att, options, level);
            r = ' ' + att.name + '="' + att.value + '"';
            this.closeAttribute(att, options, level);
            return r;
        };
        XMLWriterBase.prototype.cdata = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<![CDATA[';
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += ']]>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.comment = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<\!-- ';
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += ' -->' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.declaration = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<?xml';
            options.state = WriterState.InsideTag;
            r += ' version="' + node.version + '"';
            if (node.encoding != null) r += ' encoding="' + node.encoding + '"';
            if (node.standalone != null) r += ' standalone="' + node.standalone + '"';
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '?>';
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.docType = function(node, options, level) {
            var child, i, len, r, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            r += '<!DOCTYPE ' + node.root().name;
            if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
            if (node.children.length > 0) {
                r += ' [';
                r += this.endline(node, options, level);
                options.state = WriterState.InsideTag;
                ref = node.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    r += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r += ']';
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>';
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
            level || (level = 0);
            prettySuppressed = false;
            r = '';
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r += this.indent(node, options, level) + '<' + node.name;
            ref = node.attribs;
            for(name in ref){
                if (!hasProp.call(ref, name)) continue;
                att = ref[name];
                r += this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e) {
                return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
            })) {
                if (options.allowEmpty) {
                    r += '>';
                    options.state = WriterState.CloseTag;
                    r += '</' + node.name + '>' + this.endline(node, options, level);
                } else {
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
                }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                r += '>';
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                prettySuppressed = true;
                r += this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                prettySuppressed = false;
                options.state = WriterState.CloseTag;
                r += '</' + node.name + '>' + this.endline(node, options, level);
            } else {
                if (options.dontPrettyTextNodes) {
                    ref1 = node.children;
                    for(i = 0, len = ref1.length; i < len; i++){
                        child = ref1[i];
                        if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                            options.suppressPrettyCount++;
                            prettySuppressed = true;
                            break;
                        }
                    }
                }
                r += '>' + this.endline(node, options, level);
                options.state = WriterState.InsideTag;
                ref2 = node.children;
                for(j = 0, len1 = ref2.length; j < len1; j++){
                    child = ref2[j];
                    r += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r += this.indent(node, options, level) + '</' + node.name + '>';
                if (prettySuppressed) options.suppressPrettyCount--;
                r += this.endline(node, options, level);
                options.state = WriterState.None;
            }
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
            switch(node.type){
                case NodeType.CData:
                    return this.cdata(node, options, level);
                case NodeType.Comment:
                    return this.comment(node, options, level);
                case NodeType.Element:
                    return this.element(node, options, level);
                case NodeType.Raw:
                    return this.raw(node, options, level);
                case NodeType.Text:
                    return this.text(node, options, level);
                case NodeType.ProcessingInstruction:
                    return this.processingInstruction(node, options, level);
                case NodeType.Dummy:
                    return '';
                case NodeType.Declaration:
                    return this.declaration(node, options, level);
                case NodeType.DocType:
                    return this.docType(node, options, level);
                case NodeType.AttributeDeclaration:
                    return this.dtdAttList(node, options, level);
                case NodeType.ElementDeclaration:
                    return this.dtdElement(node, options, level);
                case NodeType.EntityDeclaration:
                    return this.dtdEntity(node, options, level);
                case NodeType.NotationDeclaration:
                    return this.dtdNotation(node, options, level);
                default:
                    throw new Error("Unknown XML node type: " + node.constructor.name);
            }
        };
        XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<?';
            options.state = WriterState.InsideTag;
            r += node.target;
            if (node.value) r += ' ' + node.value;
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '?>';
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.raw = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.text = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<!ATTLIST';
            options.state = WriterState.InsideTag;
            r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
            if (node.defaultValueType !== '#DEFAULT') r += ' ' + node.defaultValueType;
            if (node.defaultValue) r += ' "' + node.defaultValue + '"';
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdElement = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<!ELEMENT';
            options.state = WriterState.InsideTag;
            r += ' ' + node.name + ' ' + node.value;
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<!ENTITY';
            options.state = WriterState.InsideTag;
            if (node.pe) r += ' %';
            r += ' ' + node.name;
            if (node.value) r += ' "' + node.value + '"';
            else {
                if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
                if (node.nData) r += ' NDATA ' + node.nData;
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<!NOTATION';
            options.state = WriterState.InsideTag;
            r += ' ' + node.name;
            if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            else if (node.pubID) r += ' PUBLIC "' + node.pubID + '"';
            else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.openNode = function(node, options, level) {
        };
        XMLWriterBase.prototype.closeNode = function(node, options, level) {
        };
        XMLWriterBase.prototype.openAttribute = function(att, options, level) {
        };
        XMLWriterBase.prototype.closeAttribute = function(att, options, level) {
        };
        return XMLWriterBase;
    })();
}).call(this);

},{"./Utility":"3gpwT","./NodeType":"bHsfv","./XMLDeclaration":"jSij2","./XMLDocType":"cVmkM","./XMLCData":"bJsP2","./XMLComment":"457jq","./XMLElement":"4FyHi","./XMLRaw":"kQIkd","./XMLText":"bU2bi","./XMLProcessingInstruction":"caXGK","./XMLDummy":"hsJt1","./XMLDTDAttList":"388gh","./XMLDTDElement":"dW7eI","./XMLDTDEntity":"3zIKf","./XMLDTDNotation":"gZJiZ","./WriterState":"psDCU"}],"psDCU":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    module.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
    };
}).call(this);

},{}],"aJkVd":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB1, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {
    }.hasOwnProperty;
    ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
    NodeType = require('./NodeType');
    XMLDocument = require('./XMLDocument');
    XMLElement = require('./XMLElement');
    XMLCData = require('./XMLCData');
    XMLComment = require('./XMLComment');
    XMLRaw = require('./XMLRaw');
    XMLText = require('./XMLText');
    XMLProcessingInstruction = require('./XMLProcessingInstruction');
    XMLDeclaration = require('./XMLDeclaration');
    XMLDocType = require('./XMLDocType');
    XMLDTDAttList = require('./XMLDTDAttList');
    XMLDTDEntity = require('./XMLDTDEntity');
    XMLDTDElement = require('./XMLDTDElement');
    XMLDTDNotation = require('./XMLDTDNotation');
    XMLAttribute = require('./XMLAttribute');
    XMLStringifier = require('./XMLStringifier');
    XMLStringWriter = require('./XMLStringWriter');
    WriterState = require('./WriterState');
    module.exports = XMLDocumentCB1 = (function() {
        function XMLDocumentCB(options, onData, onEnd) {
            var writerOptions;
            this.name = "?xml";
            this.type = NodeType.Document;
            options || (options = {
            });
            writerOptions = {
            };
            if (!options.writer) options.writer = new XMLStringWriter();
            else if (isPlainObject(options.writer)) {
                writerOptions = options.writer;
                options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.writer = options.writer;
            this.writerOptions = this.writer.filterOptions(writerOptions);
            this.stringify = new XMLStringifier(options);
            this.onDataCallback = onData || function() {
            };
            this.onEndCallback = onEnd || function() {
            };
            this.currentNode = null;
            this.currentLevel = -1;
            this.openTags = {
            };
            this.documentStarted = false;
            this.documentCompleted = false;
            this.root = null;
        }
        XMLDocumentCB.prototype.createChildNode = function(node) {
            var att, attName, attributes, child, i, len, ref1, ref2;
            switch(node.type){
                case NodeType.CData:
                    this.cdata(node.value);
                    break;
                case NodeType.Comment:
                    this.comment(node.value);
                    break;
                case NodeType.Element:
                    attributes = {
                    };
                    ref1 = node.attribs;
                    for(attName in ref1){
                        if (!hasProp.call(ref1, attName)) continue;
                        att = ref1[attName];
                        attributes[attName] = att.value;
                    }
                    this.node(node.name, attributes);
                    break;
                case NodeType.Dummy:
                    this.dummy();
                    break;
                case NodeType.Raw:
                    this.raw(node.value);
                    break;
                case NodeType.Text:
                    this.text(node.value);
                    break;
                case NodeType.ProcessingInstruction:
                    this.instruction(node.target, node.value);
                    break;
                default:
                    throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
            }
            ref2 = node.children;
            for(i = 0, len = ref2.length; i < len; i++){
                child = ref2[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) this.up();
            }
            return this;
        };
        XMLDocumentCB.prototype.dummy = function() {
            return this;
        };
        XMLDocumentCB.prototype.node = function(name, attributes, text) {
            var ref1;
            if (name == null) throw new Error("Missing node name.");
            if (this.root && this.currentLevel === -1) throw new Error("Document can only have one root node. " + this.debugInfo(name));
            this.openCurrent();
            name = getValue(name);
            if (attributes == null) attributes = {
            };
            attributes = getValue(attributes);
            if (!isObject(attributes)) ref1 = [
                attributes,
                text
            ], text = ref1[0], attributes = ref1[1];
            this.currentNode = new XMLElement(this, name, attributes);
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            if (text != null) this.text(text);
            return this;
        };
        XMLDocumentCB.prototype.element = function(name, attributes, text) {
            var child, i, len, oldValidationFlag, ref1, root;
            if (this.currentNode && this.currentNode.type === NodeType.DocType) this.dtdElement.apply(this, arguments);
            else if (Array.isArray(name) || isObject(name) || isFunction(name)) {
                oldValidationFlag = this.options.noValidation;
                this.options.noValidation = true;
                root = new XMLDocument(this.options).element('TEMP_ROOT');
                root.element(name);
                this.options.noValidation = oldValidationFlag;
                ref1 = root.children;
                for(i = 0, len = ref1.length; i < len; i++){
                    child = ref1[i];
                    this.createChildNode(child);
                    if (child.type === NodeType.Element) this.up();
                }
            } else this.node(name, attributes, text);
            return this;
        };
        XMLDocumentCB.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (!this.currentNode || this.currentNode.children) throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
            if (name != null) name = getValue(name);
            if (isObject(name)) for(attName in name){
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                if (this.options.keepNullAttributes && value == null) this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
                else if (value != null) this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
            }
            return this;
        };
        XMLDocumentCB.prototype.text = function(value) {
            var node;
            this.openCurrent();
            node = new XMLText(this, value);
            this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.cdata = function(value) {
            var node;
            this.openCurrent();
            node = new XMLCData(this, value);
            this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.comment = function(value) {
            var node;
            this.openCurrent();
            node = new XMLComment(this, value);
            this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.raw = function(value) {
            var node;
            this.openCurrent();
            node = new XMLRaw(this, value);
            this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.instruction = function(target, value) {
            var i, insTarget, insValue, len, node;
            this.openCurrent();
            if (target != null) target = getValue(target);
            if (value != null) value = getValue(value);
            if (Array.isArray(target)) for(i = 0, len = target.length; i < len; i++){
                insTarget = target[i];
                this.instruction(insTarget);
            }
            else if (isObject(target)) for(insTarget in target){
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                node = new XMLProcessingInstruction(this, target, value);
                this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            }
            return this;
        };
        XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
            var node;
            this.openCurrent();
            if (this.documentStarted) throw new Error("declaration() must be the first node.");
            node = new XMLDeclaration(this, version, encoding, standalone);
            this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
            this.openCurrent();
            if (root == null) throw new Error("Missing root node name.");
            if (this.root) throw new Error("dtd() must come before the root node.");
            this.currentNode = new XMLDocType(this, pubID, sysID);
            this.currentNode.rootNodeName = root;
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            return this;
        };
        XMLDocumentCB.prototype.dtdElement = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDElement(this, name, value);
            this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var node;
            this.openCurrent();
            node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.entity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, false, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.pEntity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, true, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.notation = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDNotation(this, name, value);
            this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.up = function() {
            if (this.currentLevel < 0) throw new Error("The document node has no parent.");
            if (this.currentNode) {
                if (this.currentNode.children) this.closeNode(this.currentNode);
                else this.openNode(this.currentNode);
                this.currentNode = null;
            } else this.closeNode(this.openTags[this.currentLevel]);
            delete this.openTags[this.currentLevel];
            this.currentLevel--;
            return this;
        };
        XMLDocumentCB.prototype.end = function() {
            while(this.currentLevel >= 0)this.up();
            return this.onEnd();
        };
        XMLDocumentCB.prototype.openCurrent = function() {
            if (this.currentNode) {
                this.currentNode.children = true;
                return this.openNode(this.currentNode);
            }
        };
        XMLDocumentCB.prototype.openNode = function(node) {
            var att, chunk, name, ref1;
            if (!node.isOpen) {
                if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) this.root = node;
                chunk = '';
                if (node.type === NodeType.Element) {
                    this.writerOptions.state = WriterState.OpenTag;
                    chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
                    ref1 = node.attribs;
                    for(name in ref1){
                        if (!hasProp.call(ref1, name)) continue;
                        att = ref1[name];
                        chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                    }
                    chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
                    this.writerOptions.state = WriterState.InsideTag;
                } else {
                    this.writerOptions.state = WriterState.OpenTag;
                    chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;
                    if (node.pubID && node.sysID) chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                    else if (node.sysID) chunk += ' SYSTEM "' + node.sysID + '"';
                    if (node.children) {
                        chunk += ' [';
                        this.writerOptions.state = WriterState.InsideTag;
                    } else {
                        this.writerOptions.state = WriterState.CloseTag;
                        chunk += '>';
                    }
                    chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
                }
                this.onData(chunk, this.currentLevel);
                return node.isOpen = true;
            }
        };
        XMLDocumentCB.prototype.closeNode = function(node) {
            var chunk;
            if (!node.isClosed) {
                chunk = '';
                this.writerOptions.state = WriterState.CloseTag;
                if (node.type === NodeType.Element) chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
                else chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
                this.writerOptions.state = WriterState.None;
                this.onData(chunk, this.currentLevel);
                return node.isClosed = true;
            }
        };
        XMLDocumentCB.prototype.onData = function(chunk, level) {
            this.documentStarted = true;
            return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB.prototype.onEnd = function() {
            this.documentCompleted = true;
            return this.onEndCallback();
        };
        XMLDocumentCB.prototype.debugInfo = function(name) {
            if (name == null) return "";
            else return "node: <" + name + ">";
        };
        XMLDocumentCB.prototype.ele = function() {
            return this.element.apply(this, arguments);
        };
        XMLDocumentCB.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLDocumentCB.prototype.txt = function(value) {
            return this.text(value);
        };
        XMLDocumentCB.prototype.dat = function(value) {
            return this.cdata(value);
        };
        XMLDocumentCB.prototype.com = function(value) {
            return this.comment(value);
        };
        XMLDocumentCB.prototype.ins = function(target, value) {
            return this.instruction(target, value);
        };
        XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
            return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
        };
        XMLDocumentCB.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLDocumentCB.prototype.t = function(value) {
            return this.text(value);
        };
        XMLDocumentCB.prototype.d = function(value) {
            return this.cdata(value);
        };
        XMLDocumentCB.prototype.c = function(value) {
            return this.comment(value);
        };
        XMLDocumentCB.prototype.r = function(value) {
            return this.raw(value);
        };
        XMLDocumentCB.prototype.i = function(target, value) {
            return this.instruction(target, value);
        };
        XMLDocumentCB.prototype.att = function() {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
            else return this.attribute.apply(this, arguments);
        };
        XMLDocumentCB.prototype.a = function() {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
            else return this.attribute.apply(this, arguments);
        };
        XMLDocumentCB.prototype.ent = function(name, value) {
            return this.entity(name, value);
        };
        XMLDocumentCB.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
        };
        XMLDocumentCB.prototype.not = function(name, value) {
            return this.notation(name, value);
        };
        return XMLDocumentCB;
    })();
}).call(this);

},{"./Utility":"3gpwT","./NodeType":"bHsfv","./XMLDocument":"8Zx5L","./XMLElement":"4FyHi","./XMLCData":"bJsP2","./XMLComment":"457jq","./XMLRaw":"kQIkd","./XMLText":"bU2bi","./XMLProcessingInstruction":"caXGK","./XMLDeclaration":"jSij2","./XMLDocType":"cVmkM","./XMLDTDAttList":"388gh","./XMLDTDEntity":"3zIKf","./XMLDTDElement":"dW7eI","./XMLDTDNotation":"gZJiZ","./XMLAttribute":"4geFW","./XMLStringifier":"i909L","./XMLStringWriter":"WCwh2","./WriterState":"psDCU"}],"8vRPE":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLStreamWriter1, XMLWriterBase, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLWriterBase = require('./XMLWriterBase');
    WriterState = require('./WriterState');
    module.exports = XMLStreamWriter1 = (function(superClass) {
        extend(XMLStreamWriter, superClass);
        function XMLStreamWriter(stream, options) {
            this.stream = stream;
            XMLStreamWriter.__super__.constructor.call(this, options);
        }
        XMLStreamWriter.prototype.endline = function(node, options, level) {
            if (node.isLastRootNode && options.state === WriterState.CloseTag) return '';
            else return XMLStreamWriter.__super__.endline.call(this, node, options, level);
        };
        XMLStreamWriter.prototype.document = function(doc, options) {
            var child, i, j, k, len, len1, ref, ref1, results;
            ref = doc.children;
            for(i = j = 0, len = ref.length; j < len; i = ++j){
                child = ref[i];
                child.isLastRootNode = i === doc.children.length - 1;
            }
            options = this.filterOptions(options);
            ref1 = doc.children;
            results = [];
            for(k = 0, len1 = ref1.length; k < len1; k++){
                child = ref1[k];
                results.push(this.writeChildNode(child, options, 0));
            }
            return results;
        };
        XMLStreamWriter.prototype.attribute = function(att, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
        };
        XMLStreamWriter.prototype.cdata = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.comment = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.declaration = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.docType = function(node, options, level) {
            var child, j, len, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level));
            this.stream.write('<!DOCTYPE ' + node.root().name);
            if (node.pubID && node.sysID) this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            else if (node.sysID) this.stream.write(' SYSTEM "' + node.sysID + '"');
            if (node.children.length > 0) {
                this.stream.write(' [');
                this.stream.write(this.endline(node, options, level));
                options.state = WriterState.InsideTag;
                ref = node.children;
                for(j = 0, len = ref.length; j < len; j++){
                    child = ref[j];
                    this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write(']');
            }
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + '>');
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
        };
        XMLStreamWriter.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level) + '<' + node.name);
            ref = node.attribs;
            for(name in ref){
                if (!hasProp.call(ref, name)) continue;
                att = ref[name];
                this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e) {
                return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
            })) {
                if (options.allowEmpty) {
                    this.stream.write('>');
                    options.state = WriterState.CloseTag;
                    this.stream.write('</' + node.name + '>');
                } else {
                    options.state = WriterState.CloseTag;
                    this.stream.write(options.spaceBeforeSlash + '/>');
                }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                this.stream.write('>');
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                prettySuppressed = true;
                this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                prettySuppressed = false;
                options.state = WriterState.CloseTag;
                this.stream.write('</' + node.name + '>');
            } else {
                this.stream.write('>' + this.endline(node, options, level));
                options.state = WriterState.InsideTag;
                ref1 = node.children;
                for(j = 0, len = ref1.length; j < len; j++){
                    child = ref1[j];
                    this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
            }
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
        };
        XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.raw = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.text = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
        };
        return XMLStreamWriter;
    })(XMLWriterBase);
}).call(this);

},{"./NodeType":"bHsfv","./XMLWriterBase":"epzCv","./WriterState":"psDCU"}],"8Wy45":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var bom, defaults, events, isEmpty, processItem, processors1, sax, setImmediate, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    sax = require('sax');
    events = require('events');
    bom = require('./bom');
    processors1 = require('./processors');
    setImmediate = require('timers').setImmediate;
    defaults = require('./defaults').defaults;
    isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
    };
    processItem = function(processors, item, key) {
        var i, len, process;
        for(i = 0, len = processors.length; i < len; i++){
            process = processors[i];
            item = process(item, key);
        }
        return item;
    };
    exports.Parser = (function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
            this.parseStringPromise = bind(this.parseStringPromise, this);
            this.parseString = bind(this.parseString, this);
            this.reset = bind(this.reset, this);
            this.assignOrPush = bind(this.assignOrPush, this);
            this.processAsync = bind(this.processAsync, this);
            var key, ref, value;
            if (!(this instanceof exports.Parser)) return new exports.Parser(opts);
            this.options = {
            };
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
            if (this.options.xmlns) this.options.xmlnskey = this.options.attrkey + "ns";
            if (this.options.normalizeTags) {
                if (!this.options.tagNameProcessors) this.options.tagNameProcessors = [];
                this.options.tagNameProcessors.unshift(processors1.normalize);
            }
            this.reset();
        }
        Parser.prototype.processAsync = function() {
            var chunk, err;
            try {
                if (this.remaining.length <= this.options.chunkSize) {
                    chunk = this.remaining;
                    this.remaining = '';
                    this.saxParser = this.saxParser.write(chunk);
                    return this.saxParser.close();
                } else {
                    chunk = this.remaining.substr(0, this.options.chunkSize);
                    this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                    this.saxParser = this.saxParser.write(chunk);
                    return setImmediate(this.processAsync);
                }
            } catch (error1) {
                err = error1;
                if (!this.saxParser.errThrown) {
                    this.saxParser.errThrown = true;
                    return this.emit(err);
                }
            }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
            if (!(key in obj)) {
                if (!this.options.explicitArray) return obj[key] = newValue;
                else return obj[key] = [
                    newValue
                ];
            } else {
                if (!(obj[key] instanceof Array)) obj[key] = [
                    obj[key]
                ];
                return obj[key].push(newValue);
            }
        };
        Parser.prototype.reset = function() {
            var attrkey, charkey, ontext, stack;
            this.removeAllListeners();
            this.saxParser = sax.parser(this.options.strict, {
                trim: false,
                normalize: false,
                xmlns: this.options.xmlns
            });
            this.saxParser.errThrown = false;
            this.saxParser.onerror = (function(_this) {
                return function(error) {
                    _this.saxParser.resume();
                    if (!_this.saxParser.errThrown) {
                        _this.saxParser.errThrown = true;
                        return _this.emit("error", error);
                    }
                };
            })(this);
            this.saxParser.onend = (function(_this) {
                return function() {
                    if (!_this.saxParser.ended) {
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            })(this);
            this.saxParser.ended = false;
            this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
            this.resultObject = null;
            stack = [];
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            this.saxParser.onopentag = (function(_this) {
                return function(node) {
                    var key, newValue, obj, processedKey, ref;
                    obj = {
                    };
                    obj[charkey] = "";
                    if (!_this.options.ignoreAttrs) {
                        ref = node.attributes;
                        for(key in ref){
                            if (!hasProp.call(ref, key)) continue;
                            if (!(attrkey in obj) && !_this.options.mergeAttrs) obj[attrkey] = {
                            };
                            newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                            processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                            if (_this.options.mergeAttrs) _this.assignOrPush(obj, processedKey, newValue);
                            else obj[attrkey][processedKey] = newValue;
                        }
                    }
                    obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                    if (_this.options.xmlns) obj[_this.options.xmlnskey] = {
                        uri: node.uri,
                        local: node.local
                    };
                    return stack.push(obj);
                };
            })(this);
            this.saxParser.onclosetag = (function(_this) {
                return function() {
                    var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                    obj = stack.pop();
                    nodeName = obj["#name"];
                    if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) delete obj["#name"];
                    if (obj.cdata === true) {
                        cdata = obj.cdata;
                        delete obj.cdata;
                    }
                    s = stack[stack.length - 1];
                    if (obj[charkey].match(/^\s*$/) && !cdata) {
                        emptyStr = obj[charkey];
                        delete obj[charkey];
                    } else {
                        if (_this.options.trim) obj[charkey] = obj[charkey].trim();
                        if (_this.options.normalize) obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                        obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                        if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
                    }
                    if (isEmpty(obj)) obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
                    if (_this.options.validator != null) {
                        xpath = "/" + (function() {
                            var i, len, results;
                            results = [];
                            for(i = 0, len = stack.length; i < len; i++){
                                node = stack[i];
                                results.push(node["#name"]);
                            }
                            return results;
                        })().concat(nodeName).join("/");
                        (function() {
                            var err;
                            try {
                                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                            } catch (error1) {
                                err = error1;
                                return _this.emit("error", err);
                            }
                        })();
                    }
                    if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                        if (!_this.options.preserveChildrenOrder) {
                            node = {
                            };
                            if (_this.options.attrkey in obj) {
                                node[_this.options.attrkey] = obj[_this.options.attrkey];
                                delete obj[_this.options.attrkey];
                            }
                            if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                node[_this.options.charkey] = obj[_this.options.charkey];
                                delete obj[_this.options.charkey];
                            }
                            if (Object.getOwnPropertyNames(obj).length > 0) node[_this.options.childkey] = obj;
                            obj = node;
                        } else if (s) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            objClone = {
                            };
                            for(key in obj){
                                if (!hasProp.call(obj, key)) continue;
                                objClone[key] = obj[key];
                            }
                            s[_this.options.childkey].push(objClone);
                            delete obj["#name"];
                            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
                        }
                    }
                    if (stack.length > 0) return _this.assignOrPush(s, nodeName, obj);
                    else {
                        if (_this.options.explicitRoot) {
                            old = obj;
                            obj = {
                            };
                            obj[nodeName] = old;
                        }
                        _this.resultObject = obj;
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            })(this);
            ontext = (function(_this) {
                return function(text) {
                    var charChild, s;
                    s = stack[stack.length - 1];
                    if (s) {
                        s[charkey] += text;
                        if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            charChild = {
                                '#name': '__text__'
                            };
                            charChild[charkey] = text;
                            if (_this.options.normalize) charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                            s[_this.options.childkey].push(charChild);
                        }
                        return s;
                    }
                };
            })(this);
            this.saxParser.ontext = ontext;
            return this.saxParser.oncdata = (function(_this) {
                return function(text) {
                    var s;
                    s = ontext(text);
                    if (s) return s.cdata = true;
                };
            })(this);
        };
        Parser.prototype.parseString = function(str, cb) {
            var err1;
            if (cb != null && typeof cb === "function") {
                this.on("end", function(result) {
                    this.reset();
                    return cb(null, result);
                });
                this.on("error", function(err) {
                    this.reset();
                    return cb(err);
                });
            }
            try {
                str = str.toString();
                if (str.trim() === '') {
                    this.emit("end", null);
                    return true;
                }
                str = bom.stripBOM(str);
                if (this.options.async) {
                    this.remaining = str;
                    setImmediate(this.processAsync);
                    return this.saxParser;
                }
                return this.saxParser.write(str).close();
            } catch (error1) {
                err1 = error1;
                if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                    this.emit('error', err1);
                    return this.saxParser.errThrown = true;
                } else if (this.saxParser.ended) throw err1;
            }
        };
        Parser.prototype.parseStringPromise = function(str) {
            return new Promise(function(_this) {
                return function(resolve, reject) {
                    return _this.parseString(str, function(err, value) {
                        if (err) return reject(err);
                        else return resolve(value);
                    });
                };
            }(this));
        };
        return Parser;
    })(events);
    exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
            if (typeof b === 'function') cb = b;
            if (typeof a === 'object') options = a;
        } else {
            if (typeof a === 'function') cb = a;
            options = {
            };
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
    };
    exports.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === 'object') options = a;
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
    };
}).call(this);

},{"sax":"gBT5g","events":"bHM3D","./bom":"hdwAm","./processors":"ckxC8","timers":"59lXe","./defaults":"fDk2h"}],"gBT5g":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function(sax) {
    sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 65536;
    var buffers = [
        'comment',
        'sgmlDecl',
        'textNode',
        'tagName',
        'doctype',
        'procInstName',
        'procInstBody',
        'entity',
        'attribName',
        'attribValue',
        'cdata',
        'script'
    ];
    sax.EVENTS = [
        'text',
        'processinginstruction',
        'sgmldeclaration',
        'doctype',
        'comment',
        'opentagstart',
        'attribute',
        'opentag',
        'closetag',
        'opencdata',
        'cdata',
        'closecdata',
        'error',
        'end',
        'ready',
        'script',
        'opennamespace',
        'closenamespace'
    ];
    function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = '';
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {
        };
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        // namespaces form a prototype chain.
        // it always points at the current tag,
        // which protos to its parent tag.
        if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
        // mostly just for error reporting
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
        emit(parser, 'onready');
    }
    if (!Object.create) Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
    };
    if (!Object.keys) Object.keys = function(o) {
        var a = [];
        for(var i in o)if (o.hasOwnProperty(i)) a.push(i);
        return a;
    };
    function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for(var i = 0, l = buffers.length; i < l; i++){
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) // Text/cdata nodes can get big, and since they're buffered,
            // we can get here under normal conditions.
            // Avoid issues by emitting the text node now,
            // so at least it won't get any bigger.
            switch(buffers[i]){
                case 'textNode':
                    closeText(parser);
                    break;
                case 'cdata':
                    emitNode(parser, 'oncdata', parser.cdata);
                    parser.cdata = '';
                    break;
                case 'script':
                    emitNode(parser, 'onscript', parser.script);
                    parser.script = '';
                    break;
                default:
                    error(parser, 'Max buffer length exceeded: ' + buffers[i]);
            }
            maxActual = Math.max(maxActual, len);
        }
        // schedule the next check for the earliest possible buffer overrun.
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
        for(var i = 0, l = buffers.length; i < l; i++)parser[buffers[i]] = '';
    }
    function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== '') {
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
        }
        if (parser.script !== '') {
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
    }
    SAXParser.prototype = {
        end: function() {
            end(this);
        },
        write: write,
        resume: function() {
            this.error = null;
            return this;
        },
        close: function() {
            return this.write(null);
        },
        flush: function() {
            flushBuffers(this);
        }
    };
    var Stream;
    try {
        Stream = require('stream').Stream;
    } catch (ex) {
        Stream = function() {
        };
    }
    var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== 'error' && ev !== 'end';
    });
    function createStream(strict, opt) {
        return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
            me.emit('end');
        };
        this._parser.onerror = function(er) {
            me.emit('error', er);
            // if didn't throw, then means error was handled.
            // go ahead and clear error, so we can write again.
            me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
            Object.defineProperty(me, 'on' + ev, {
                get: function() {
                    return me._parser['on' + ev];
                },
                set: function(h) {
                    if (!h) {
                        me.removeAllListeners(ev);
                        me._parser['on' + ev] = h;
                        return h;
                    }
                    me.on(ev, h);
                },
                enumerable: true,
                configurable: false
            });
        });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
            value: SAXStream
        }
    });
    SAXStream.prototype.write = function(data) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = require('string_decoder').StringDecoder;
                this._decoder = new SD('utf8');
            }
            data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit('data', data);
        return true;
    };
    SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) this.write(chunk);
        this._parser.end();
        return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) me._parser['on' + ev] = function() {
            var args = arguments.length === 1 ? [
                arguments[0]
            ] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
        };
        return Stream.prototype.on.call(me, ev, handler);
    };
    // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.
    var CDATA = '[CDATA[';
    var DOCTYPE = 'DOCTYPE';
    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
    var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
    };
    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
        return c === ' ' || c === '\n' || c === '\r' || c === '\t';
    }
    function isQuote(c) {
        return c === '"' || c === '\'';
    }
    function isAttribEnd(c) {
        return c === '>' || isWhitespace(c);
    }
    function isMatch(regex, c) {
        return regex.test(c);
    }
    function notMatch(regex, c) {
        return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++ // <script> ... <
    };
    sax.XML_ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': "'"
    };
    sax.ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': "'",
        'AElig': 198,
        'Aacute': 193,
        'Acirc': 194,
        'Agrave': 192,
        'Aring': 197,
        'Atilde': 195,
        'Auml': 196,
        'Ccedil': 199,
        'ETH': 208,
        'Eacute': 201,
        'Ecirc': 202,
        'Egrave': 200,
        'Euml': 203,
        'Iacute': 205,
        'Icirc': 206,
        'Igrave': 204,
        'Iuml': 207,
        'Ntilde': 209,
        'Oacute': 211,
        'Ocirc': 212,
        'Ograve': 210,
        'Oslash': 216,
        'Otilde': 213,
        'Ouml': 214,
        'THORN': 222,
        'Uacute': 218,
        'Ucirc': 219,
        'Ugrave': 217,
        'Uuml': 220,
        'Yacute': 221,
        'aacute': 225,
        'acirc': 226,
        'aelig': 230,
        'agrave': 224,
        'aring': 229,
        'atilde': 227,
        'auml': 228,
        'ccedil': 231,
        'eacute': 233,
        'ecirc': 234,
        'egrave': 232,
        'eth': 240,
        'euml': 235,
        'iacute': 237,
        'icirc': 238,
        'igrave': 236,
        'iuml': 239,
        'ntilde': 241,
        'oacute': 243,
        'ocirc': 244,
        'ograve': 242,
        'oslash': 248,
        'otilde': 245,
        'ouml': 246,
        'szlig': 223,
        'thorn': 254,
        'uacute': 250,
        'ucirc': 251,
        'ugrave': 249,
        'uuml': 252,
        'yacute': 253,
        'yuml': 255,
        'copy': 169,
        'reg': 174,
        'nbsp': 160,
        'iexcl': 161,
        'cent': 162,
        'pound': 163,
        'curren': 164,
        'yen': 165,
        'brvbar': 166,
        'sect': 167,
        'uml': 168,
        'ordf': 170,
        'laquo': 171,
        'not': 172,
        'shy': 173,
        'macr': 175,
        'deg': 176,
        'plusmn': 177,
        'sup1': 185,
        'sup2': 178,
        'sup3': 179,
        'acute': 180,
        'micro': 181,
        'para': 182,
        'middot': 183,
        'cedil': 184,
        'ordm': 186,
        'raquo': 187,
        'frac14': 188,
        'frac12': 189,
        'frac34': 190,
        'iquest': 191,
        'times': 215,
        'divide': 247,
        'OElig': 338,
        'oelig': 339,
        'Scaron': 352,
        'scaron': 353,
        'Yuml': 376,
        'fnof': 402,
        'circ': 710,
        'tilde': 732,
        'Alpha': 913,
        'Beta': 914,
        'Gamma': 915,
        'Delta': 916,
        'Epsilon': 917,
        'Zeta': 918,
        'Eta': 919,
        'Theta': 920,
        'Iota': 921,
        'Kappa': 922,
        'Lambda': 923,
        'Mu': 924,
        'Nu': 925,
        'Xi': 926,
        'Omicron': 927,
        'Pi': 928,
        'Rho': 929,
        'Sigma': 931,
        'Tau': 932,
        'Upsilon': 933,
        'Phi': 934,
        'Chi': 935,
        'Psi': 936,
        'Omega': 937,
        'alpha': 945,
        'beta': 946,
        'gamma': 947,
        'delta': 948,
        'epsilon': 949,
        'zeta': 950,
        'eta': 951,
        'theta': 952,
        'iota': 953,
        'kappa': 954,
        'lambda': 955,
        'mu': 956,
        'nu': 957,
        'xi': 958,
        'omicron': 959,
        'pi': 960,
        'rho': 961,
        'sigmaf': 962,
        'sigma': 963,
        'tau': 964,
        'upsilon': 965,
        'phi': 966,
        'chi': 967,
        'psi': 968,
        'omega': 969,
        'thetasym': 977,
        'upsih': 978,
        'piv': 982,
        'ensp': 8194,
        'emsp': 8195,
        'thinsp': 8201,
        'zwnj': 8204,
        'zwj': 8205,
        'lrm': 8206,
        'rlm': 8207,
        'ndash': 8211,
        'mdash': 8212,
        'lsquo': 8216,
        'rsquo': 8217,
        'sbquo': 8218,
        'ldquo': 8220,
        'rdquo': 8221,
        'bdquo': 8222,
        'dagger': 8224,
        'Dagger': 8225,
        'bull': 8226,
        'hellip': 8230,
        'permil': 8240,
        'prime': 8242,
        'Prime': 8243,
        'lsaquo': 8249,
        'rsaquo': 8250,
        'oline': 8254,
        'frasl': 8260,
        'euro': 8364,
        'image': 8465,
        'weierp': 8472,
        'real': 8476,
        'trade': 8482,
        'alefsym': 8501,
        'larr': 8592,
        'uarr': 8593,
        'rarr': 8594,
        'darr': 8595,
        'harr': 8596,
        'crarr': 8629,
        'lArr': 8656,
        'uArr': 8657,
        'rArr': 8658,
        'dArr': 8659,
        'hArr': 8660,
        'forall': 8704,
        'part': 8706,
        'exist': 8707,
        'empty': 8709,
        'nabla': 8711,
        'isin': 8712,
        'notin': 8713,
        'ni': 8715,
        'prod': 8719,
        'sum': 8721,
        'minus': 8722,
        'lowast': 8727,
        'radic': 8730,
        'prop': 8733,
        'infin': 8734,
        'ang': 8736,
        'and': 8743,
        'or': 8744,
        'cap': 8745,
        'cup': 8746,
        'int': 8747,
        'there4': 8756,
        'sim': 8764,
        'cong': 8773,
        'asymp': 8776,
        'ne': 8800,
        'equiv': 8801,
        'le': 8804,
        'ge': 8805,
        'sub': 8834,
        'sup': 8835,
        'nsub': 8836,
        'sube': 8838,
        'supe': 8839,
        'oplus': 8853,
        'otimes': 8855,
        'perp': 8869,
        'sdot': 8901,
        'lceil': 8968,
        'rceil': 8969,
        'lfloor': 8970,
        'rfloor': 8971,
        'lang': 9001,
        'rang': 9002,
        'loz': 9674,
        'spades': 9824,
        'clubs': 9827,
        'hearts': 9829,
        'diams': 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === 'number' ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
    });
    for(var s1 in sax.STATE)sax.STATE[sax.STATE[s1]] = s1;
    // shorthand
    S = sax.STATE;
    function emit(parser, event, data) {
        parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
    }
    function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, 'ontext', parser.textNode);
        parser.textNode = '';
    }
    function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, ' ');
        return text;
    }
    function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
        er = new Error(er);
        parser.error = er;
        emit(parser, 'onerror', er);
        return parser;
    }
    function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) error(parser, 'Unexpected end');
        closeText(parser);
        parser.c = '';
        parser.closed = true;
        emit(parser, 'onend');
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
    }
    function strictFail(parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser)) throw new Error('bad call to strictFail');
        if (parser.strict) error(parser, message);
    }
    function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
            name: parser.tagName,
            attributes: {
            }
        };
        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
        if (parser.opt.xmlns) tag.ns = parent.ns;
        parser.attribList.length = 0;
        emitNode(parser, 'onopentagstart', tag);
    }
    function qname(name, attribute) {
        var i = name.indexOf(':');
        var qualName = i < 0 ? [
            '',
            name
        ] : name.split(':');
        var prefix = qualName[0];
        var local = qualName[1];
        // <x "xmlns"="http://foo">
        if (attribute && name === 'xmlns') {
            prefix = 'xmlns';
            local = '';
        }
        return {
            prefix: prefix,
            local: local
        };
    }
    function attrib(parser) {
        if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = '';
            return;
        }
        if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === 'xmlns') {
                // namespace binding attribute. push the binding into scope
                if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
                    tag.ns[local] = parser.attribValue;
                }
            }
            // defer onattribute events until all attributes have been seen
            // so any new bindings can take effect. preserve attribute order
            // so deferred events can be emitted in document order
            parser.attribList.push([
                parser.attribName,
                parser.attribValue
            ]);
        } else {
            // in non-xmlns mode, we can emit the event right away
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, 'onattribute', {
                name: parser.attribName,
                value: parser.attribValue
            });
        }
        parser.attribName = parser.attribValue = '';
    }
    function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
            // emit namespace binding events
            var tag = parser.tag;
            // add namespace info to tag
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || '';
            if (tag.prefix && !tag.uri) {
                strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
                tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p) {
                emitNode(parser, 'onopennamespace', {
                    prefix: p,
                    uri: tag.ns[p]
                });
            });
            // handle deferred onattribute events
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for(var i = 0, l = parser.attribList.length; i < l; i++){
                var nv = parser.attribList[i];
                var name = nv[0];
                var value = nv[1];
                var qualName = qname(name, true);
                var prefix = qualName.prefix;
                var local = qualName.local;
                var uri = prefix === '' ? '' : tag.ns[prefix] || '';
                var a = {
                    name: name,
                    value: value,
                    prefix: prefix,
                    local: local,
                    uri: uri
                };
                // if there's any attributes with an undefined namespace,
                // then fail on them now.
                if (prefix && prefix !== 'xmlns' && !uri) {
                    strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
                    a.uri = prefix;
                }
                parser.tag.attributes[name] = a;
                emitNode(parser, 'onattribute', a);
            }
            parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        // process the tag
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, 'onopentag', parser.tag);
        if (!selfClosing) {
            // special case for <script> in non-strict mode.
            if (!parser.noscript && parser.tagName.toLowerCase() === 'script') parser.state = S.SCRIPT;
            else parser.state = S.TEXT;
            parser.tag = null;
            parser.tagName = '';
        }
        parser.attribName = parser.attribValue = '';
        parser.attribList.length = 0;
    }
    function closeTag(parser) {
        if (!parser.tagName) {
            strictFail(parser, 'Weird empty close tag.');
            parser.textNode += '</>';
            parser.state = S.TEXT;
            return;
        }
        if (parser.script) {
            if (parser.tagName !== 'script') {
                parser.script += '</' + parser.tagName + '>';
                parser.tagName = '';
                parser.state = S.SCRIPT;
                return;
            }
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
        // first make sure that the closing tag actually exists.
        // <a><b></c></b></a> will close everything, otherwise.
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) tagName = tagName[parser.looseCase]();
        var closeTo = tagName;
        while(t--){
            var close = parser.tags[t];
            if (close.name !== closeTo) // fail the first time in strict mode
            strictFail(parser, 'Unexpected close tag');
            else break;
        }
        // didn't find it.  we already failed for strict, so just abort.
        if (t < 0) {
            strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
            parser.textNode += '</' + parser.tagName + '>';
            parser.state = S.TEXT;
            return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while((s--) > t){
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, 'onclosetag', parser.tagName);
            var x = {
            };
            for(var i in tag.ns)x[i] = tag.ns[i];
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) // remove namespace bindings introduced by tag
            Object.keys(tag.ns).forEach(function(p) {
                var n = tag.ns[p];
                emitNode(parser, 'onclosenamespace', {
                    prefix: p,
                    uri: n
                });
            });
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = '';
        parser.attribList.length = 0;
        parser.state = S.TEXT;
    }
    function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = '';
        if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
        if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
        entity = entityLC;
        if (entity.charAt(0) === '#') {
            if (entity.charAt(1) === 'x') {
                entity = entity.slice(2);
                num = parseInt(entity, 16);
                numStr = num.toString(16);
            } else {
                entity = entity.slice(1);
                num = parseInt(entity, 10);
                numStr = num.toString(10);
            }
        }
        entity = entity.replace(/^0+/, '');
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, 'Invalid character entity');
            return '&' + parser.entity + ';';
        }
        return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
        if (c === '<') {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
            // have to process this as a text node.
            // weird, but happens.
            strictFail(parser, 'Non-whitespace before first tag.');
            parser.textNode = c;
            parser.state = S.TEXT;
        }
    }
    function charAt(chunk, i) {
        var result = '';
        if (i < chunk.length) result = chunk.charAt(i);
        return result;
    }
    function write(chunk) {
        var parser = this;
        if (this.error) throw this.error;
        if (parser.closed) return error(parser, 'Cannot write after close. Assign an onready handler.');
        if (chunk === null) return end(parser);
        if (typeof chunk === 'object') chunk = chunk.toString();
        var i = 0;
        var c = '';
        while(true){
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) break;
            if (parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                    parser.line++;
                    parser.column = 0;
                } else parser.column++;
            }
            switch(parser.state){
                case S.BEGIN:
                    parser.state = S.BEGIN_WHITESPACE;
                    if (c === '\uFEFF') continue;
                    beginWhiteSpace(parser, c);
                    continue;
                case S.BEGIN_WHITESPACE:
                    beginWhiteSpace(parser, c);
                    continue;
                case S.TEXT:
                    if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i - 1;
                        while(c && c !== '<' && c !== '&'){
                            c = charAt(chunk, i++);
                            if (c && parser.trackPosition) {
                                parser.position++;
                                if (c === '\n') {
                                    parser.line++;
                                    parser.column = 0;
                                } else parser.column++;
                            }
                        }
                        parser.textNode += chunk.substring(starti, i - 1);
                    }
                    if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    } else {
                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, 'Text data outside of root node.');
                        if (c === '&') parser.state = S.TEXT_ENTITY;
                        else parser.textNode += c;
                    }
                    continue;
                case S.SCRIPT:
                    // only non-strict
                    if (c === '<') parser.state = S.SCRIPT_ENDING;
                    else parser.script += c;
                    continue;
                case S.SCRIPT_ENDING:
                    if (c === '/') parser.state = S.CLOSE_TAG;
                    else {
                        parser.script += '<' + c;
                        parser.state = S.SCRIPT;
                    }
                    continue;
                case S.OPEN_WAKA:
                    // either a /, ?, !, or text is coming next.
                    if (c === '!') {
                        parser.state = S.SGML_DECL;
                        parser.sgmlDecl = '';
                    } else if (isWhitespace(c)) ;
                    else if (isMatch(nameStart, c)) {
                        parser.state = S.OPEN_TAG;
                        parser.tagName = c;
                    } else if (c === '/') {
                        parser.state = S.CLOSE_TAG;
                        parser.tagName = '';
                    } else if (c === '?') {
                        parser.state = S.PROC_INST;
                        parser.procInstName = parser.procInstBody = '';
                    } else {
                        strictFail(parser, 'Unencoded <');
                        // if there was some whitespace, then add that in.
                        if (parser.startTagPosition + 1 < parser.position) {
                            var pad = parser.position - parser.startTagPosition;
                            c = new Array(pad).join(' ') + c;
                        }
                        parser.textNode += '<' + c;
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.SGML_DECL:
                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                        emitNode(parser, 'onopencdata');
                        parser.state = S.CDATA;
                        parser.sgmlDecl = '';
                        parser.cdata = '';
                    } else if (parser.sgmlDecl + c === '--') {
                        parser.state = S.COMMENT;
                        parser.comment = '';
                        parser.sgmlDecl = '';
                    } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                        parser.state = S.DOCTYPE;
                        if (parser.doctype || parser.sawRoot) strictFail(parser, 'Inappropriately located doctype declaration');
                        parser.doctype = '';
                        parser.sgmlDecl = '';
                    } else if (c === '>') {
                        emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                        parser.sgmlDecl = '';
                        parser.state = S.TEXT;
                    } else if (isQuote(c)) {
                        parser.state = S.SGML_DECL_QUOTED;
                        parser.sgmlDecl += c;
                    } else parser.sgmlDecl += c;
                    continue;
                case S.SGML_DECL_QUOTED:
                    if (c === parser.q) {
                        parser.state = S.SGML_DECL;
                        parser.q = '';
                    }
                    parser.sgmlDecl += c;
                    continue;
                case S.DOCTYPE:
                    if (c === '>') {
                        parser.state = S.TEXT;
                        emitNode(parser, 'ondoctype', parser.doctype);
                        parser.doctype = true // just remember that we saw it.
                        ;
                    } else {
                        parser.doctype += c;
                        if (c === '[') parser.state = S.DOCTYPE_DTD;
                        else if (isQuote(c)) {
                            parser.state = S.DOCTYPE_QUOTED;
                            parser.q = c;
                        }
                    }
                    continue;
                case S.DOCTYPE_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.q = '';
                        parser.state = S.DOCTYPE;
                    }
                    continue;
                case S.DOCTYPE_DTD:
                    parser.doctype += c;
                    if (c === ']') parser.state = S.DOCTYPE;
                    else if (isQuote(c)) {
                        parser.state = S.DOCTYPE_DTD_QUOTED;
                        parser.q = c;
                    }
                    continue;
                case S.DOCTYPE_DTD_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.q = '';
                    }
                    continue;
                case S.COMMENT:
                    if (c === '-') parser.state = S.COMMENT_ENDING;
                    else parser.comment += c;
                    continue;
                case S.COMMENT_ENDING:
                    if (c === '-') {
                        parser.state = S.COMMENT_ENDED;
                        parser.comment = textopts(parser.opt, parser.comment);
                        if (parser.comment) emitNode(parser, 'oncomment', parser.comment);
                        parser.comment = '';
                    } else {
                        parser.comment += '-' + c;
                        parser.state = S.COMMENT;
                    }
                    continue;
                case S.COMMENT_ENDED:
                    if (c !== '>') {
                        strictFail(parser, 'Malformed comment');
                        // allow <\!-- blah -- bloo --> in non-strict mode,
                        // which is a comment of " blah -- bloo "
                        parser.comment += '--' + c;
                        parser.state = S.COMMENT;
                    } else parser.state = S.TEXT;
                    continue;
                case S.CDATA:
                    if (c === ']') parser.state = S.CDATA_ENDING;
                    else parser.cdata += c;
                    continue;
                case S.CDATA_ENDING:
                    if (c === ']') parser.state = S.CDATA_ENDING_2;
                    else {
                        parser.cdata += ']' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.CDATA_ENDING_2:
                    if (c === '>') {
                        if (parser.cdata) emitNode(parser, 'oncdata', parser.cdata);
                        emitNode(parser, 'onclosecdata');
                        parser.cdata = '';
                        parser.state = S.TEXT;
                    } else if (c === ']') parser.cdata += ']';
                    else {
                        parser.cdata += ']]' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.PROC_INST:
                    if (c === '?') parser.state = S.PROC_INST_ENDING;
                    else if (isWhitespace(c)) parser.state = S.PROC_INST_BODY;
                    else parser.procInstName += c;
                    continue;
                case S.PROC_INST_BODY:
                    if (!parser.procInstBody && isWhitespace(c)) continue;
                    else if (c === '?') parser.state = S.PROC_INST_ENDING;
                    else parser.procInstBody += c;
                    continue;
                case S.PROC_INST_ENDING:
                    if (c === '>') {
                        emitNode(parser, 'onprocessinginstruction', {
                            name: parser.procInstName,
                            body: parser.procInstBody
                        });
                        parser.procInstName = parser.procInstBody = '';
                        parser.state = S.TEXT;
                    } else {
                        parser.procInstBody += '?' + c;
                        parser.state = S.PROC_INST_BODY;
                    }
                    continue;
                case S.OPEN_TAG:
                    if (isMatch(nameBody, c)) parser.tagName += c;
                    else {
                        newTag(parser);
                        if (c === '>') openTag(parser);
                        else if (c === '/') parser.state = S.OPEN_TAG_SLASH;
                        else {
                            if (!isWhitespace(c)) strictFail(parser, 'Invalid character in tag name');
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.OPEN_TAG_SLASH:
                    if (c === '>') {
                        openTag(parser, true);
                        closeTag(parser);
                    } else {
                        strictFail(parser, 'Forward-slash in opening tag not followed by >');
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.ATTRIB:
                    // haven't read the attribute name yet.
                    if (isWhitespace(c)) continue;
                    else if (c === '>') openTag(parser);
                    else if (c === '/') parser.state = S.OPEN_TAG_SLASH;
                    else if (isMatch(nameStart, c)) {
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else strictFail(parser, 'Invalid attribute name');
                    continue;
                case S.ATTRIB_NAME:
                    if (c === '=') parser.state = S.ATTRIB_VALUE;
                    else if (c === '>') {
                        strictFail(parser, 'Attribute without value');
                        parser.attribValue = parser.attribName;
                        attrib(parser);
                        openTag(parser);
                    } else if (isWhitespace(c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;
                    else if (isMatch(nameBody, c)) parser.attribName += c;
                    else strictFail(parser, 'Invalid attribute name');
                    continue;
                case S.ATTRIB_NAME_SAW_WHITE:
                    if (c === '=') parser.state = S.ATTRIB_VALUE;
                    else if (isWhitespace(c)) continue;
                    else {
                        strictFail(parser, 'Attribute without value');
                        parser.tag.attributes[parser.attribName] = '';
                        parser.attribValue = '';
                        emitNode(parser, 'onattribute', {
                            name: parser.attribName,
                            value: ''
                        });
                        parser.attribName = '';
                        if (c === '>') openTag(parser);
                        else if (isMatch(nameStart, c)) {
                            parser.attribName = c;
                            parser.state = S.ATTRIB_NAME;
                        } else {
                            strictFail(parser, 'Invalid attribute name');
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.ATTRIB_VALUE:
                    if (isWhitespace(c)) continue;
                    else if (isQuote(c)) {
                        parser.q = c;
                        parser.state = S.ATTRIB_VALUE_QUOTED;
                    } else {
                        strictFail(parser, 'Unquoted attribute value');
                        parser.state = S.ATTRIB_VALUE_UNQUOTED;
                        parser.attribValue = c;
                    }
                    continue;
                case S.ATTRIB_VALUE_QUOTED:
                    if (c !== parser.q) {
                        if (c === '&') parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                        else parser.attribValue += c;
                        continue;
                    }
                    attrib(parser);
                    parser.q = '';
                    parser.state = S.ATTRIB_VALUE_CLOSED;
                    continue;
                case S.ATTRIB_VALUE_CLOSED:
                    if (isWhitespace(c)) parser.state = S.ATTRIB;
                    else if (c === '>') openTag(parser);
                    else if (c === '/') parser.state = S.OPEN_TAG_SLASH;
                    else if (isMatch(nameStart, c)) {
                        strictFail(parser, 'No whitespace between attributes');
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else strictFail(parser, 'Invalid attribute name');
                    continue;
                case S.ATTRIB_VALUE_UNQUOTED:
                    if (!isAttribEnd(c)) {
                        if (c === '&') parser.state = S.ATTRIB_VALUE_ENTITY_U;
                        else parser.attribValue += c;
                        continue;
                    }
                    attrib(parser);
                    if (c === '>') openTag(parser);
                    else parser.state = S.ATTRIB;
                    continue;
                case S.CLOSE_TAG:
                    if (!parser.tagName) {
                        if (isWhitespace(c)) continue;
                        else if (notMatch(nameStart, c)) {
                            if (parser.script) {
                                parser.script += '</' + c;
                                parser.state = S.SCRIPT;
                            } else strictFail(parser, 'Invalid tagname in closing tag.');
                        } else parser.tagName = c;
                    } else if (c === '>') closeTag(parser);
                    else if (isMatch(nameBody, c)) parser.tagName += c;
                    else if (parser.script) {
                        parser.script += '</' + parser.tagName;
                        parser.tagName = '';
                        parser.state = S.SCRIPT;
                    } else {
                        if (!isWhitespace(c)) strictFail(parser, 'Invalid tagname in closing tag');
                        parser.state = S.CLOSE_TAG_SAW_WHITE;
                    }
                    continue;
                case S.CLOSE_TAG_SAW_WHITE:
                    if (isWhitespace(c)) continue;
                    if (c === '>') closeTag(parser);
                    else strictFail(parser, 'Invalid characters in closing tag');
                    continue;
                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                    var returnState;
                    var buffer;
                    switch(parser.state){
                        case S.TEXT_ENTITY:
                            returnState = S.TEXT;
                            buffer = 'textNode';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_Q:
                            returnState = S.ATTRIB_VALUE_QUOTED;
                            buffer = 'attribValue';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_U:
                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                            buffer = 'attribValue';
                            break;
                    }
                    if (c === ';') {
                        parser[buffer] += parseEntity(parser);
                        parser.entity = '';
                        parser.state = returnState;
                    } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) parser.entity += c;
                    else {
                        strictFail(parser, 'Invalid character in entity name');
                        parser[buffer] += '&' + parser.entity + c;
                        parser.entity = '';
                        parser.state = returnState;
                    }
                    continue;
                default:
                    throw new Error(parser, 'Unknown state: ' + parser.state);
            }
        } // while
        if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
        return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ /* istanbul ignore next */ if (!String.fromCodePoint) (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) return '';
            var result = '';
            while(++index < length){
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint // not an integer
                ) throw RangeError('Invalid code point: ' + codePoint);
                if (codePoint <= 65535) codeUnits.push(codePoint);
                else {
                    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    codePoint -= 65536;
                    highSurrogate = (codePoint >> 10) + 55296;
                    lowSurrogate = codePoint % 1024 + 56320;
                    codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                    result += stringFromCharCode.apply(null, codeUnits);
                    codeUnits.length = 0;
                }
            }
            return result;
        };
        /* istanbul ignore next */ if (Object.defineProperty) Object.defineProperty(String, 'fromCodePoint', {
            value: fromCodePoint,
            configurable: true,
            writable: true
        });
        else String.fromCodePoint = fromCodePoint;
    })();
})(typeof exports === 'undefined' ? this.sax = {
} : exports);

},{"buffer":"bOetu","stream":"ylvqt","string_decoder":"vLxWd"}],"bOetu":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
var base64 = require('base64-js');
var ieee754 = require('ieee754');
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 2147483647;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    var length = byteLength1(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength1(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength1;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 255 // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i1;
    if (dir) {
        var foundIndex = -1;
        for(i1 = byteOffset; i1 < arrLength; i1++)if (read(arr, i1) === read(val, foundIndex === -1 ? 0 : i1 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i1;
            if (i1 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i1 -= i1 - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i1 = byteOffset; i1 >= 0; i1--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i1 + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i1;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 127);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 256))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 256))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 256))val += this[offset + i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 256))val += this[offset + --i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while(++i < byteLength && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while(++i < byteLength && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 55295 && codePoint < 57344) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 255);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"base64-js":"nR26C","ieee754":"ljh7N"}],"nR26C":[function(require,module,exports) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i1 = 0, len1 = code.length; i1 < len1; ++i1){
    lookup[i1] = code[i1];
    revLookup[code.charCodeAt(i1)] = i1;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + '=');
    }
    return parts.join('');
}

},{}],"ljh7N":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"ylvqt":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;
var EE = require('events').EventEmitter;
var inherits = require('inherits');
inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js');
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js');
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.
function Stream() {
    EE.call(this);
}
Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
        if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) source.pause();
        }
    }
    source.on('data', ondata);
    function ondrain() {
        if (source.readable && source.resume) source.resume();
    }
    dest.on('drain', ondrain);
    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === 'function') dest.destroy();
    }
    // don't leave dangling pipes when there are errors.
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, 'error') === 0) throw er; // Unhandled stream error in pipe.
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    // remove all the event listeners that were added.
    function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);
        source.removeListener('end', onend);
        source.removeListener('close', onclose);
        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);
        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);
        dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
};

},{"events":"bHM3D","inherits":"d3hL2","readable-stream/lib/_stream_readable.js":"cOmIG","readable-stream/lib/_stream_writable.js":"8Zkyc","readable-stream/lib/_stream_duplex.js":"gXe2L","readable-stream/lib/_stream_transform.js":"d0v77","readable-stream/lib/_stream_passthrough.js":"dYz8E","readable-stream/lib/internal/streams/end-of-stream.js":"lMiCr","readable-stream/lib/internal/streams/pipeline.js":"l5HmF"}],"bHM3D":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== 'function') throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === 'error';
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === 'function') ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === 'function') // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
        }
    } else if (typeof list !== 'function') {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === 'function') this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === 'function') return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === 'function') return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === 'function') emitter.removeListener('error', errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== 'error') addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === 'function') // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"d3hL2":[function(require,module,exports) {
if (typeof Object.create === 'function') // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"cOmIG":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = require('./internal/streams/stream');
/*</replacement>*/ var Buffer = require('buffer').Buffer;
var OurUint8Array = global.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog('stream');
else debug = function debug() {
};
/*</replacement>*/ var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    'error',
    'close',
    'destroy',
    'pause',
    'resume'
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require('./_stream_duplex');
    options = options || {
    }; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true; // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true; // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy; // has it been destroyed
    this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || require('./_stream_duplex');
    if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex); // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === 'function') this._read = options.read;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
         // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === 'string') {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = '';
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug('readableAddChunk', chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) chunk = _uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            else if (state.destroyed) return false;
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    } // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit('data', chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) er = new ERR_INVALID_ARG_TYPE('chunk', [
        'string',
        'Buffer',
        'Uint8Array'
    ], chunk);
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
}; // backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = '';
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== '') this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
}; // Don't raise the hwm > 1GB
var MAX_HWM = 1073741824;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    } // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n; // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
} // you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
    } else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true; // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true; // call internal read method
        this._read(state.highWaterMark);
        state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit('data', ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug('onEofChunk');
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug('emitReadable', state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug('emitReadable_', state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit('readable');
        state.emittedReadable = false;
    } // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once('end', endFn);
    dest.on('unpipe', onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug('onunpipe');
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug('onend');
        dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug('cleanup'); // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', unpipe);
        src.removeListener('data', ondata);
        cleanedUp = true; // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on('data', ondata);
    function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        debug('dest.write', ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug('false write response, pause', state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
    } // Make sure our error handler is attached before userland ones.
    prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
    }
    dest.once('finish', onfinish);
    function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
    } // tell the dest that it's being piped to
    dest.emit('pipe', src); // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug('pipe resume');
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    }; // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this; // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes; // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this, unpipeInfo);
        return this;
    } // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit('unpipe', this, {
            hasUnpiped: false
        });
        return this;
    } // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit('unpipe', this, unpipeInfo);
    return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === 'data') {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === 'readable') {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug('on readable', state.length, state.reading);
            if (state.length) emitReadable(this);
            else if (!state.reading) process.nextTick(nReadingNextTick, this);
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === 'readable') // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === 'readable' || ev === undefined) // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
function updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount('readable') > 0;
    if (state.resumeScheduled && !state.paused) // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
    else if (self.listenerCount('data') > 0) self.resume();
}
function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug('resume'); // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug('resume', state.reading);
    if (!state.reading) stream.read(0);
    state.resumeScheduled = false;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug('call pause flowing=%j', this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);
    while(state.flowing && stream.read() !== null);
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === 'function') this[i] = (function methodWrap(method) {
        return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
        };
    })(i);
     // proxy certain important events.
    for(var n1 = 0; n1 < kProxyEvents.length; n1++)stream.on(kProxyEvents[n1], this.emit.bind(this, kProxyEvents[n1]));
     // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === 'function') Readable.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === undefined) createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    return createReadableStreamAsyncIterator(this);
};
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) this._readableState.flowing = state;
    }
}); // exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = state.buffer.consume(n, state.decoder);
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug('endReadable', state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
        }
    }
}
if (typeof Symbol === 'function') Readable.from = function(iterable, opts) {
    if (from === undefined) from = require('./internal/streams/from');
    return from(Readable, iterable, opts);
};
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

},{"process":"lDnB8","events":"bHM3D","./internal/streams/stream":"2DxWV","buffer":"bOetu","util":"joWnX","./internal/streams/buffer_list":"m1twv","./internal/streams/destroy":"fTkLZ","./internal/streams/state":"c6Ca1","../errors":"9j4wu","inherits":"d3hL2","./_stream_duplex":"gXe2L","string_decoder/":"vLxWd","./internal/streams/async_iterator":"1SRgg","./internal/streams/from":"6Gblw"}],"lDnB8":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {
};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {
};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {
};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"2DxWV":[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":"bHM3D"}],"joWnX":[function(require,module,exports) {
"use strict";

},{}],"m1twv":[function(require,module,exports) {
'use strict';
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {
        };
        if (i % 2) ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
        else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        else ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var _require = require('buffer'), Buffer = _require.Buffer;
var _require2 = require('util'), inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ (function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return '';
                var p = this.head;
                var ret = '' + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            } // Consumes a specified amount of bytes or characters from the buffered data.
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) // First chunk is a perfect match.
                ret = this.shift();
                else // Result spans more than one buffer.
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            } // Consumes a specified amount of characters from the buffered data.
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            } // Consumes a specified amount of bytes from the buffered data.
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            } // Make sure the linked list only shows the minimal necessary information.
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread({
                }, options, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
})();

},{"buffer":"bOetu","util":"joWnX"}],"fTkLZ":[function(require,module,exports) {
var process = require("process");
'use strict'; // undocumented cb() API, needed for core, not for public API
function destroy(err1, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err1);
        else if (err1) {
            if (!this._writableState) process.nextTick(emitErrorNT, this, err1);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err1);
            }
        }
        return this;
    } // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
     // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err1 || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) process.nextTick(emitErrorAndCloseNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else process.nextTick(emitCloseNT, _this);
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else process.nextTick(emitCloseNT, _this);
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit('close');
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit('error', err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit('error', err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};

},{"process":"lDnB8"}],"c6Ca1":[function(require,module,exports) {
'use strict';
var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : 'highWaterMark';
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    } // Default value
    return state.objectMode ? 16 : 16384;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};

},{"../../../errors":"9j4wu"}],"9j4wu":[function(require,module,exports) {
'use strict';
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
var codes = {
};
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError1 = /*#__PURE__*/ function(_Base) {
        _inheritsLoose(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError;
    }(Base);
    NodeError1.prototype.name = Base.name;
    NodeError1.prototype.code = code;
    codes[code] = NodeError1;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== 'number') start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType('ERR_INVALID_OPT_VALUE', function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
    } else determiner = 'must be';
    var msg;
    if (endsWith(name, ' argument')) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    else {
        var type = includes(name, '.') ? 'property' : 'argument';
        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function(name) {
    return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function(name) {
    return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function(arg) {
    return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],"gXe2L":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
// Allow the keys array to be GC'ed.
var keys1 = objectKeys(Writable.prototype);
for(var v = 0; v < keys1.length; v++){
    var method = keys1[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once('end', onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
}); // the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return; // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
         // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});

},{"process":"lDnB8","./_stream_readable":"cOmIG","./_stream_writable":"8Zkyc","inherits":"d3hL2"}],"8Zkyc":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: require('util-deprecate')
};
/*</replacement>*/ /*<replacement>*/ var Stream = require('./internal/streams/stream');
/*</replacement>*/ var Buffer = require('buffer').Buffer;
var OurUint8Array = global.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {
}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require('./_stream_duplex');
    options = options || {
    }; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called
    this.finalCalled = false; // drain event flag.
    this.needDrain = false; // at the start of calling end()
    this.ending = false; // when end() has been called, and returned
    this.ended = false; // when 'finish' is emitted
    this.finished = false; // has it been destroyed
    this.destroyed = false; // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0; // a flag to see when we're in the middle of a write.
    this.writing = false; // when true all writes will be buffered until .uncork() call
    this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true; // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    }; // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null; // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false; // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy; // count buffered requests
    this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", 'DEP0003')
        });
    } catch (_) {
    }
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else realHasInstance = function realHasInstance(object) {
    return object instanceof this;
};
function Writable(options) {
    Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex); // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === 'function') this._write = options.write;
        if (typeof options.writev === 'function') this._writev = options.writev;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
        if (typeof options.final === 'function') this._final = options.final;
    }
    Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) er = new ERR_STREAM_NULL_VALUES();
    else if (typeof chunk !== 'string' && !state.objectMode) er = new ERR_INVALID_ARG_TYPE('chunk', [
        'string',
        'Buffer'
    ], chunk);
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);
    if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = 'buffer';
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== 'function') cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!([
        'hex',
        'utf8',
        'utf-8',
        'ascii',
        'binary',
        'base64',
        'ucs2',
        'ucs-2',
        'utf16le',
        'utf-16le',
        'raw'
    ].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = 'buffer';
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er); // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er); // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
        if (sync) process.nextTick(afterWrite, stream, state, finished, cb);
        else afterWrite(stream, state, finished, cb);
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
    }
} // if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else state.corkedRequestsFree = new CorkedRequest(state);
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) break;
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    } // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) errorOrDestroy(stream, err);
        state.prefinished = true;
        stream.emit('prefinish');
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === 'function' && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit('prefinish');
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit('finish');
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) stream.destroy();
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    } // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) return false;
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) return;
         // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};

},{"process":"lDnB8","util-deprecate":"bfjXI","./internal/streams/stream":"2DxWV","buffer":"bOetu","./internal/streams/destroy":"fTkLZ","./internal/streams/state":"c6Ca1","../errors":"9j4wu","inherits":"d3hL2","./_stream_duplex":"gXe2L"}],"bfjXI":[function(require,module,exports) {
var global = arguments[3];
/**
 * Module exports.
 */ module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */ function deprecate(fn, msg) {
    if (config('noDeprecation')) return fn;
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config('throwDeprecation')) throw new Error(msg);
            else if (config('traceDeprecation')) console.trace(msg);
            else console.warn(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */ function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
        if (!global.localStorage) return false;
    } catch (_) {
        return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === 'true';
}

},{}],"vLxWd":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
/*<replacement>*/ var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = '' + encoding;
    switch(encoding && encoding.toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while(true)switch(enc){
        case 'utf8':
        case 'utf-8':
            return 'utf8';
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return 'utf16le';
        case 'latin1':
        case 'binary':
            return 'latin1';
        case 'base64':
        case 'ascii':
        case 'hex':
            return enc;
        default:
            if (retried) return; // undefined
            enc = ('' + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
            self.lastNeed = 1;
            return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
                self.lastNeed = 2;
                return '\ufffd';
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + '\ufffd';
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":"hZf9b"}],"hZf9b":[function(require,module,exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = require('buffer');
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') throw new TypeError('Argument must not be a number');
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') throw new TypeError('Argument must be a number');
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') throw new TypeError('Argument must be a number');
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') throw new TypeError('Argument must be a number');
    return buffer.SlowBuffer(size);
};

},{"buffer":"bOetu"}],"1SRgg":[function(require,module,exports) {
var process = require("process");
'use strict';
var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read(); // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) return Promise.reject(error);
        if (this[kEnded]) return Promise.resolve(createIterResult(undefined, true));
        if (this[kStream].destroyed) // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function(resolve, reject) {
            process.nextTick(function() {
                if (_this[kError]) reject(_this[kError]);
                else resolve(createIterResult(undefined, true));
            });
        });
         // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) promise = new Promise(wrapForNext(lastPromise, this));
        else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) return Promise.resolve(createIterResult(data, false));
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {
    }, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
            var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on('readable', onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;

},{"process":"lDnB8","./end-of-stream":"lMiCr"}],"lMiCr":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';
var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        callback.apply(this, args);
    };
}
function noop() {
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
    if (typeof opts === 'function') return eos(stream, null, opts);
    if (!opts) opts = {
    };
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on('finish', onfinish);
    };
    if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();
        else stream.on('request', onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
    }
    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false) stream.on('error', onerror);
    stream.on('close', onclose);
    return function() {
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
    };
}
module.exports = eos;

},{"../../../errors":"9j4wu"}],"6Gblw":[function(require,module,exports) {
module.exports = function() {
    throw new Error('Readable.from is not available in the browser');
};

},{}],"d0v77":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';
module.exports = Transform;
var _require$codes = require('../errors').codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) return this.emit('error', new ERR_MULTIPLE_CALLBACK());
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    }; // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
    } // When the writable side finishes, then flush out anything remaining.
    this.on('prefinish', prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === 'function' && !this._readableState.destroyed) this._flush(function(er, data) {
        done(_this, er, data);
    });
    else done(this, null, null);
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
};
Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er) return stream.emit('error', er);
    if (data != null) stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}

},{"../errors":"9j4wu","./_stream_duplex":"gXe2L","inherits":"d3hL2"}],"dYz8E":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';
module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};

},{"./_stream_transform":"d0v77","inherits":"d3hL2"}],"l5HmF":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';
var eos;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = require('../../../errors').codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on('close', function() {
        closed = true;
    });
    if (eos === undefined) eos = require('./end-of-stream');
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true; // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === 'function') return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED('pipe'));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== 'function') return noop;
    return streams.pop();
}
function pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++)streams[_key] = arguments[_key];
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new ERR_MISSING_ARGS('streams');
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;

},{"../../../errors":"9j4wu","./end-of-stream":"lMiCr"}],"hdwAm":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    exports.stripBOM = function(str) {
        if (str[0] === '\uFEFF') return str.substring(1);
        else return str;
    };
}).call(this);

},{}],"ckxC8":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports.normalize = function(str) {
        return str.toLowerCase();
    };
    exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, '');
    };
    exports.parseNumbers = function(str) {
        if (!isNaN(str)) str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        return str;
    };
    exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) str = str.toLowerCase() === 'true';
        return str;
    };
}).call(this);

},{}],"59lXe":[function(require,module,exports) {
var global = arguments[3];
var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply;
// DOM APIs, for completeness
exports.setTimeout = function() {
    return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
    return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function(timeout) {
    if (timeout) timeout.close();
};
function Timeout(id, clearFn) {
    this._id = id;
    this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {
};
Timeout.prototype.close = function() {
    this._clearFn.call(scope, this._id);
};
// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = msecs;
};
exports.unenroll = function(item) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = -1;
};
exports._unrefActive = exports.active = function(item) {
    clearTimeout(item._idleTimeoutId);
    var msecs = item._idleTimeout;
    if (msecs >= 0) item._idleTimeoutId = setTimeout(function onTimeout() {
        if (item._onTimeout) item._onTimeout();
    }, msecs);
};
// setimmediate attaches itself to the global object
require("setimmediate");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;

},{"setimmediate":"jbb8I"}],"jbb8I":[function(require,module,exports) {
var process = require("process");
var global1 = arguments[3];
(function(global, undefined) {
    if (global.setImmediate) return;
    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {
    };
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;
    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") callback = new Function("" + callback);
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for(var i = 0; i < args.length; i++)args[i] = arguments[i + 1];
        // Store and register the task
        var task = {
            callback: callback,
            args: args
        };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }
    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }
    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch(args.length){
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }
    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
        // "too much recursion" error.
        setTimeout(runIfPresent, 0, handle);
        else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally{
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }
    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function() {
                runIfPresent(handle);
            });
        };
    }
    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }
    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) runIfPresent(+event.data.slice(messagePrefix.length));
        };
        if (global.addEventListener) global.addEventListener("message", onGlobalMessage, false);
        else global.attachEvent("onmessage", onGlobalMessage);
        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }
    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };
        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }
    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function() {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }
    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }
    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
    // Don't get fooled by e.g. browserify environments.
    if (({
    }).toString.call(global.process) === "[object process]") // For Node.js before 0.9
    installNextTickImplementation();
    else if (canUsePostMessage()) // For non-IE10 modern browsers
    installPostMessageImplementation();
    else if (global.MessageChannel) // For web workers, where supported
    installMessageChannelImplementation();
    else if (doc && "onreadystatechange" in doc.createElement("script")) // For IE 6–8
    installReadyStateChangeImplementation();
    else // For older browsers
    installSetTimeoutImplementation();
    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global1 === "undefined" ? this : global1 : self);

},{"process":"lDnB8"}],"a22RV":[function(require,module,exports) {
/*jslint node:true */ var xml2js = require('./xml2js');
var xml2json = require('./xml2json');
var js2xml = require('./js2xml');
var json2xml = require('./json2xml');
module.exports = {
    xml2js: xml2js,
    xml2json: xml2json,
    js2xml: js2xml,
    json2xml: json2xml
};

},{"./xml2js":"9phWB","./xml2json":"7o1rr","./js2xml":"fQpG1","./json2xml":"jFMMv"}],"9phWB":[function(require,module,exports) {
var sax = require('sax');
var expat /*= require('node-expat');*/  = {
    on: function() {
    },
    parse: function() {
    }
};
var helper = require('./options-helper');
var isArray = require('./array-helper').isArray;
var options;
var pureJsParser = true;
var currentElement;
function validateOptions(userOptions) {
    options = helper.copyOptions(userOptions);
    helper.ensureFlagExists('ignoreDeclaration', options);
    helper.ensureFlagExists('ignoreInstruction', options);
    helper.ensureFlagExists('ignoreAttributes', options);
    helper.ensureFlagExists('ignoreText', options);
    helper.ensureFlagExists('ignoreComment', options);
    helper.ensureFlagExists('ignoreCdata', options);
    helper.ensureFlagExists('ignoreDoctype', options);
    helper.ensureFlagExists('compact', options);
    helper.ensureFlagExists('alwaysChildren', options);
    helper.ensureFlagExists('addParent', options);
    helper.ensureFlagExists('trim', options);
    helper.ensureFlagExists('nativeType', options);
    helper.ensureFlagExists('nativeTypeAttributes', options);
    helper.ensureFlagExists('sanitize', options);
    helper.ensureFlagExists('instructionHasAttributes', options);
    helper.ensureFlagExists('captureSpacesBetweenElements', options);
    helper.ensureAlwaysArrayExists(options);
    helper.ensureKeyExists('declaration', options);
    helper.ensureKeyExists('instruction', options);
    helper.ensureKeyExists('attributes', options);
    helper.ensureKeyExists('text', options);
    helper.ensureKeyExists('comment', options);
    helper.ensureKeyExists('cdata', options);
    helper.ensureKeyExists('doctype', options);
    helper.ensureKeyExists('type', options);
    helper.ensureKeyExists('name', options);
    helper.ensureKeyExists('elements', options);
    helper.ensureKeyExists('parent', options);
    helper.checkFnExists('doctype', options);
    helper.checkFnExists('instruction', options);
    helper.checkFnExists('cdata', options);
    helper.checkFnExists('comment', options);
    helper.checkFnExists('text', options);
    helper.checkFnExists('instructionName', options);
    helper.checkFnExists('elementName', options);
    helper.checkFnExists('attributeName', options);
    helper.checkFnExists('attributeValue', options);
    helper.checkFnExists('attributes', options);
    return options;
}
function nativeType(value) {
    var nValue = Number(value);
    if (!isNaN(nValue)) return nValue;
    var bValue = value.toLowerCase();
    if (bValue === 'true') return true;
    else if (bValue === 'false') return false;
    return value;
}
function addField(type, value) {
    var key;
    if (options.compact) {
        if (!currentElement[options[type + 'Key']] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)) currentElement[options[type + 'Key']] = [];
        if (currentElement[options[type + 'Key']] && !isArray(currentElement[options[type + 'Key']])) currentElement[options[type + 'Key']] = [
            currentElement[options[type + 'Key']]
        ];
        if (type + 'Fn' in options && typeof value === 'string') value = options[type + 'Fn'](value, currentElement);
        if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {
            for(key in value)if (value.hasOwnProperty(key)) {
                if ('instructionFn' in options) value[key] = options.instructionFn(value[key], key, currentElement);
                else {
                    var temp = value[key];
                    delete value[key];
                    value[options.instructionNameFn(key, temp, currentElement)] = temp;
                }
            }
        }
        if (isArray(currentElement[options[type + 'Key']])) currentElement[options[type + 'Key']].push(value);
        else currentElement[options[type + 'Key']] = value;
    } else {
        if (!currentElement[options.elementsKey]) currentElement[options.elementsKey] = [];
        var element = {
        };
        element[options.typeKey] = type;
        if (type === 'instruction') {
            for(key in value){
                if (value.hasOwnProperty(key)) break;
            }
            element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;
            if (options.instructionHasAttributes) {
                element[options.attributesKey] = value[key][options.attributesKey];
                if ('instructionFn' in options) element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
            } else {
                if ('instructionFn' in options) value[key] = options.instructionFn(value[key], key, currentElement);
                element[options.instructionKey] = value[key];
            }
        } else {
            if (type + 'Fn' in options) value = options[type + 'Fn'](value, currentElement);
            element[options[type + 'Key']] = value;
        }
        if (options.addParent) element[options.parentKey] = currentElement;
        currentElement[options.elementsKey].push(element);
    }
}
function manipulateAttributes(attributes) {
    if ('attributesFn' in options && attributes) attributes = options.attributesFn(attributes, currentElement);
    if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {
        var key;
        for(key in attributes)if (attributes.hasOwnProperty(key)) {
            if (options.trim) attributes[key] = attributes[key].trim();
            if (options.nativeTypeAttributes) attributes[key] = nativeType(attributes[key]);
            if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
            if ('attributeNameFn' in options) {
                var temp = attributes[key];
                delete attributes[key];
                attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
            }
        }
    }
    return attributes;
}
function onInstruction(instruction) {
    var attributes = {
    };
    if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {
        var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
        var match;
        while((match = attrsRegExp.exec(instruction.body)) !== null)attributes[match[1]] = match[2] || match[3] || match[4];
        attributes = manipulateAttributes(attributes);
    }
    if (instruction.name.toLowerCase() === 'xml') {
        if (options.ignoreDeclaration) return;
        currentElement[options.declarationKey] = {
        };
        if (Object.keys(attributes).length) currentElement[options.declarationKey][options.attributesKey] = attributes;
        if (options.addParent) currentElement[options.declarationKey][options.parentKey] = currentElement;
    } else {
        if (options.ignoreInstruction) return;
        if (options.trim) instruction.body = instruction.body.trim();
        var value = {
        };
        if (options.instructionHasAttributes && Object.keys(attributes).length) {
            value[instruction.name] = {
            };
            value[instruction.name][options.attributesKey] = attributes;
        } else value[instruction.name] = instruction.body;
        addField('instruction', value);
    }
}
function onStartElement(name, attributes) {
    var element;
    if (typeof name === 'object') {
        attributes = name.attributes;
        name = name.name;
    }
    attributes = manipulateAttributes(attributes);
    if ('elementNameFn' in options) name = options.elementNameFn(name, currentElement);
    if (options.compact) {
        element = {
        };
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
            element[options.attributesKey] = {
            };
            var key;
            for(key in attributes)if (attributes.hasOwnProperty(key)) element[options.attributesKey][key] = attributes[key];
        }
        if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) currentElement[name] = [];
        if (currentElement[name] && !isArray(currentElement[name])) currentElement[name] = [
            currentElement[name]
        ];
        if (isArray(currentElement[name])) currentElement[name].push(element);
        else currentElement[name] = element;
    } else {
        if (!currentElement[options.elementsKey]) currentElement[options.elementsKey] = [];
        element = {
        };
        element[options.typeKey] = 'element';
        element[options.nameKey] = name;
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) element[options.attributesKey] = attributes;
        if (options.alwaysChildren) element[options.elementsKey] = [];
        currentElement[options.elementsKey].push(element);
    }
    element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent
    currentElement = element;
}
function onText(text) {
    if (options.ignoreText) return;
    if (!text.trim() && !options.captureSpacesBetweenElements) return;
    if (options.trim) text = text.trim();
    if (options.nativeType) text = nativeType(text);
    if (options.sanitize) text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    addField('text', text);
}
function onComment(comment) {
    if (options.ignoreComment) return;
    if (options.trim) comment = comment.trim();
    addField('comment', comment);
}
function onEndElement(name) {
    var parentElement = currentElement[options.parentKey];
    if (!options.addParent) delete currentElement[options.parentKey];
    currentElement = parentElement;
}
function onCdata(cdata) {
    if (options.ignoreCdata) return;
    if (options.trim) cdata = cdata.trim();
    addField('cdata', cdata);
}
function onDoctype(doctype) {
    if (options.ignoreDoctype) return;
    doctype = doctype.replace(/^ /, '');
    if (options.trim) doctype = doctype.trim();
    addField('doctype', doctype);
}
function onError(error) {
    error.note = error; //console.error(error);
}
module.exports = function(xml, userOptions) {
    var parser = pureJsParser ? sax.parser(true, {
    }) : parser = new expat.Parser('UTF-8');
    var result = {
    };
    currentElement = result;
    options = validateOptions(userOptions);
    if (pureJsParser) {
        parser.opt = {
            strictEntities: true
        };
        parser.onopentag = onStartElement;
        parser.ontext = onText;
        parser.oncomment = onComment;
        parser.onclosetag = onEndElement;
        parser.onerror = onError;
        parser.oncdata = onCdata;
        parser.ondoctype = onDoctype;
        parser.onprocessinginstruction = onInstruction;
    } else {
        parser.on('startElement', onStartElement);
        parser.on('text', onText);
        parser.on('comment', onComment);
        parser.on('endElement', onEndElement);
        parser.on('error', onError);
    //parser.on('startCdata', onStartCdata);
    //parser.on('endCdata', onEndCdata);
    //parser.on('entityDecl', onEntityDecl);
    }
    if (pureJsParser) parser.write(xml).close();
    else {
        if (!parser.parse(xml)) throw new Error('XML parsing error: ' + parser.getError());
    }
    if (result[options.elementsKey]) {
        var temp = result[options.elementsKey];
        delete result[options.elementsKey];
        result[options.elementsKey] = temp;
        delete result.text;
    }
    return result;
};

},{"sax":"gBT5g","./options-helper":"jReS5","./array-helper":"9HMGN"}],"jReS5":[function(require,module,exports) {
var isArray = require('./array-helper').isArray;
module.exports = {
    copyOptions: function(options) {
        var key, copy = {
        };
        for(key in options)if (options.hasOwnProperty(key)) copy[key] = options[key];
        return copy;
    },
    ensureFlagExists: function(item, options) {
        if (!(item in options) || typeof options[item] !== 'boolean') options[item] = false;
    },
    ensureSpacesExists: function(options) {
        if (!('spaces' in options) || typeof options.spaces !== 'number' && typeof options.spaces !== 'string') options.spaces = 0;
    },
    ensureAlwaysArrayExists: function(options) {
        if (!('alwaysArray' in options) || typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray)) options.alwaysArray = false;
    },
    ensureKeyExists: function(key, options) {
        if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') options[key + 'Key'] = options.compact ? '_' + key : key;
    },
    checkFnExists: function(key, options) {
        return key + 'Fn' in options;
    }
};

},{"./array-helper":"9HMGN"}],"9HMGN":[function(require,module,exports) {
module.exports = {
    isArray: function(value) {
        if (Array.isArray) return Array.isArray(value);
        // fallback for older browsers like  IE 8
        return Object.prototype.toString.call(value) === '[object Array]';
    }
};

},{}],"7o1rr":[function(require,module,exports) {
var helper = require('./options-helper');
var xml2js = require('./xml2js');
function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureSpacesExists(options);
    return options;
}
module.exports = function(xml, userOptions) {
    var options, js, json, parentKey;
    options = validateOptions(userOptions);
    js = xml2js(xml, options);
    parentKey = 'compact' in options && options.compact ? '_parent' : 'parent';
    // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this
    if ('addParent' in options && options.addParent) json = JSON.stringify(js, function(k, v) {
        return k === parentKey ? '_' : v;
    }, options.spaces);
    else json = JSON.stringify(js, null, options.spaces);
    return json.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
};

},{"./options-helper":"jReS5","./xml2js":"9phWB"}],"fQpG1":[function(require,module,exports) {
var helper = require('./options-helper');
var isArray = require('./array-helper').isArray;
var currentElement, currentElementName;
function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureFlagExists('ignoreDeclaration', options);
    helper.ensureFlagExists('ignoreInstruction', options);
    helper.ensureFlagExists('ignoreAttributes', options);
    helper.ensureFlagExists('ignoreText', options);
    helper.ensureFlagExists('ignoreComment', options);
    helper.ensureFlagExists('ignoreCdata', options);
    helper.ensureFlagExists('ignoreDoctype', options);
    helper.ensureFlagExists('compact', options);
    helper.ensureFlagExists('indentText', options);
    helper.ensureFlagExists('indentCdata', options);
    helper.ensureFlagExists('indentAttributes', options);
    helper.ensureFlagExists('indentInstruction', options);
    helper.ensureFlagExists('fullTagEmptyElement', options);
    helper.ensureFlagExists('noQuotesForNativeAttributes', options);
    helper.ensureSpacesExists(options);
    if (typeof options.spaces === 'number') options.spaces = Array(options.spaces + 1).join(' ');
    helper.ensureKeyExists('declaration', options);
    helper.ensureKeyExists('instruction', options);
    helper.ensureKeyExists('attributes', options);
    helper.ensureKeyExists('text', options);
    helper.ensureKeyExists('comment', options);
    helper.ensureKeyExists('cdata', options);
    helper.ensureKeyExists('doctype', options);
    helper.ensureKeyExists('type', options);
    helper.ensureKeyExists('name', options);
    helper.ensureKeyExists('elements', options);
    helper.checkFnExists('doctype', options);
    helper.checkFnExists('instruction', options);
    helper.checkFnExists('cdata', options);
    helper.checkFnExists('comment', options);
    helper.checkFnExists('text', options);
    helper.checkFnExists('instructionName', options);
    helper.checkFnExists('elementName', options);
    helper.checkFnExists('attributeName', options);
    helper.checkFnExists('attributeValue', options);
    helper.checkFnExists('attributes', options);
    helper.checkFnExists('fullTagEmptyElement', options);
    return options;
}
function writeIndentation(options, depth, firstLine) {
    return (!firstLine && options.spaces ? '\n' : '') + Array(depth + 1).join(options.spaces);
}
function writeAttributes(attributes, options, depth) {
    if (options.ignoreAttributes) return '';
    if ('attributesFn' in options) attributes = options.attributesFn(attributes, currentElementName, currentElement);
    var key, attr, attrName, quote, result = [];
    for(key in attributes)if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {
        quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '"';
        attr = '' + attributes[key]; // ensure number and boolean are converted to String
        attr = attr.replace(/"/g, '&quot;');
        attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
        result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : ' ');
        result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
    }
    if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) result.push(writeIndentation(options, depth, false));
    return result.join('');
}
function writeDeclaration(declaration, options, depth) {
    currentElement = declaration;
    currentElementName = 'xml';
    return options.ignoreDeclaration ? '' : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';
}
function writeInstruction(instruction, options, depth) {
    if (options.ignoreInstruction) return '';
    var key;
    for(key in instruction){
        if (instruction.hasOwnProperty(key)) break;
    }
    var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
    if (typeof instruction[key] === 'object') {
        currentElement = instruction;
        currentElementName = instructionName;
        return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';
    } else {
        var instructionValue = instruction[key] ? instruction[key] : '';
        if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
        return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';
    }
}
function writeComment(comment, options) {
    return options.ignoreComment ? '' : '<\!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';
}
function writeCdata(cdata, options) {
    return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';
}
function writeDoctype(doctype, options) {
    return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';
}
function writeText(text, options) {
    if (options.ignoreText) return '';
    text = '' + text; // ensure Number and Boolean are converted to String
    text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization
    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;
}
function hasContent(element, options) {
    var i;
    if (element.elements && element.elements.length) for(i = 0; i < element.elements.length; ++i)switch(element.elements[i][options.typeKey]){
        case 'text':
            if (options.indentText) return true;
            break; // skip to next key
        case 'cdata':
            if (options.indentCdata) return true;
            break; // skip to next key
        case 'instruction':
            if (options.indentInstruction) return true;
            break; // skip to next key
        case 'doctype':
        case 'comment':
        case 'element':
            return true;
        default:
            return true;
    }
    return false;
}
function writeElement(element, options, depth) {
    currentElement = element;
    currentElementName = element.name;
    var xml = [], elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;
    xml.push('<' + elementName);
    if (element[options.attributesKey]) xml.push(writeAttributes(element[options.attributesKey], options, depth));
    var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
    if (!withClosingTag) {
        if ('fullTagEmptyElementFn' in options) withClosingTag = options.fullTagEmptyElementFn(element.name, element);
        else withClosingTag = options.fullTagEmptyElement;
    }
    if (withClosingTag) {
        xml.push('>');
        if (element[options.elementsKey] && element[options.elementsKey].length) {
            xml.push(writeElements(element[options.elementsKey], options, depth + 1));
            currentElement = element;
            currentElementName = element.name;
        }
        xml.push(options.spaces && hasContent(element, options) ? '\n' + Array(depth + 1).join(options.spaces) : '');
        xml.push('</' + elementName + '>');
    } else xml.push('/>');
    return xml.join('');
}
function writeElements(elements, options, depth, firstLine) {
    return elements.reduce(function(xml, element) {
        var indent = writeIndentation(options, depth, firstLine && !xml);
        switch(element.type){
            case 'element':
                return xml + indent + writeElement(element, options, depth);
            case 'comment':
                return xml + indent + writeComment(element[options.commentKey], options);
            case 'doctype':
                return xml + indent + writeDoctype(element[options.doctypeKey], options);
            case 'cdata':
                return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);
            case 'text':
                return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);
            case 'instruction':
                var instruction = {
                };
                instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
                return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);
        }
    }, '');
}
function hasContentCompact(element, options, anyContent) {
    var key;
    for(key in element)if (element.hasOwnProperty(key)) switch(key){
        case options.parentKey:
        case options.attributesKey:
            break; // skip to next key
        case options.textKey:
            if (options.indentText || anyContent) return true;
            break; // skip to next key
        case options.cdataKey:
            if (options.indentCdata || anyContent) return true;
            break; // skip to next key
        case options.instructionKey:
            if (options.indentInstruction || anyContent) return true;
            break; // skip to next key
        case options.doctypeKey:
        case options.commentKey:
            return true;
        default:
            return true;
    }
    return false;
}
function writeElementCompact(element, name, options, depth, indent) {
    currentElement = element;
    currentElementName = name;
    var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;
    if (typeof element === 'undefined' || element === null || element === '') return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';
    var xml = [];
    if (name) {
        xml.push('<' + elementName);
        if (typeof element !== 'object') {
            xml.push('>' + writeText(element, options) + '</' + elementName + '>');
            return xml.join('');
        }
        if (element[options.attributesKey]) xml.push(writeAttributes(element[options.attributesKey], options, depth));
        var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
        if (!withClosingTag) {
            if ('fullTagEmptyElementFn' in options) withClosingTag = options.fullTagEmptyElementFn(name, element);
            else withClosingTag = options.fullTagEmptyElement;
        }
        if (withClosingTag) xml.push('>');
        else {
            xml.push('/>');
            return xml.join('');
        }
    }
    xml.push(writeElementsCompact(element, options, depth + 1, false));
    currentElement = element;
    currentElementName = name;
    if (name) xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');
    return xml.join('');
}
function writeElementsCompact(element, options, depth, firstLine) {
    var i, key, nodes, xml = [];
    for(key in element)if (element.hasOwnProperty(key)) {
        nodes = isArray(element[key]) ? element[key] : [
            element[key]
        ];
        for(i = 0; i < nodes.length; ++i){
            switch(key){
                case options.declarationKey:
                    xml.push(writeDeclaration(nodes[i], options, depth));
                    break;
                case options.instructionKey:
                    xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth));
                    break;
                case options.attributesKey:
                case options.parentKey:
                    break; // skip
                case options.textKey:
                    xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options));
                    break;
                case options.cdataKey:
                    xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options));
                    break;
                case options.doctypeKey:
                    xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
                    break;
                case options.commentKey:
                    xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
                    break;
                default:
                    xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
            }
            firstLine = firstLine && !xml.length;
        }
    }
    return xml.join('');
}
module.exports = function(js, options) {
    options = validateOptions(options);
    var xml = [];
    currentElement = js;
    currentElementName = '_root_';
    if (options.compact) xml.push(writeElementsCompact(js, options, 0, true));
    else {
        if (js[options.declarationKey]) xml.push(writeDeclaration(js[options.declarationKey], options, 0));
        if (js[options.elementsKey] && js[options.elementsKey].length) xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
    }
    return xml.join('');
};

},{"./options-helper":"jReS5","./array-helper":"9HMGN"}],"jFMMv":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var js2xml = require('./js2xml.js');
module.exports = function(json, options) {
    if (json instanceof Buffer) json = json.toString();
    var js = null;
    if (typeof json === 'string') try {
        js = JSON.parse(json);
    } catch (e) {
        throw new Error('The JSON structure is invalid');
    }
    else js = json;
    return js2xml(js, options);
};

},{"buffer":"bOetu","./js2xml.js":"fQpG1"}],"c5U8Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PropertyType", ()=>PropertyType
);
parcelHelpers.export(exports, "Graph", ()=>Graph
);
var _underscore = require("underscore");
var _underscoreDefault = parcelHelpers.interopDefault(_underscore);
var _graphProperties = require("./graph_properties");
const INIT_VERTICES = [
    {
        id: 0
    },
    {
        id: 1
    },
    {
        id: 2
    },
    {
        id: 3
    },
    {
        id: 4
    }, 
];
const INIT_EDGES = [
    {
        id: 0,
        source: 0,
        target: 1
    },
    {
        id: 1,
        source: 0,
        target: 2
    },
    {
        id: 2,
        source: 0,
        target: 3
    },
    {
        id: 3,
        source: 0,
        target: 4
    },
    {
        id: 4,
        source: 1,
        target: 2
    },
    {
        id: 5,
        source: 1,
        target: 3
    },
    {
        id: 6,
        source: 1,
        target: 4
    },
    {
        id: 7,
        source: 2,
        target: 3
    },
    {
        id: 8,
        source: 2,
        target: 4
    },
    {
        id: 9,
        source: 3,
        target: 4
    }, 
];
const PropertyType = {
    GROUPS: "GROUPS",
    ADJACENCY_MATRIX: "ADJACENCY_MATRIX",
    TRIVIAL: "TRIVIAL",
    COMPLETE_GRAPH: "COMPLETE_GRAPH",
    MIN_DEGREE: "MIN_DEGREE",
    MAX_DEGREE: "MAX_DEGREE",
    REGULAR_GRAPH: "REGULAR_GRAPH",
    BIPARTITE: "BIPARTITE",
    CHROMATIC_COLOR: "CHROMATIC_COLOR",
    COLORING: "COLORING",
    CYCLES: "CYCLES",
    TREES: "TREES",
    COMPONENTS: "COMPONENTS"
};
class Graph {
    graphVertices = INIT_VERTICES;
    graphEdges = INIT_EDGES;
    propertiesToShow = [];
    chromaticNumber;
    // Methods
    restartGraph;
    toggleColors;
    toggleVertexId;
    // utils
    isEdgeOfVertex = (vertex, edge)=>{
        // console.log("isEdgeOfVertex", { vertex, edge, includes: vertex.edges.includes(edge) })
        return (vertex.id == edge.source.id || vertex.id == edge.target.id) && (vertex.edges == null || !vertex.edges.map((it)=>it.source
        ).includes(edge) || !vertex.edges.map((it)=>it.target
        ).includes(edge));
    };
    // mappers
    mapNodeToVertex = (node)=>({
            id: node['id'],
            degree: 0,
            edges: []
        })
    ;
    mapLinkToEdge = (link)=>({
            id: link['id'],
            source: link['source'],
            target: link['target']
        })
    ;
    addEdge(link) {
        // console.log("addEdge", { link, graphVertices: this.graphVertices });
        var newEdge = this.mapLinkToEdge(link);
        this.graphEdges = [
            ...this.graphEdges,
            newEdge, 
        ];
        this.graphVertices = this.graphVertices.map((it)=>this.isEdgeOfVertex(it, newEdge) ? {
                ...it,
                degree: it.degree + 1,
                edges: [
                    ...it.edges || [],
                    newEdge
                ]
            } : it
        );
    // console.log("addEdge end", { newEdge, graphEdges: this.graphEdges, graphVertices: this.graphVertices });
    }
    // Main methods
    showVertexInfo(node) {
        if (window.div.style("opacity") > 0 && window.div.attr("id") == node.id) return;
        var vertex1 = this.graphVertices.find((vertex)=>vertex["id"] == node["id"]
        );
        window.div.html(_graphProperties.getVertexId(vertex1) + _graphProperties.getVertexDegree(vertex1) + _graphProperties.getVertexNeighborhood(vertex1)).attr("id", function() {
            return vertex1.id.toString();
        }).style("margin-left", node.x + 20 + "px").style("margin-top", node.y - 12 + "px");
        MathJax.Hub.Queue([
            "Typeset",
            MathJax.Hub
        ]);
        window.div.transition().duration(200).style("z-index", 0).style("opacity", 0.98);
    }
    hideVertexInfo() {
        window.div.transition().duration(200).style("z-index", -1).style("opacity", 0);
    }
    hasProperty(property) {
        return this.propertiesToShow.find((it)=>it == property
        );
    }
    showMathJaxOutput(content, componentId) {
        try {
            if (content.length > 0) {
                document.getElementById(componentId + "-card").classList.remove("output-card-display");
                document.getElementById(componentId).textContent = content;
                if (MathJax != null) MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub
                ]);
            } else {
                document.getElementById(componentId + "-card").classList.add("output-card-display");
                document.getElementById(componentId).textContent = content;
                if (MathJax != null) MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub
                ]);
            }
        } catch (e) {
        // 
        }
    }
    showGraphInfo() {
        var contentsToShow1 = "";
        if (this.hasProperty(PropertyType.GROUPS) || this.hasProperty(PropertyType.ADJACENCY_MATRIX) || this.hasProperty(PropertyType.COMPLETE_GRAPH) || this.hasProperty(PropertyType.TRIVIAL)) contentsToShow1 += _graphProperties.sectionHeader("Primeiros conceitos");
        if (this.hasProperty(PropertyType.GROUPS)) contentsToShow1 += _graphProperties.showGroups(this.graphVertices, this.graphEdges);
        if (this.hasProperty(PropertyType.ADJACENCY_MATRIX)) contentsToShow1 += _graphProperties.showAdjacencyMatrix();
        if (this.hasProperty(PropertyType.TRIVIAL)) contentsToShow1 += _graphProperties.showTrivialGraph();
        if (this.hasProperty(PropertyType.COMPLETE_GRAPH)) contentsToShow1 += _graphProperties.showCompleteGraph();
        this.showMathJaxOutput(contentsToShow1, "output-groups");
        var contentsToShow2 = "";
        if (this.hasProperty(PropertyType.MIN_DEGREE) || this.hasProperty(PropertyType.MAX_DEGREE) || this.hasProperty(PropertyType.REGULAR_GRAPH)) contentsToShow2 += _graphProperties.sectionHeader("Grau");
        if (this.hasProperty(PropertyType.MIN_DEGREE)) contentsToShow2 += _graphProperties.showGraphMinDegree();
        if (this.hasProperty(PropertyType.MAX_DEGREE)) contentsToShow2 += _graphProperties.showGraphMaxDegree();
        if (this.hasProperty(PropertyType.REGULAR_GRAPH)) contentsToShow2 += _graphProperties.showGraphRegular();
        this.showMathJaxOutput(contentsToShow2, "output-degree");
        var contentsToShow3 = "";
        if (this.hasProperty(PropertyType.BIPARTITE) || this.hasProperty(PropertyType.CHROMATIC_COLOR) || this.hasProperty(PropertyType.COLORING)) contentsToShow3 += _graphProperties.sectionHeader("Coloração/multipartição");
        else _graphProperties.resetColoring(this.graphVertices);
        if (this.hasProperty(PropertyType.BIPARTITE)) {
            _graphProperties.greedyColoring(this.graphVertices);
            contentsToShow3 += _graphProperties.showBiparte(window.graph.chromaticNumber == 2);
        }
        if (this.hasProperty(PropertyType.CHROMATIC_COLOR)) {
            _graphProperties.greedyColoring(this.graphVertices);
            contentsToShow3 += _graphProperties.showChromaticNumber(window.graph.chromaticNumber);
        }
        // if (this.hasProperty(PropertyType.COLORING)) {
        //     GraphProperties.greedyColoring(this.graphVertices);
        //     contentsToShow3 += GraphProperties.showBiparte(window.graph.chromaticNumber == 2);
        //     contentsToShow3 += GraphProperties.showChromaticNumber(window.graph.chromaticNumber);
        // } else {
        //     GraphProperties.resetColoring(this.graphVertices);
        // }
        this.showMathJaxOutput(contentsToShow3, "output-coloring");
        var contentsToShow4 = "";
        if (this.hasProperty(PropertyType.CYCLES)) contentsToShow4 += _graphProperties.sectionHeader("Ciclos");
        if (this.hasProperty(PropertyType.CYCLES)) contentsToShow4 += _graphProperties.showCycles();
        this.showMathJaxOutput(contentsToShow4, "output-cycles");
        var contentsToShow5 = "";
        if (this.hasProperty(PropertyType.TREES)) contentsToShow5 += _graphProperties.sectionHeader("Árvores");
        if (this.hasProperty(PropertyType.TREES)) contentsToShow5 += _graphProperties.showTrees();
        this.showMathJaxOutput(contentsToShow5, "output-trees");
        var contentsToShow6 = "";
        if (this.hasProperty(PropertyType.COMPONENTS)) contentsToShow6 += _graphProperties.sectionHeader("Conectividade");
        if (this.hasProperty(PropertyType.COMPONENTS)) contentsToShow6 += _graphProperties.checkComponents();
        this.showMathJaxOutput(contentsToShow6, "output-conectivity");
        // console.log("showGraphInfo final", contentsToShow);
        try {
            document.getElementById("svg-output").textContent = contentsToShow;
            if (MathJax != null) MathJax.Hub.Queue([
                "Typeset",
                MathJax.Hub
            ]);
        } catch (e) {
        // 
        }
    }
    showGraphInfoThrottle = _underscoreDefault.default.throttle(this.showGraphInfo, 500);
    refresh(nodes, links) {
        // var a = nodes.length != this.graphVertices.length;
        // var b = links.length != this.graphEdges.length;
        // var c = this.graphVertices.filter((e) => e.edges == null || e.edges.length == 0).length > 0;
        if (nodes.length != this.graphVertices.length || links.length != this.graphEdges.length || this.graphVertices.filter((e)=>e.edges == null
        ).length > 0) {
            this.graphVertices = nodes.map((it)=>this.mapNodeToVertex(it)
            );
            this.graphEdges = [];
            links.map((it)=>{
                this.addEdge(it);
            });
            // if (nodes.length != this.graphVertices.length || links.length != this.graphEdges.length) {
            //     console.log("refresh/if", { nodes, links, graphEdges: this.graphEdges, graphVertices: this.graphVertices })
            //     this.graphVertices = vertices;
            //     this.graphEdges = edges;
            // }
            this.showGraphInfoThrottle();
        }
    // console.log("refresh end", { graphEdges: this.graphEdges, graphVertices: this.graphVertices });
    }
    importGraph(vertices, edges) {
        // console.log("importGraph", vertices, edges);
        this.graphVertices = vertices;
        this.graphEdges = edges;
        this.restartGraph();
    }
}
window.graph = new Graph();

},{"underscore":"dga04","./graph_properties":"6Ena2","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6Ena2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sectionHeader", ()=>sectionHeader
);
parcelHelpers.export(exports, "showGraphMinDegree", ()=>showGraphMinDegree
);
parcelHelpers.export(exports, "showGraphMaxDegree", ()=>showGraphMaxDegree
);
parcelHelpers.export(exports, "getVertexId", ()=>getVertexId
);
parcelHelpers.export(exports, "getVertexDegree", ()=>getVertexDegree
);
parcelHelpers.export(exports, "getVertexNeighborhood", ()=>getVertexNeighborhood
);
parcelHelpers.export(exports, "showGraphRegular", ()=>showGraphRegular
);
parcelHelpers.export(exports, "showGroups", ()=>showGroups
);
parcelHelpers.export(exports, "showAdjacencyMatrix", ()=>showAdjacencyMatrix
);
parcelHelpers.export(exports, "greedyColoring", ()=>greedyColoring
);
parcelHelpers.export(exports, "resetColoring", ()=>resetColoring
);
parcelHelpers.export(exports, "showChromaticNumber", ()=>showChromaticNumber
);
parcelHelpers.export(exports, "showBiparte", ()=>showBiparte
);
parcelHelpers.export(exports, "checkComponents", ()=>checkComponents
);
parcelHelpers.export(exports, "showCompleteGraph", ()=>showCompleteGraph
);
parcelHelpers.export(exports, "showTrivialGraph", ()=>showTrivialGraph
);
parcelHelpers.export(exports, "showCycles", ()=>showCycles
);
parcelHelpers.export(exports, "showTrees", ()=>showTrees
);
function sectionHeader(text) {
    var l = "\\[\\large{\\text{" + text + "}} \\]";
    return l;
}
function showGraphMinDegree() {
    var vertices = window.graph.graphVertices;
    var minDeg = Infinity;
    vertices.forEach(function(v) {
        if (v.degree < minDeg) minDeg = v.degree;
    });
    var l = "";
    if (vertices.length) l += "\\[\\delta(G)=" + minDeg + "\\]";
    else l += "\\[G \\hspace{10px} is \\hspace{10px} null\\]";
    return l;
}
function showGraphMaxDegree() {
    var vertices = window.graph.graphVertices;
    var maxDeg = 0;
    vertices.forEach(function(v) {
        if (v.degree > maxDeg) maxDeg = v.degree;
    });
    var l;
    if (vertices.length) l = "\\[\\Delta(G)=" + maxDeg + "\\]";
    else l = "\\[G \\hspace{10px} is \\hspace{10px} null\\]";
    return l;
}
function getVertexId(vertex) {
    var v = "\\[v_{" + vertex.id + "}" + "\\]";
    return v;
}
function getVertexDegree(vertex) {
    var l = "\\[\\delta_{G}(v_{" + vertex.id + "}" + ")=" + vertex.degree + "\\]";
    return l;
}
function vertexNeighborhood(vertex) {
    var edges = vertex.edges || [];
    return edges.map((it)=>it.target.id != vertex.id ? it.target.id : it.source.id
    );
}
function getVertexNeighborhood(vertex) {
    var neighborhood = vertexNeighborhood(vertex);
    // console.log("getVertexNeighborhood", { neighborhood });
    var e = "\\[\\Gamma_{G}(v_{" + vertex.id + "})=\\{";
    for(let i = 0; i < neighborhood.length; i++){
        if (i == neighborhood.length - 1) e += "v_{" + neighborhood[i] + "}";
        else e += "v_{" + neighborhood[i] + "}" + ",";
        //add line break
        if ((i + 1) % 10 == 0) e += "\\\\";
    }
    e += "\\}\\]";
    // console.log("getVertexNeighborhood 2", { neighborhood, e });
    return e;
}
function showGraphRegular() {
    var vertices = window.graph.graphVertices;
    var degSeq = vertices.map(function(v) {
        return v.degree;
    });
    //sort in decreasing order
    degSeq.sort(function(a, b) {
        return b - a;
    });
    //test if graph is regular
    var flag = false;
    if (degSeq.length > 0) flag = true;
    for(var i = 0; i < degSeq.length - 1; i++)if (degSeq[i] != degSeq[i + 1]) {
        flag = false;
        break;
    }
    var l = "";
    // var l = "\\[\\text{Degree Sequence}=(";
    // degSeq.forEach(function(d, i) {
    //     if (i !== degSeq.length - 1) l += d + ",";
    //     else l += d;
    //     if (i % 15 == 14) l += "\\\\";
    // });
    // l += ")\\]";
    if (flag) l += "\\[\\text{Grafo é \\(" + degSeq[0] + "\\)-regular de ordem }" + degSeq.length + "\\]";
    else l += "\\[\\text{Grafo não é k-regular.}\\]";
    return l;
}
function showGroups(vertices, edges) {
    var v = "\\[V=\\{";
    for(let i = 0; i < vertices.length; i++){
        if (i == 0) v += "v_{" + vertices[i].id + "}";
        else v += ",v_{" + vertices[i].id + "}";
        if ((i + 1) % 15 == 0) v += "\\\\";
    }
    v += "\\}\\]";
    var e = "\\[E=\\{";
    for(let i1 = 0; i1 < edges.length; i1++){
        if (i1 == edges.length - 1) e += "(v_{" + edges[i1].source.id + "}" + "v_{" + edges[i1].target.id + "}" + ")";
        else e += "(\\color{0}{v_{" + edges[i1].source.id + "}}" + "v_{" + edges[i1].target.id + "}" + ")" + ",";
        if ((i1 + 1) % 10 == 0) e += "\\\\";
    }
    e += "\\}\\]";
    e += "\\[\\text{|V| = }" + vertices.length + "\\]";
    e += "\\[\\text{|E| = }" + edges.length + "\\]";
    return v + e;
}
function showAdjacencyMatrix() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    var l = "";
    l += "\\[\\text{Matriz de adjacência}\\]";
    l += "\\[\\begin{pmatrix}";
    var a = [];
    for(let i = 0; i < vertices.length; i++){
        for(let j = 0; j < vertices.length; j++){
            var value;
            if (i == j) value = 0;
            else value = vertices[i].edges.filter((e)=>e.source.id == vertices[j].id || e.target.id == vertices[j].id
            ).length > 0 ? 1 : 0;
            var and = j == vertices.length - 1 ? "" : " & ";
            l += "" + value + and;
        }
        l += "\\";
        l += "\\";
    }
    l += "\\end{pmatrix}\\]";
    return l;
}
function greedyColoring(vertices) {
    const colors = vertices.map((it, index)=>index
    );
    const colorsResult = [];
    var result = [];
    vertices.forEach((v)=>{
        const usedColors = [];
        v.edges.forEach((edge, i)=>{
            var neighbour = vertices.find((it, _)=>it.id == edge.target.id || it.id == edge.source.id
            );
            usedColors.push(neighbour.color);
        });
        var color = colors.find((it, _)=>!usedColors.includes(it)
        );
        if (colorsResult.indexOf(color) === -1) colorsResult.push(color);
        v.color = color;
        result.push(v);
    });
    window.graph.graphVertices = result;
    window.graph.chromaticNumber = colorsResult.length;
    // console.log("GREEDY/final", {
    //     result,
    //     colors,
    //     graph: window.graph,
    //     colorsResult,
    // });
    window.graph.restartGraph();
}
function resetColoring(vertices) {
    window.graph.graphVertices = vertices.map((e)=>({
            ...e,
            color: null
        })
    );
    window.graph.restartGraph();
    window.graph.chromaticNumber = 0;
}
function showChromaticNumber(chromaticNumber) {
    // var l = "\\[\\text{Número crômatico é } \\chi = " + chromaticNumber + "\\]";
    var l = "\\[\\chi = " + chromaticNumber + "\\]";
    return l;
}
function showBiparte(isBipartite) {
    var vertices = window.graph.graphVertices;
    var l = "";
    if (isBipartite) {
        var setA = "", setB = "";
        var countA = 0, countB = 0;
        vertices.forEach(function(v) {
            if (v.color % 2 == 0) {
                countA++;
                setA += "v_{" + v.id + "},";
                if (countA % 12 == 0) setA += "\\\\";
            } else if (v.color % 2 == 1) {
                countB++;
                setB += "v_{" + v.id + "},";
                if (countB % 12 == 0) setB += "\\\\";
            }
        });
        //modify sets to make Latex text look nicer
        if (countA % 12 == 0) setA = setA.slice(0, -3);
        else setA = setA.slice(0, -1);
        if (countB % 12 == 0) setB = setB.slice(0, -3);
        else setB = setB.slice(0, -1);
        l += "\\[\\text{O grafo é bipartido!}\\]";
        l += "\\[\\text{Conjunto } A = \\{" + setA + "\\} \\]";
        l += "\\[\\text{Conjunto } B = \\{" + setB + "\\} \\]";
    } else if (isBipartite != false) l = "\\[\\text{O grafo não é bipartido.}\\]";
    else l = "\\[\\text{O grafo não é bipartido.}\\]";
    return l;
}
function checkComponents() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    if (vertices.length == 0) {
        componentCount = 0;
        return showComponents(componentCount);
    }
    componentCount = 1;
    //construct adjacency list of graph
    var adjList = {
    };
    vertices.forEach(function(v) {
        v.visited = false;
        adjList[v.id] = [];
    });
    edges.forEach(function(e) {
        adjList[e.source.id].push(vertices.find((v)=>v.id == e.target.id
        ));
        adjList[e.target.id].push(vertices.find((v)=>v.id == e.source.id
        ));
    });
    //perform DFS on vertices
    var q = [];
    q.push(vertices[0]);
    while(q.length > 0){
        var v1 = q.shift();
        var adj = adjList[v1.id];
        for(let i = 0; i < adj.length; i++){
            var v2 = adj[i];
            if (v2.visited) continue;
            q.push(v2);
        }
        v1.visited = true;
        v1.componentId = componentCount;
        //check for unvisited vertices
        if (q.length == 0) {
            for(let i = 0; i < vertices.length; i++)if (!vertices[i].visited) {
                q.push(vertices[i]);
                componentCount++;
                break;
            }
        }
    } //while ends here
    // vertices.style("fill", function(d) {
    //     return colors[d.componentId % 10];
    // });
    return showComponents(componentCount);
}
function showComponents(componentCount) {
    var l = "";
    if (componentCount == 0) l = "\\[\\text{Grafo não contém nenhum componente.}\\]";
    else if (componentCount == 1) l = "\\[\\text{O grafo tem somente um componente.}\\]";
    else l = "\\[\\text{O grafo tem " + componentCount + " componentes. É um grafo desconexo.}\\]";
    return l;
}
function showCompleteGraph() {
    var l = "";
    var degSeq = window.graph.graphVertices.map(function(v) {
        return v.degree;
    });
    //sort in decreasing order
    degSeq.sort(function(a, b) {
        return b - a;
    });
    var order = window.graph.graphVertices.length, size = window.graph.graphEdges.length;
    if (order > 0 && 2 * size == order * (order - 1)) l += "\\[\\text{\xc9 um grafo completo (}K_{" + degSeq.length + "} \\text{).}\\]";
    else l += "\\[\\text{Não é um grafo completo.}\\]";
    return l;
}
function showTrivialGraph() {
    var vertices = window.graph.graphVertices;
    var isTrivial = vertices.length == 1;
    if (isTrivial) return "\\[\\text{É um grafo trivial.}\\]";
    return "\\[\\text{Não é um grafo trivial.}\\]";
}
function checkCycle() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    if (edges.length == 0) return false;
    //construct adjacency list of graph
    //vis keeps track of visited node ids
    var adjList = {
    }, vis = {
    }, parent = {
    };
    vertices.forEach(function(v) {
        v.visited = false;
        adjList[v.id] = [];
        vis[v.id] = false;
    });
    edges.forEach(function(e) {
        adjList[e.source.id].push(e.target.id);
        adjList[e.target.id].push(e.source.id);
    });
    //perform DFS on vertices
    var q = [
        vertices[0].id
    ];
    //-1 means root
    parent[vertices[0].id] = -1;
    var v1, v2;
    while(q.length > 0){
        v1 = q.shift();
        vis[v1] = true;
        for(let i = 0; i < adjList[v1].length; i++){
            v2 = adjList[v1][i];
            if (vis[v2] && parent[v1] != v2) return true;
            if (!vis[v2]) {
                q.push(v2);
                parent[v2] = v1;
            }
        }
    }
    //check for other components
    if (q.length == 0) {
        for(let v in vis)if (!vis[v]) {
            q.push(v);
            parent[v] = -1;
            break;
        }
    }
    return false;
}
function showCycles() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    var l = "";
    //construct adjacency list of graph
    //vis keeps track of visited node ids
    var adjList = {
    }, vis = {
    }, parent = {
    };
    vertices.forEach(function(v) {
        v.visited = false;
        adjList[v.id] = [];
        vis[v.id] = false;
    });
    edges.forEach(function(e) {
        adjList[e.source.id].push(e.target.id);
        adjList[e.target.id].push(e.source.id);
    });
    //perform DFS on vertices
    var q = [
        vertices[0].id
    ];
    //-1 means root
    parent[vertices[0].id] = -1;
    var v1, v2;
    var cycles = 0;
    while(q.length > 0){
        v1 = q.shift();
        vis[v1] = true;
        for(let i = 0; i < adjList[v1].length; i++){
            v2 = adjList[v1][i];
            if (vis[v2] && parent[v1] != v2) cycles += 1;
            if (!vis[v2]) {
                q.push(v2);
                parent[v2] = v1;
            }
        }
        //check for other components
        if (q.length == 0) {
            for(let v in vis)if (!vis[v]) {
                q.push(v);
                parent[v] = -1;
                break;
            }
        }
    } //while ends here
    if (cycles == 0) l += "\\[\\text{O grafo não tem ciclos}\\]";
    else l += "\\[\\text{O grafo tem " + cycles + " ciclos.}\\]";
    return l;
}
function showTrees() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    var l = "";
    if (vertices.length == 0) l = "\\[\\text{Não é uma árvore.}\\]";
    else if (checkCycle()) l = "\\[\\text{Não é uma árvore. Grafo não é acíclico.}\\]";
    else if (vertices.length == edges.length + 1) l = "\\[\\text{É uma árvore.}\\]";
    else l = "\\[\\text{É uma floresta.}\\]";
    return l;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}]},["dwKjh","jQACI"], "jQACI", "parcelRequire0215")

</script>
<script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"4BeY2":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "60b0b19691db6101";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    var parents = getParents(module.bundle.root, id); // If no parents, the asset is new. Prevent reloading the page.
    if (!parents.length) return true;
    return parents.some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"29hU0":[function(require,module,exports) {
var _graphDrawerJs = require("./src/graph_drawer.js");

},{"./src/graph_drawer.js":"dI4YH"}],"dI4YH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _d3 = require("d3");
var _pleasejs = require("pleasejs");
var _pleasejsDefault = parcelHelpers.interopDefault(_pleasejs);
const htmlColors = require('html-colors');
var nodes = [];
var links = [];
var showVerticesIds = false;
var lastNodeId = nodes.length - 1;
var lastEdgeId = links.length - 1;
var viewWid = document.documentElement.clientWidth;
var w = viewWid > 1200 ? 900 : 700;
var h = w == 900 ? 600 : 500;
var rad = 12;
document.getElementById("properties").style.width = "" + w + "px";
var div = _d3.select("#svg-wrap").append("div").attr("width", w).attr("height", h).attr("class", "tooltip").style("opacity", 0);
window.div = div;
var svg = _d3.select("#svg-wrap").append("svg").attr("width", w).attr("height", h);
//array of colors for nodes
var colors = _d3.schemeCategory10.concat(_pleasejsDefault.default.make_color({
    colors_returned: 90,
    value: 0.7,
    saturation: 0.8,
    golden: false
}).map((e)=>!_d3.schemeCategory10.includes(e)
));
//the animation line when adding edge b/w two vertices
var dragLine = svg.append("path").attr("class", "dragLine hidden").attr("d", "M0,0L0,0");
var edges = svg.append("g").selectAll(".edge");
var vertices = svg.append("g").selectAll(".vertex");
var simulation = _d3.forceSimulation().force("charge", _d3.forceManyBody().strength(-300).distanceMax(w / 2)).force("link", _d3.forceLink().distance(60)).force("x", _d3.forceX(w / 2)).force("y", _d3.forceY(h / 2)).on("tick", tick);
var force = _d3.forceSimulation().force("charge", _d3.forceManyBody().strength(-300).distanceMax((w + h) / 2)).force("link", _d3.forceLink().distance(100)).force("x", _d3.forceX(w / 2)).force("y", _d3.forceY(h / 2)).on("tick", tick);
force.nodes(nodes);
force.force("link").links(links);
//update positions of edges and vertices with each internal timer's tick
function tick() {
    edges.attr("x1", function(d) {
        return d.source.x;
    }).attr("y1", function(d) {
        return d.source.y;
    }).attr("x2", function(d) {
        return d.target.x;
    }).attr("y2", function(d) {
        return d.target.y;
    });
    // vertices.attr("cx", function(d) { return d.x; })
    //     .attr("cy", function(d) { return d.y; });
    //here vertices are g.vertex elements
    vertices.attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
    });
}
function getColor(value) {
    return colors[value];
}
//updates the graph by updating links, nodes and binding them with DOM
//interface is defined through several events
function restart() {
    edges = edges.data(links, function(d) {
        return d.id;
    });
    edges.exit().remove();
    var ed = edges.enter().append("line").attr("class", "edge").on("mousedown", function() {
        _d3.event.stopPropagation();
    }).on("contextmenu", removeEdge);
    ed.append("title").text(function(d) {
        return "e" + d.id;
    });
    ed.append("text").style("text-anchor", "middle").attr("y", 5).attr("class", "vertex-text").on("mousedown", function() {
        _d3.event.stopPropagation();
    }).on("contextmenu", removeEdge).text(function(d) {
        return "teste";
    });
    edges = ed.merge(edges);
    //vertices are known by id
    vertices = vertices.data(nodes, function(d) {
        return d.id;
    });
    vertices.exit().remove();
    var g = vertices.enter().append("g").attr("class", "vertex")//so that force.drag and addNode don't interfere
    //mousedown is initiated on circle which is stopped at .vertex
    .on("mousedown", function() {
        _d3.event.stopPropagation();
    });
    g.append("circle").attr("r", rad).style("fill", function(d, i) {
        // console.log("fill", { d, color: colors[d.color % 10] });
        return getColor(d.color);
    }).on("mousedown", beginDragLine).on("mouseup", endDragLine).on("contextmenu", removeNode);
    g.append("title").text(function(d) {
        return "v" + d.id;
    });
    g.selectAll(".vertex");
    vertices = g.merge(vertices);
    vertices.style("fill", function(d, i) {
        // console.log("fill2", { d, color: colors[d.color % 10] });
        return getColor(d.color);
    });
    if (showVerticesIds) vertices.append("text").style("text-anchor", "middle").attr("y", 5).attr("class", "vertex-text").on("mousedown", beginDragLine).on("mouseup", endDragLine).on("contextmenu", removeNode).text(function(d) {
        return showVerticesIds ? d.id : null;
    });
    else vertices.selectAll("text").remove();
    force.nodes(nodes);
    // console.log("restart/6,", { links, nodes });
    force.force("link").links(links);
    // console.log("restart/7");
    force.alpha(0.8).restart();
    window.graph.refresh(nodes, links);
// console.log("restart/final", { nodes, links });
}
// CORE STUFF TO DRAW GRAPH ENDS //
// FUNCTIONS TO MANIPULATE GRAPH //
//interface for manipulation
svg.on("mousedown", addNode).on("mousemove", updateDragLine).on("mouseup", hideDragLine).on("contextmenu", function() {
    _d3.event.preventDefault();
}).on("mouseleave", hideDragLine);
function addNode() {
    if (_d3.event.button == 0) {
        var coords = _d3.mouse(this);
        var newNode = {
            x: coords[0],
            y: coords[1],
            id: ++lastNodeId
        };
        nodes.push(newNode);
        window.graph.hideVertexInfo();
        restart();
    }
}
//d is data, i is index according to selection
function removeNode(d, i) {
    //to make ctrl-drag works for mac/osx users
    if (_d3.event.ctrlKey) return;
    nodes.splice(nodes.indexOf(d), 1);
    var linksToRemove = links.filter(function(l) {
        return l.source === d || l.target === d;
    });
    linksToRemove.map(function(l) {
        links.splice(links.indexOf(l), 1);
    });
    _d3.event.preventDefault();
    restart();
    lastNodeId = nodes.map((it)=>it.id
    ).reduce((a, b)=>Math.max(a, b)
    );
}
function removeEdge(d, i) {
    links.splice(links.indexOf(d), 1);
    _d3.event.preventDefault();
    restart();
// window.graph.removeEdge(links);
}
//dragLine is used to add edge graphicaly b/w two nodes
//the two nodes of edges are mousedownNode and mouseupNode
var mousedownNode = null;
var mouseupNode = null;
function resetMouseVar() {
    mousedownNode = null;
    mouseupNode = null;
}
function hideDragLine() {
    dragLine.classed("hidden", true);
    resetMouseVar();
    restart();
}
function beginDragLine(d) {
    if (window.ctrlKeyIsPressed) window.graph.showVertexInfo(d);
    else window.graph.hideVertexInfo();
    //to prevent call of addNode through svg
    _d3.event.stopPropagation();
    //to prevent dragging of svg in firefox
    _d3.event.preventDefault();
    if (_d3.event.ctrlKey || _d3.event.button != 0) return;
    mousedownNode = d;
    dragLine.classed("hidden", false).attr("d", "M" + mousedownNode.x + "," + mousedownNode.y + "L" + mousedownNode.x + "," + mousedownNode.y);
}
function updateDragLine() {
    if (!mousedownNode) return;
    dragLine.attr("d", "M" + mousedownNode.x + "," + mousedownNode.y + "L" + _d3.mouse(this)[0] + "," + _d3.mouse(this)[1]);
}
//no need to call hideDragLine in endDragLine
//mouseup on vertices propagates to svg which calls hideDragLine
function endDragLine(d) {
    if (!mousedownNode || mousedownNode === d) return;
    //return if link already exists
    for(var i = 0; i < links.length; i++){
        var l = links[i];
        if (l.source === mousedownNode && l.target === d || l.source === d && l.target === mousedownNode) return;
    }
    var newLink = {
        source: mousedownNode,
        target: d,
        id: ++lastEdgeId
    };
    links.push(newLink);
}
//clearAll button
_d3.select("#clear").on('click', function() {
    nodes.splice(0);
    links.splice(0);
    lastNodeId = -1;
    restart();
});
// FUNCTIONS TO MANIPULATE GRAPH ENDS //
// Functions to enable draging of nodes when ctrl is held
//one response per ctrl keydown
var lastKeyDown = -1;
_d3.select(window).on('keydown', keydown).on('keyup', keyup);
function keydown() {
    _d3.event.preventDefault();
    if (lastKeyDown !== -1) return;
    lastKeyDown = _d3.event.key;
    if (lastKeyDown === "Control") vertices.call(_d3.drag().on("start", function dragstarted(d) {
        if (!_d3.event.active) simulation.alphaTarget(1).restart();
        d.fx = d.x;
        d.fy = d.y;
    }).on("drag", function(d) {
        d.fx = _d3.event.x;
        d.fy = _d3.event.y;
    }).on("end", function(d) {
        if (!_d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }));
}
function keyup() {
    lastKeyDown = -1;
    if (_d3.event.key === "Control") vertices.on("mousedown.drag", null);
}
function mapVertexToNode(vertex) {
    currentNode = nodes.find((e)=>e.id == vertex["id"]
    );
    return currentNode != null ? {
        ...currentNode,
        degree: vertex["degree"],
        color: vertex["color"]
    } : {
        id: vertex["id"],
        degree: vertex["degree"],
        color: vertex["color"]
    };
}
function mapEdgeToLink(edge, index) {
    return {
        id: edge["id"] || index,
        source: edge["source"],
        target: edge["target"]
    };
}
function setColor() {
    vertices.selectAll("circle").style("fill", function(d) {
        var vertex = window.graph.graphVertices.find((e)=>e.id == d.id
        );
        return getColor(vertex.color);
    });
}
function restartGraph() {
    setColor();
}
function toggleVertexId() {
    showVerticesIds = !showVerticesIds;
    restart();
}
function start() {
    if (window.graph.graphVertices != null) {
        var tempVertices = window.graph.graphVertices;
        var tempEdges = window.graph.graphEdges;
        window.graph.restartGraph = ()=>restartGraph()
        ;
        window.graph.toggleVertexId = ()=>toggleVertexId()
        ;
        nodes = tempVertices.map((it)=>mapVertexToNode(it)
        );
        links = tempEdges.map((it, index)=>mapEdgeToLink(it, index)
        );
        lastNodeId = nodes.map((it)=>it.id
        ).reduce((a, b)=>Math.max(a, b)
        );
        lastEdgeId = edges.length - 1;
    // console.log("start", { nodes, links });
    }
    restart();
}
// Start
start();

},{"d3":"lm5gy","pleasejs":"ki8vQ","html-colors":"2B6CQ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lm5gy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>_package.version
);
var _package = require("./dist/package");
var _d3Array = require("d3-array");
parcelHelpers.exportAll(_d3Array, exports);
var _d3Axis = require("d3-axis");
parcelHelpers.exportAll(_d3Axis, exports);
var _d3Brush = require("d3-brush");
parcelHelpers.exportAll(_d3Brush, exports);
var _d3Chord = require("d3-chord");
parcelHelpers.exportAll(_d3Chord, exports);
var _d3Collection = require("d3-collection");
parcelHelpers.exportAll(_d3Collection, exports);
var _d3Color = require("d3-color");
parcelHelpers.exportAll(_d3Color, exports);
var _d3Contour = require("d3-contour");
parcelHelpers.exportAll(_d3Contour, exports);
var _d3Dispatch = require("d3-dispatch");
parcelHelpers.exportAll(_d3Dispatch, exports);
var _d3Drag = require("d3-drag");
parcelHelpers.exportAll(_d3Drag, exports);
var _d3Dsv = require("d3-dsv");
parcelHelpers.exportAll(_d3Dsv, exports);
var _d3Ease = require("d3-ease");
parcelHelpers.exportAll(_d3Ease, exports);
var _d3Fetch = require("d3-fetch");
parcelHelpers.exportAll(_d3Fetch, exports);
var _d3Force = require("d3-force");
parcelHelpers.exportAll(_d3Force, exports);
var _d3Format = require("d3-format");
parcelHelpers.exportAll(_d3Format, exports);
var _d3Geo = require("d3-geo");
parcelHelpers.exportAll(_d3Geo, exports);
var _d3Hierarchy = require("d3-hierarchy");
parcelHelpers.exportAll(_d3Hierarchy, exports);
var _d3Interpolate = require("d3-interpolate");
parcelHelpers.exportAll(_d3Interpolate, exports);
var _d3Path = require("d3-path");
parcelHelpers.exportAll(_d3Path, exports);
var _d3Polygon = require("d3-polygon");
parcelHelpers.exportAll(_d3Polygon, exports);
var _d3Quadtree = require("d3-quadtree");
parcelHelpers.exportAll(_d3Quadtree, exports);
var _d3Random = require("d3-random");
parcelHelpers.exportAll(_d3Random, exports);
var _d3Scale = require("d3-scale");
parcelHelpers.exportAll(_d3Scale, exports);
var _d3ScaleChromatic = require("d3-scale-chromatic");
parcelHelpers.exportAll(_d3ScaleChromatic, exports);
var _d3Selection = require("d3-selection");
parcelHelpers.exportAll(_d3Selection, exports);
var _d3Shape = require("d3-shape");
parcelHelpers.exportAll(_d3Shape, exports);
var _d3Time = require("d3-time");
parcelHelpers.exportAll(_d3Time, exports);
var _d3TimeFormat = require("d3-time-format");
parcelHelpers.exportAll(_d3TimeFormat, exports);
var _d3Timer = require("d3-timer");
parcelHelpers.exportAll(_d3Timer, exports);
var _d3Transition = require("d3-transition");
parcelHelpers.exportAll(_d3Transition, exports);
var _d3Voronoi = require("d3-voronoi");
parcelHelpers.exportAll(_d3Voronoi, exports);
var _d3Zoom = require("d3-zoom");
parcelHelpers.exportAll(_d3Zoom, exports);

},{"./dist/package":"c0Spb","d3-array":"dclxS","d3-axis":"3HH3d","d3-brush":"j4mPt","d3-chord":"8oHeW","d3-collection":"4zn9z","d3-color":"ap3Jg","d3-contour":"jmn9V","d3-dispatch":"9d2te","d3-drag":"dKCUo","d3-dsv":"lK0ts","d3-ease":"elZFc","d3-fetch":"hPJXo","d3-force":"5HM4e","d3-format":"hzInr","d3-geo":"euFVP","d3-hierarchy":"1CTpH","d3-interpolate":"e7XwA","d3-path":"4S67G","d3-polygon":"6ide9","d3-quadtree":"1oyVd","d3-random":"dyiSs","d3-scale":"hrwOn","d3-scale-chromatic":"aFDOR","d3-selection":"hgWtk","d3-shape":"dTLqu","d3-time":"lTNsW","d3-time-format":"ioDBG","d3-timer":"82ygz","d3-transition":"cRYyR","d3-voronoi":"1EzfH","d3-zoom":"7E00u","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c0Spb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "name", ()=>name
);
parcelHelpers.export(exports, "version", ()=>version
);
parcelHelpers.export(exports, "description", ()=>description
);
parcelHelpers.export(exports, "keywords", ()=>keywords
);
parcelHelpers.export(exports, "homepage", ()=>homepage
);
parcelHelpers.export(exports, "license", ()=>license
);
parcelHelpers.export(exports, "author", ()=>author
);
parcelHelpers.export(exports, "main", ()=>main
);
parcelHelpers.export(exports, "unpkg", ()=>unpkg
);
parcelHelpers.export(exports, "jsdelivr", ()=>jsdelivr
);
parcelHelpers.export(exports, "module", ()=>module
);
parcelHelpers.export(exports, "repository", ()=>repository
);
parcelHelpers.export(exports, "scripts", ()=>scripts
);
parcelHelpers.export(exports, "devDependencies", ()=>devDependencies
);
parcelHelpers.export(exports, "dependencies", ()=>dependencies
);
var name = "d3";
var version = "5.7.0";
var description = "Data-Driven Documents";
var keywords = [
    "dom",
    "visualization",
    "svg",
    "animation",
    "canvas"
];
var homepage = "https://d3js.org";
var license = "BSD-3-Clause";
var author = {
    "name": "Mike Bostock",
    "url": "https://bost.ocks.org/mike"
};
var main = "dist/d3.node.js";
var unpkg = "dist/d3.min.js";
var jsdelivr = "dist/d3.min.js";
var module = "index.js";
var repository = {
    "type": "git",
    "url": "https://github.com/d3/d3.git"
};
var scripts = {
    "pretest": "rimraf dist && mkdir dist && json2module package.json > dist/package.js && node rollup.node",
    "test": "tape 'test/**/*-test.js'",
    "prepublishOnly": "yarn test && rollup -c",
    "postpublish": "git push && git push --tags && cd ../d3.github.com && git pull && cp ../d3/dist/d3.js d3.v5.js && cp ../d3/dist/d3.min.js d3.v5.min.js && git add d3.v5.js d3.v5.min.js && git commit -m \"d3 ${npm_package_version}\" && git push && cd - && cd ../d3-bower && git pull && cp ../d3/LICENSE ../d3/README.md ../d3/dist/d3.js ../d3/dist/d3.min.js . && git add -- LICENSE README.md d3.js d3.min.js && git commit -m \"${npm_package_version}\" && git tag -am \"${npm_package_version}\" v${npm_package_version} && git push && git push --tags && cd - && zip -j dist/d3.zip -- LICENSE README.md API.md CHANGES.md dist/d3.js dist/d3.min.js"
};
var devDependencies = {
    "json2module": "0.0",
    "rimraf": "2",
    "rollup": "0.64",
    "rollup-plugin-ascii": "0.0",
    "rollup-plugin-node-resolve": "3",
    "rollup-plugin-terser": "1",
    "tape": "4"
};
var dependencies = {
    "d3-array": "1",
    "d3-axis": "1",
    "d3-brush": "1",
    "d3-chord": "1",
    "d3-collection": "1",
    "d3-color": "1",
    "d3-contour": "1",
    "d3-dispatch": "1",
    "d3-drag": "1",
    "d3-dsv": "1",
    "d3-ease": "1",
    "d3-fetch": "1",
    "d3-force": "1",
    "d3-format": "1",
    "d3-geo": "1",
    "d3-hierarchy": "1",
    "d3-interpolate": "1",
    "d3-path": "1",
    "d3-polygon": "1",
    "d3-quadtree": "1",
    "d3-random": "1",
    "d3-scale": "2",
    "d3-scale-chromatic": "1",
    "d3-selection": "1",
    "d3-shape": "1",
    "d3-time": "1",
    "d3-time-format": "2",
    "d3-timer": "1",
    "d3-transition": "1",
    "d3-voronoi": "1",
    "d3-zoom": "1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"dclxS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bisect", ()=>_bisectDefault.default
);
parcelHelpers.export(exports, "bisectRight", ()=>_bisect.bisectRight
);
parcelHelpers.export(exports, "bisectLeft", ()=>_bisect.bisectLeft
);
parcelHelpers.export(exports, "ascending", ()=>_ascendingDefault.default
);
parcelHelpers.export(exports, "bisector", ()=>_bisectorDefault.default
);
parcelHelpers.export(exports, "cross", ()=>_crossDefault.default
);
parcelHelpers.export(exports, "descending", ()=>_descendingDefault.default
);
parcelHelpers.export(exports, "deviation", ()=>_deviationDefault.default
);
parcelHelpers.export(exports, "extent", ()=>_extentDefault.default
);
parcelHelpers.export(exports, "histogram", ()=>_histogramDefault.default
);
parcelHelpers.export(exports, "thresholdFreedmanDiaconis", ()=>_freedmanDiaconisDefault.default
);
parcelHelpers.export(exports, "thresholdScott", ()=>_scottDefault.default
);
parcelHelpers.export(exports, "thresholdSturges", ()=>_sturgesDefault.default
);
parcelHelpers.export(exports, "max", ()=>_maxDefault.default
);
parcelHelpers.export(exports, "mean", ()=>_meanDefault.default
);
parcelHelpers.export(exports, "median", ()=>_medianDefault.default
);
parcelHelpers.export(exports, "merge", ()=>_mergeDefault.default
);
parcelHelpers.export(exports, "min", ()=>_minDefault.default
);
parcelHelpers.export(exports, "pairs", ()=>_pairsDefault.default
);
parcelHelpers.export(exports, "permute", ()=>_permuteDefault.default
);
parcelHelpers.export(exports, "quantile", ()=>_quantileDefault.default
);
parcelHelpers.export(exports, "range", ()=>_rangeDefault.default
);
parcelHelpers.export(exports, "scan", ()=>_scanDefault.default
);
parcelHelpers.export(exports, "shuffle", ()=>_shuffleDefault.default
);
parcelHelpers.export(exports, "sum", ()=>_sumDefault.default
);
parcelHelpers.export(exports, "ticks", ()=>_ticksDefault.default
);
parcelHelpers.export(exports, "tickIncrement", ()=>_ticks.tickIncrement
);
parcelHelpers.export(exports, "tickStep", ()=>_ticks.tickStep
);
parcelHelpers.export(exports, "transpose", ()=>_transposeDefault.default
);
parcelHelpers.export(exports, "variance", ()=>_varianceDefault.default
);
parcelHelpers.export(exports, "zip", ()=>_zipDefault.default
);
var _bisect = require("./bisect");
var _bisectDefault = parcelHelpers.interopDefault(_bisect);
var _ascending = require("./ascending");
var _ascendingDefault = parcelHelpers.interopDefault(_ascending);
var _bisector = require("./bisector");
var _bisectorDefault = parcelHelpers.interopDefault(_bisector);
var _cross = require("./cross");
var _crossDefault = parcelHelpers.interopDefault(_cross);
var _descending = require("./descending");
var _descendingDefault = parcelHelpers.interopDefault(_descending);
var _deviation = require("./deviation");
var _deviationDefault = parcelHelpers.interopDefault(_deviation);
var _extent = require("./extent");
var _extentDefault = parcelHelpers.interopDefault(_extent);
var _histogram = require("./histogram");
var _histogramDefault = parcelHelpers.interopDefault(_histogram);
var _freedmanDiaconis = require("./threshold/freedmanDiaconis");
var _freedmanDiaconisDefault = parcelHelpers.interopDefault(_freedmanDiaconis);
var _scott = require("./threshold/scott");
var _scottDefault = parcelHelpers.interopDefault(_scott);
var _sturges = require("./threshold/sturges");
var _sturgesDefault = parcelHelpers.interopDefault(_sturges);
var _max = require("./max");
var _maxDefault = parcelHelpers.interopDefault(_max);
var _mean = require("./mean");
var _meanDefault = parcelHelpers.interopDefault(_mean);
var _median = require("./median");
var _medianDefault = parcelHelpers.interopDefault(_median);
var _merge = require("./merge");
var _mergeDefault = parcelHelpers.interopDefault(_merge);
var _min = require("./min");
var _minDefault = parcelHelpers.interopDefault(_min);
var _pairs = require("./pairs");
var _pairsDefault = parcelHelpers.interopDefault(_pairs);
var _permute = require("./permute");
var _permuteDefault = parcelHelpers.interopDefault(_permute);
var _quantile = require("./quantile");
var _quantileDefault = parcelHelpers.interopDefault(_quantile);
var _range = require("./range");
var _rangeDefault = parcelHelpers.interopDefault(_range);
var _scan = require("./scan");
var _scanDefault = parcelHelpers.interopDefault(_scan);
var _shuffle = require("./shuffle");
var _shuffleDefault = parcelHelpers.interopDefault(_shuffle);
var _sum = require("./sum");
var _sumDefault = parcelHelpers.interopDefault(_sum);
var _ticks = require("./ticks");
var _ticksDefault = parcelHelpers.interopDefault(_ticks);
var _transpose = require("./transpose");
var _transposeDefault = parcelHelpers.interopDefault(_transpose);
var _variance = require("./variance");
var _varianceDefault = parcelHelpers.interopDefault(_variance);
var _zip = require("./zip");
var _zipDefault = parcelHelpers.interopDefault(_zip);

},{"./bisect":"aBOzL","./ascending":"is3Cq","./bisector":"d0uRQ","./cross":"9wmuf","./descending":"3aHVG","./deviation":"gC5d9","./extent":"i65AD","./histogram":"cSFR1","./threshold/freedmanDiaconis":"YcDJP","./threshold/scott":"h9Xie","./threshold/sturges":"iBhHB","./max":"aKI7F","./mean":"522BH","./median":"25KY1","./merge":"lLqaS","./min":"ah5VG","./pairs":"f10CX","./permute":"lBJIA","./quantile":"g22bz","./range":"aFuRJ","./scan":"ek53c","./shuffle":"hrDvf","./sum":"5x489","./ticks":"eP3r2","./transpose":"eTl2h","./variance":"fFwh7","./zip":"g6Swo","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aBOzL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bisectRight", ()=>bisectRight
);
parcelHelpers.export(exports, "bisectLeft", ()=>bisectLeft
);
var _ascending = require("./ascending");
var _ascendingDefault = parcelHelpers.interopDefault(_ascending);
var _bisector = require("./bisector");
var _bisectorDefault = parcelHelpers.interopDefault(_bisector);
var ascendingBisect = _bisectorDefault.default(_ascendingDefault.default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
exports.default = bisectRight;

},{"./ascending":"is3Cq","./bisector":"d0uRQ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"is3Cq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"d0uRQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _ascending = require("./ascending");
var _ascendingDefault = parcelHelpers.interopDefault(_ascending);
exports.default = function(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
        left: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while(lo < hi){
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
            }
            return lo;
        },
        right: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while(lo < hi){
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) > 0) hi = mid;
                else lo = mid + 1;
            }
            return lo;
        }
    };
};
function ascendingComparator(f) {
    return function(d, x) {
        return _ascendingDefault.default(f(d), x);
    };
}

},{"./ascending":"is3Cq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9wmuf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pairs = require("./pairs");
exports.default = function(values0, values1, reduce) {
    var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0;
    if (reduce == null) reduce = _pairs.pair;
    for(i0 = i = 0; i0 < n0; ++i0)for(value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i)values[i] = reduce(value0, values1[i1]);
    return values;
};

},{"./pairs":"f10CX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"f10CX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pair", ()=>pair
);
exports.default = function(array, f) {
    if (f == null) f = pair;
    var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
    while(i < n)pairs[i] = f(p, p = array[++i]);
    return pairs;
};
function pair(a, b) {
    return [
        a,
        b
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3aHVG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gC5d9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _variance = require("./variance");
var _varianceDefault = parcelHelpers.interopDefault(_variance);
exports.default = function(array, f) {
    var v = _varianceDefault.default(array, f);
    return v ? Math.sqrt(v) : v;
};

},{"./variance":"fFwh7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fFwh7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _number = require("./number");
var _numberDefault = parcelHelpers.interopDefault(_number);
exports.default = function(values, valueof) {
    var n = values.length, m = 0, i = -1, mean = 0, value, delta, sum = 0;
    if (valueof == null) {
        while(++i < n)if (!isNaN(value = _numberDefault.default(values[i]))) {
            delta = value - mean;
            mean += delta / ++m;
            sum += delta * (value - mean);
        }
    } else {
        while(++i < n)if (!isNaN(value = _numberDefault.default(valueof(values[i], i, values)))) {
            delta = value - mean;
            mean += delta / ++m;
            sum += delta * (value - mean);
        }
    }
    if (m > 1) return sum / (m - 1);
};

},{"./number":"bMc02","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bMc02":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return x === null ? NaN : +x;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"i65AD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(values, valueof) {
    var n = values.length, i = -1, value, min, max;
    if (valueof == null) {
        while(++i < n)if ((value = values[i]) != null && value >= value) {
            min = max = value;
            while(++i < n)if ((value = values[i]) != null) {
                if (min > value) min = value;
                if (max < value) max = value;
            }
        }
    } else {
        while(++i < n)if ((value = valueof(values[i], i, values)) != null && value >= value) {
            min = max = value;
            while(++i < n)if ((value = valueof(values[i], i, values)) != null) {
                if (min > value) min = value;
                if (max < value) max = value;
            }
        }
    }
    return [
        min,
        max
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cSFR1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _array = require("./array");
var _bisect = require("./bisect");
var _bisectDefault = parcelHelpers.interopDefault(_bisect);
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var _extent = require("./extent");
var _extentDefault = parcelHelpers.interopDefault(_extent);
var _identity = require("./identity");
var _identityDefault = parcelHelpers.interopDefault(_identity);
var _range = require("./range");
var _rangeDefault = parcelHelpers.interopDefault(_range);
var _ticks = require("./ticks");
var _sturges = require("./threshold/sturges");
var _sturgesDefault = parcelHelpers.interopDefault(_sturges);
exports.default = function() {
    var value = _identityDefault.default, domain = _extentDefault.default, threshold = _sturgesDefault.default;
    function histogram(data) {
        var i, n = data.length, x, values = new Array(n);
        for(i = 0; i < n; ++i)values[i] = value(data[i], i, data);
        var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
            tz = _ticks.tickStep(x0, x1, tz);
            tz = _rangeDefault.default(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
        }
        // Remove any thresholds outside the domain.
        var m = tz.length;
        while(tz[0] <= x0)tz.shift(), --m;
        while(tz[m - 1] > x1)tz.pop(), --m;
        var bins = new Array(m + 1), bin;
        // Initialize bins.
        for(i = 0; i <= m; ++i){
            bin = bins[i] = [];
            bin.x0 = i > 0 ? tz[i - 1] : x0;
            bin.x1 = i < m ? tz[i] : x1;
        }
        // Assign data to bins by value, ignoring any outside the domain.
        for(i = 0; i < n; ++i){
            x = values[i];
            if (x0 <= x && x <= x1) bins[_bisectDefault.default(tz, x, 0, m)].push(data[i]);
        }
        return bins;
    }
    histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : _constantDefault.default(_), histogram) : value;
    };
    histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : _constantDefault.default([
            _[0],
            _[1]
        ]), histogram) : domain;
    };
    histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? _constantDefault.default(_array.slice.call(_)) : _constantDefault.default(_), histogram) : threshold;
    };
    return histogram;
};

},{"./array":"iz59S","./bisect":"aBOzL","./constant":"gS2I2","./extent":"i65AD","./identity":"4zs3O","./range":"aFuRJ","./ticks":"eP3r2","./threshold/sturges":"iBhHB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iz59S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "slice", ()=>slice
);
parcelHelpers.export(exports, "map", ()=>map
);
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gS2I2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4zs3O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return x;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aFuRJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
    while(++i < n)range[i] = start + i * step;
    return range;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eP3r2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tickIncrement", ()=>tickIncrement
);
parcelHelpers.export(exports, "tickStep", ()=>tickStep
);
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
exports.default = function(start, stop, count) {
    var reverse, i = -1, n, ticks, step;
    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [
        start
    ];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];
    if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));
        while(++i < n)ticks[i] = (start + i) * step;
    } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));
        while(++i < n)ticks[i] = (start - i) / step;
    }
    if (reverse) ticks.reverse();
    return ticks;
};
function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iBhHB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(values) {
    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"YcDJP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _array = require("../array");
var _ascending = require("../ascending");
var _ascendingDefault = parcelHelpers.interopDefault(_ascending);
var _number = require("../number");
var _numberDefault = parcelHelpers.interopDefault(_number);
var _quantile = require("../quantile");
var _quantileDefault = parcelHelpers.interopDefault(_quantile);
exports.default = function(values, min, max) {
    values = _array.map.call(values, _numberDefault.default).sort(_ascendingDefault.default);
    return Math.ceil((max - min) / (2 * (_quantileDefault.default(values, 0.75) - _quantileDefault.default(values, 0.25)) * Math.pow(values.length, -1 / 3)));
};

},{"../array":"iz59S","../ascending":"is3Cq","../number":"bMc02","../quantile":"g22bz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g22bz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _number = require("./number");
var _numberDefault = parcelHelpers.interopDefault(_number);
exports.default = function(values, p, valueof) {
    if (valueof == null) valueof = _numberDefault.default;
    if (!(n = values.length)) return;
    if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
    if (p >= 1) return +valueof(values[n - 1], n - 1, values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
};

},{"./number":"bMc02","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"h9Xie":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _deviation = require("../deviation");
var _deviationDefault = parcelHelpers.interopDefault(_deviation);
exports.default = function(values, min, max) {
    return Math.ceil((max - min) / (3.5 * _deviationDefault.default(values) * Math.pow(values.length, -1 / 3)));
};

},{"../deviation":"gC5d9","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aKI7F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(values, valueof) {
    var n = values.length, i = -1, value, max;
    if (valueof == null) {
        while(++i < n)if ((value = values[i]) != null && value >= value) {
            max = value;
            while(++i < n)if ((value = values[i]) != null && value > max) max = value;
        }
    } else {
        while(++i < n)if ((value = valueof(values[i], i, values)) != null && value >= value) {
            max = value;
            while(++i < n)if ((value = valueof(values[i], i, values)) != null && value > max) max = value;
        }
    }
    return max;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"522BH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _number = require("./number");
var _numberDefault = parcelHelpers.interopDefault(_number);
exports.default = function(values, valueof) {
    var n = values.length, m = n, i = -1, value, sum = 0;
    if (valueof == null) {
        while(++i < n)if (!isNaN(value = _numberDefault.default(values[i]))) sum += value;
        else --m;
    } else {
        while(++i < n)if (!isNaN(value = _numberDefault.default(valueof(values[i], i, values)))) sum += value;
        else --m;
    }
    if (m) return sum / m;
};

},{"./number":"bMc02","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"25KY1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _ascending = require("./ascending");
var _ascendingDefault = parcelHelpers.interopDefault(_ascending);
var _number = require("./number");
var _numberDefault = parcelHelpers.interopDefault(_number);
var _quantile = require("./quantile");
var _quantileDefault = parcelHelpers.interopDefault(_quantile);
exports.default = function(values, valueof) {
    var n = values.length, i = -1, value, numbers = [];
    if (valueof == null) {
        while(++i < n)if (!isNaN(value = _numberDefault.default(values[i]))) numbers.push(value);
    } else {
        while(++i < n)if (!isNaN(value = _numberDefault.default(valueof(values[i], i, values)))) numbers.push(value);
    }
    return _quantileDefault.default(numbers.sort(_ascendingDefault.default), 0.5);
};

},{"./ascending":"is3Cq","./number":"bMc02","./quantile":"g22bz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lLqaS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while(++i < n)j += arrays[i].length;
    merged = new Array(j);
    while(--n >= 0){
        array = arrays[n];
        m = array.length;
        while(--m >= 0)merged[--j] = array[m];
    }
    return merged;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ah5VG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(values, valueof) {
    var n = values.length, i = -1, value, min;
    if (valueof == null) {
        while(++i < n)if ((value = values[i]) != null && value >= value) {
            min = value;
            while(++i < n)if ((value = values[i]) != null && min > value) min = value;
        }
    } else {
        while(++i < n)if ((value = valueof(values[i], i, values)) != null && value >= value) {
            min = value;
            while(++i < n)if ((value = valueof(values[i], i, values)) != null && min > value) min = value;
        }
    }
    return min;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lBJIA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while(i--)permutes[i] = array[indexes[i]];
    return permutes;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ek53c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _ascending = require("./ascending");
var _ascendingDefault = parcelHelpers.interopDefault(_ascending);
exports.default = function(values, compare) {
    if (!(n = values.length)) return;
    var n, i = 0, j = 0, xi, xj = values[j];
    if (compare == null) compare = _ascendingDefault.default;
    while(++i < n)if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;
    if (compare(xj, xj) === 0) return j;
};

},{"./ascending":"is3Cq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hrDvf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(array, i0, i1) {
    var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;
    while(m){
        i = Math.random() * m-- | 0;
        t = array[m + i0];
        array[m + i0] = array[i + i0];
        array[i + i0] = t;
    }
    return array;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5x489":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(values, valueof) {
    var n = values.length, i = -1, value, sum = 0;
    if (valueof == null) {
        while(++i < n)if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    } else {
        while(++i < n)if (value = +valueof(values[i], i, values)) sum += value;
    }
    return sum;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eTl2h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _min = require("./min");
var _minDefault = parcelHelpers.interopDefault(_min);
exports.default = function(matrix) {
    if (!(n = matrix.length)) return [];
    for(var i = -1, m = _minDefault.default(matrix, length), transpose = new Array(m); ++i < m;)for(var j = -1, n, row = transpose[i] = new Array(n); ++j < n;)row[j] = matrix[j][i];
    return transpose;
};
function length(d) {
    return d.length;
}

},{"./min":"ah5VG","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g6Swo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _transpose = require("./transpose");
var _transposeDefault = parcelHelpers.interopDefault(_transpose);
exports.default = function() {
    return _transposeDefault.default(arguments);
};

},{"./transpose":"eTl2h","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3HH3d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "axisTop", ()=>_axis.axisTop
);
parcelHelpers.export(exports, "axisRight", ()=>_axis.axisRight
);
parcelHelpers.export(exports, "axisBottom", ()=>_axis.axisBottom
);
parcelHelpers.export(exports, "axisLeft", ()=>_axis.axisLeft
);
var _axis = require("./axis");

},{"./axis":"5vLMo","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5vLMo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "axisTop", ()=>axisTop
);
parcelHelpers.export(exports, "axisRight", ()=>axisRight
);
parcelHelpers.export(exports, "axisBottom", ()=>axisBottom
);
parcelHelpers.export(exports, "axisLeft", ()=>axisLeft
);
var _array = require("./array");
var _identity = require("./identity");
var _identityDefault = parcelHelpers.interopDefault(_identity);
var top = 1, right = 2, bottom = 3, left = 4, epsilon = 0.000001;
function translateX(x) {
    return "translate(" + (x + 0.5) + ",0)";
}
function translateY(y) {
    return "translate(0," + (y + 0.5) + ")";
}
function number(scale) {
    return function(d) {
        return +scale(d);
    };
}
function center(scale) {
    var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
    if (scale.round()) offset = Math.round(offset);
    return function(d) {
        return +scale(d) + offset;
    };
}
function entering() {
    return !this.__axis;
}
function axis1(orient, scale) {
    var tickArguments = [], tickValues = null, tickFormat = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX : translateY;
    function axis(context) {
        var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identityDefault.default : tickFormat, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + 0.5, range1 = +range[range.length - 1] + 0.5, position = (scale.bandwidth ? center : number)(scale.copy()), selection = context.selection ? context.selection() : context, path = selection.selectAll(".domain").data([
            null
        ]), tick = selection.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
        path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
        tick = tick.merge(tickEnter);
        line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
        text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
        if (context !== selection) {
            path = path.transition(context);
            tick = tick.transition(context);
            line = line.transition(context);
            text = text.transition(context);
            tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
                return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform");
            });
            tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
                var p = this.parentNode.__axis;
                return transform(p && isFinite(p = p(d)) ? p : position(d));
            });
        }
        tickExit.remove();
        path.attr("d", orient === left || orient == right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1);
        tick.attr("opacity", 1).attr("transform", function(d) {
            return transform(position(d));
        });
        line.attr(x + "2", k * tickSizeInner);
        text.attr(x, k * spacing).text(format);
        selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
        selection.each(function() {
            this.__axis = position;
        });
    }
    axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
    };
    axis.ticks = function() {
        return tickArguments = _array.slice.call(arguments), axis;
    };
    axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : _array.slice.call(_), axis) : tickArguments.slice();
    };
    axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : _array.slice.call(_), axis) : tickValues && tickValues.slice();
    };
    axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
    };
    axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
    };
    axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
    };
    axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
    };
    axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
    };
    return axis;
}
function axisTop(scale) {
    return axis1(top, scale);
}
function axisRight(scale) {
    return axis1(right, scale);
}
function axisBottom(scale) {
    return axis1(bottom, scale);
}
function axisLeft(scale) {
    return axis1(left, scale);
}

},{"./array":"jGeXs","./identity":"eB8bj","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jGeXs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "slice", ()=>slice
);
var slice = Array.prototype.slice;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eB8bj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return x;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"j4mPt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brush", ()=>_brushJsDefault.default
);
parcelHelpers.export(exports, "brushX", ()=>_brushJs.brushX
);
parcelHelpers.export(exports, "brushY", ()=>_brushJs.brushY
);
parcelHelpers.export(exports, "brushSelection", ()=>_brushJs.brushSelection
);
var _brushJs = require("./brush.js");
var _brushJsDefault = parcelHelpers.interopDefault(_brushJs);

},{"./brush.js":"klUdI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"klUdI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brushSelection", ()=>brushSelection
);
parcelHelpers.export(exports, "brushX", ()=>brushX
);
parcelHelpers.export(exports, "brushY", ()=>brushY
);
var _d3Dispatch = require("d3-dispatch");
var _d3Drag = require("d3-drag");
var _d3Interpolate = require("d3-interpolate");
var _d3Selection = require("d3-selection");
var _d3Transition = require("d3-transition");
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _eventJs = require("./event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _noeventJs = require("./noevent.js");
var _noeventJsDefault = parcelHelpers.interopDefault(_noeventJs);
var MODE_DRAG = {
    name: "drag"
}, MODE_SPACE = {
    name: "space"
}, MODE_HANDLE = {
    name: "handle"
}, MODE_CENTER = {
    name: "center"
};
function number1(e) {
    return [
        +e[0],
        +e[1]
    ];
}
function number2(e) {
    return [
        number1(e[0]),
        number1(e[1])
    ];
}
function toucher(identifier) {
    return function(target) {
        return _d3Selection.touch(target, _d3Selection.event.touches, identifier);
    };
}
var X = {
    name: "x",
    handles: [
        "w",
        "e"
    ].map(type1),
    input: function(x, e) {
        return x == null ? null : [
            [
                +x[0],
                e[0][1]
            ],
            [
                +x[1],
                e[1][1]
            ]
        ];
    },
    output: function(xy) {
        return xy && [
            xy[0][0],
            xy[1][0]
        ];
    }
};
var Y = {
    name: "y",
    handles: [
        "n",
        "s"
    ].map(type1),
    input: function(y, e) {
        return y == null ? null : [
            [
                e[0][0],
                +y[0]
            ],
            [
                e[1][0],
                +y[1]
            ]
        ];
    },
    output: function(xy) {
        return xy && [
            xy[0][1],
            xy[1][1]
        ];
    }
};
var XY = {
    name: "xy",
    handles: [
        "n",
        "w",
        "e",
        "s",
        "nw",
        "ne",
        "sw",
        "se"
    ].map(type1),
    input: function(xy) {
        return xy == null ? null : number2(xy);
    },
    output: function(xy) {
        return xy;
    }
};
var cursors = {
    overlay: "crosshair",
    selection: "move",
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
};
var flipX = {
    e: "w",
    w: "e",
    nw: "ne",
    ne: "nw",
    se: "sw",
    sw: "se"
};
var flipY = {
    n: "s",
    s: "n",
    nw: "sw",
    ne: "se",
    se: "ne",
    sw: "nw"
};
var signsX = {
    overlay: 1,
    selection: 1,
    n: null,
    e: 1,
    s: null,
    w: -1,
    nw: -1,
    ne: 1,
    se: 1,
    sw: -1
};
var signsY = {
    overlay: 1,
    selection: 1,
    n: -1,
    e: null,
    s: 1,
    w: null,
    nw: -1,
    ne: -1,
    se: 1,
    sw: 1
};
function type1(t) {
    return {
        type: t
    };
}
// Ignore right-click, since that should open the context menu.
function defaultFilter() {
    return !_d3Selection.event.ctrlKey && !_d3Selection.event.button;
}
function defaultExtent() {
    var svg = this.ownerSVGElement || this;
    if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [
            [
                svg.x,
                svg.y
            ],
            [
                svg.x + svg.width,
                svg.y + svg.height
            ]
        ];
    }
    return [
        [
            0,
            0
        ],
        [
            svg.width.baseVal.value,
            svg.height.baseVal.value
        ]
    ];
}
function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
}
// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
    while(!node.__brush)if (!(node = node.parentNode)) return;
    return node.__brush;
}
function empty(extent) {
    return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
}
function brushSelection(node) {
    var state = node.__brush;
    return state ? state.dim.output(state.selection) : null;
}
function brushX() {
    return brush1(X);
}
function brushY() {
    return brush1(Y);
}
exports.default = function() {
    return brush1(XY);
};
function brush1(dim) {
    var extent1 = defaultExtent, filter = defaultFilter, touchable = defaultTouchable, keys = true, listeners = _d3Dispatch.dispatch("start", "brush", "end"), handleSize = 6, touchending;
    function brush(group) {
        var overlay = group.property("__brush", initialize).selectAll(".overlay").data([
            type1("overlay")
        ]);
        overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
            var extent = local(this).extent;
            _d3Selection.select(this).attr("x", extent[0][0]).attr("y", extent[0][1]).attr("width", extent[1][0] - extent[0][0]).attr("height", extent[1][1] - extent[0][1]);
        });
        group.selectAll(".selection").data([
            type1("selection")
        ]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
        var handle = group.selectAll(".handle").data(dim.handles, function(d) {
            return d.type;
        });
        handle.exit().remove();
        handle.enter().append("rect").attr("class", function(d) {
            return "handle handle--" + d.type;
        }).attr("cursor", function(d) {
            return cursors[d.type];
        });
        group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    brush.move = function(group, selection) {
        if (group.selection) group.on("start.brush", function() {
            emitter(this, arguments).beforestart().start();
        }).on("interrupt.brush end.brush", function() {
            emitter(this, arguments).end();
        }).tween("brush", function() {
            var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent), i = _d3Interpolate.interpolate(selection0, selection1);
            function tween(t) {
                state.selection = t === 1 && selection1 === null ? null : i(t);
                redraw.call(that);
                emit.brush();
            }
            return selection0 !== null && selection1 !== null ? tween : tween(1);
        });
        else group.each(function() {
            var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent), emit = emitter(that, args).beforestart();
            _d3Transition.interrupt(that);
            state.selection = selection1 === null ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
        });
    };
    brush.clear = function(group) {
        brush.move(group, null);
    };
    function redraw() {
        var group = _d3Selection.select(this), selection = local(this).selection;
        if (selection) {
            group.selectAll(".selection").style("display", null).attr("x", selection[0][0]).attr("y", selection[0][1]).attr("width", selection[1][0] - selection[0][0]).attr("height", selection[1][1] - selection[0][1]);
            group.selectAll(".handle").style("display", null).attr("x", function(d) {
                return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2;
            }).attr("y", function(d) {
                return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2;
            }).attr("width", function(d) {
                return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize;
            }).attr("height", function(d) {
                return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize;
            });
        } else group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
    function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
    }
    function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
    }
    Emitter.prototype = {
        beforestart: function() {
            if (++this.active === 1) this.state.emitter = this, this.starting = true;
            return this;
        },
        start: function() {
            if (this.starting) this.starting = false, this.emit("start");
            else this.emit("brush");
            return this;
        },
        brush: function() {
            this.emit("brush");
            return this;
        },
        end: function() {
            if (--this.active === 0) delete this.state.emitter, this.emit("end");
            return this;
        },
        emit: function(type) {
            _d3Selection.customEvent(new _eventJsDefault.default(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [
                type,
                this.that,
                this.args
            ]);
        }
    };
    function started() {
        if (touchending && !_d3Selection.event.touches) return;
        if (!filter.apply(this, arguments)) return;
        var that = this, type = _d3Selection.event.target.__data__.type, mode = (keys && _d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : keys && _d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type], signY = dim === X ? null : signsY[type], state = local(that), extent = state.extent, selection = state.selection, W = extent[0][0], w0, w1, N = extent[0][1], n0, n1, E = extent[1][0], e0, e1, S = extent[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && _d3Selection.event.shiftKey, lockX, lockY, pointer = _d3Selection.event.touches ? toucher(_d3Selection.event.changedTouches[0].identifier) : _d3Selection.mouse, point0 = pointer(that), point = point0, emit = emitter(that, arguments, true).beforestart();
        if (type === "overlay") {
            if (selection) moving = true;
            state.selection = selection = [
                [
                    w0 = dim === Y ? W : point0[0],
                    n0 = dim === X ? N : point0[1]
                ],
                [
                    e0 = dim === Y ? E : w0,
                    s0 = dim === X ? S : n0
                ]
            ];
        } else {
            w0 = selection[0][0];
            n0 = selection[0][1];
            e0 = selection[1][0];
            s0 = selection[1][1];
        }
        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;
        var group = _d3Selection.select(that).attr("pointer-events", "none");
        var overlay = group.selectAll(".overlay").attr("cursor", cursors[type]);
        if (_d3Selection.event.touches) {
            emit.moved = moved;
            emit.ended = ended;
        } else {
            var view = _d3Selection.select(_d3Selection.event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
            if (keys) view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
            _d3Drag.dragDisable(_d3Selection.event.view);
        }
        _noeventJs.nopropagation();
        _d3Transition.interrupt(that);
        redraw.call(that);
        emit.start();
        function moved() {
            var point1 = pointer(that);
            if (shifting && !lockX && !lockY) {
                if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
                else lockX = true;
            }
            point = point1;
            moving = true;
            _noeventJsDefault.default();
            move();
        }
        function move() {
            var t;
            dx = point[0] - point0[0];
            dy = point[1] - point0[1];
            switch(mode){
                case MODE_SPACE:
                case MODE_DRAG:
                    if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
                    if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
                    break;
                case MODE_HANDLE:
                    if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                    else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                    if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                    else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
                    break;
                case MODE_CENTER:
                    if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
                    if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
                    break;
            }
            if (e1 < w1) {
                signX *= -1;
                t = w0, w0 = e0, e0 = t;
                t = w1, w1 = e1, e1 = t;
                if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
            }
            if (s1 < n1) {
                signY *= -1;
                t = n0, n0 = s0, s0 = t;
                t = n1, n1 = s1, s1 = t;
                if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
            }
            if (state.selection) selection = state.selection; // May be set by brush.move!
            if (lockX) w1 = selection[0][0], e1 = selection[1][0];
            if (lockY) n1 = selection[0][1], s1 = selection[1][1];
            if (selection[0][0] !== w1 || selection[0][1] !== n1 || selection[1][0] !== e1 || selection[1][1] !== s1) {
                state.selection = [
                    [
                        w1,
                        n1
                    ],
                    [
                        e1,
                        s1
                    ]
                ];
                redraw.call(that);
                emit.brush();
            }
        }
        function ended() {
            _noeventJs.nopropagation();
            if (_d3Selection.event.touches) {
                if (_d3Selection.event.touches.length) return;
                if (touchending) clearTimeout(touchending);
                touchending = setTimeout(function() {
                    touchending = null;
                }, 500); // Ghost clicks are delayed!
            } else {
                _d3Drag.dragEnable(_d3Selection.event.view, moving);
                view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
            }
            group.attr("pointer-events", "all");
            overlay.attr("cursor", cursors.overlay);
            if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
            if (empty(selection)) state.selection = null, redraw.call(that);
            emit.end();
        }
        function keydowned() {
            switch(_d3Selection.event.keyCode){
                case 16:
                    shifting = signX && signY;
                    break;
                case 18:
                    if (mode === MODE_HANDLE) {
                        if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                        if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                        mode = MODE_CENTER;
                        move();
                    }
                    break;
                case 32:
                    if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                        if (signX < 0) e0 = e1 - dx;
                        else if (signX > 0) w0 = w1 - dx;
                        if (signY < 0) s0 = s1 - dy;
                        else if (signY > 0) n0 = n1 - dy;
                        mode = MODE_SPACE;
                        overlay.attr("cursor", cursors.selection);
                        move();
                    }
                    break;
                default:
                    return;
            }
            _noeventJsDefault.default();
        }
        function keyupped() {
            switch(_d3Selection.event.keyCode){
                case 16:
                    if (shifting) {
                        lockX = lockY = shifting = false;
                        move();
                    }
                    break;
                case 18:
                    if (mode === MODE_CENTER) {
                        if (signX < 0) e0 = e1;
                        else if (signX > 0) w0 = w1;
                        if (signY < 0) s0 = s1;
                        else if (signY > 0) n0 = n1;
                        mode = MODE_HANDLE;
                        move();
                    }
                    break;
                case 32:
                    if (mode === MODE_SPACE) {
                        if (_d3Selection.event.altKey) {
                            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                            mode = MODE_CENTER;
                        } else {
                            if (signX < 0) e0 = e1;
                            else if (signX > 0) w0 = w1;
                            if (signY < 0) s0 = s1;
                            else if (signY > 0) n0 = n1;
                            mode = MODE_HANDLE;
                        }
                        overlay.attr("cursor", cursors[type]);
                        move();
                    }
                    break;
                default:
                    return;
            }
            _noeventJsDefault.default();
        }
    }
    function touchmoved() {
        emitter(this, arguments).moved();
    }
    function touchended() {
        emitter(this, arguments).ended();
    }
    function initialize() {
        var state = this.__brush || {
            selection: null
        };
        state.extent = number2(extent1.apply(this, arguments));
        state.dim = dim;
        return state;
    }
    brush.extent = function(_) {
        return arguments.length ? (extent1 = typeof _ === "function" ? _ : _constantJsDefault.default(number2(_)), brush) : extent1;
    };
    brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : _constantJsDefault.default(!!_), brush) : filter;
    };
    brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : _constantJsDefault.default(!!_), brush) : touchable;
    };
    brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
    };
    brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
    };
    brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
    };
    return brush;
}

},{"d3-dispatch":"9d2te","d3-drag":"dKCUo","d3-interpolate":"e7XwA","d3-selection":"hgWtk","d3-transition":"cRYyR","./constant.js":"j4KZw","./event.js":"3Rq9l","./noevent.js":"9Mi58","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9d2te":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dispatch", ()=>_dispatchJsDefault.default
);
var _dispatchJs = require("./dispatch.js");
var _dispatchJsDefault = parcelHelpers.interopDefault(_dispatchJs);

},{"./dispatch.js":"fEgH3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fEgH3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var noop = {
    value: function() {
    }
};
function dispatch() {
    for(var i = 0, n = arguments.length, _ = {
    }, t; i < n; ++i){
        if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
    }
    return new Dispatch(_);
}
function Dispatch(_) {
    this._ = _;
}
function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {
            type: t,
            name: name
        };
    });
}
Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
        var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
            while(++i < n)if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
            return;
        }
        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while(++i < n){
            if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
            else if (callback == null) for(t in _)_[t] = set(_[t], typename.name, null);
        }
        return this;
    },
    copy: function() {
        var copy = {
        }, _ = this._;
        for(var t in _)copy[t] = _[t].slice();
        return new Dispatch(copy);
    },
    call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for(var args = new Array(n), i = 0, n, t; i < n; ++i)args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for(t = this._[type], i = 0, n = t.length; i < n; ++i)t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for(var t = this._[type], i = 0, n = t.length; i < n; ++i)t[i].value.apply(that, args);
    }
};
function get(type, name) {
    for(var i = 0, n = type.length, c; i < n; ++i){
        if ((c = type[i]).name === name) return c.value;
    }
}
function set(type, name, callback) {
    for(var i = 0, n = type.length; i < n; ++i)if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
    }
    if (callback != null) type.push({
        name: name,
        value: callback
    });
    return type;
}
exports.default = dispatch;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dKCUo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drag", ()=>_dragJsDefault.default
);
parcelHelpers.export(exports, "dragDisable", ()=>_nodragJsDefault.default
);
parcelHelpers.export(exports, "dragEnable", ()=>_nodragJs.yesdrag
);
var _dragJs = require("./drag.js");
var _dragJsDefault = parcelHelpers.interopDefault(_dragJs);
var _nodragJs = require("./nodrag.js");
var _nodragJsDefault = parcelHelpers.interopDefault(_nodragJs);

},{"./drag.js":"7NbwI","./nodrag.js":"1WTbI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7NbwI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Dispatch = require("d3-dispatch");
var _d3Selection = require("d3-selection");
var _nodragJs = require("./nodrag.js");
var _nodragJsDefault = parcelHelpers.interopDefault(_nodragJs);
var _noeventJs = require("./noevent.js");
var _noeventJsDefault = parcelHelpers.interopDefault(_noeventJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _eventJs = require("./event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
// Ignore right-click, since that should open the context menu.
function defaultFilter() {
    return !_d3Selection.event.ctrlKey && !_d3Selection.event.button;
}
function defaultContainer() {
    return this.parentNode;
}
function defaultSubject(d) {
    return d == null ? {
        x: _d3Selection.event.x,
        y: _d3Selection.event.y
    } : d;
}
function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
}
exports.default = function() {
    var filter = defaultFilter, container1 = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {
    }, listeners = _d3Dispatch.dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
    function drag(selection) {
        selection.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function mousedowned() {
        if (touchending || !filter.apply(this, arguments)) return;
        var gesture = beforestart("mouse", container1.apply(this, arguments), _d3Selection.mouse, this, arguments);
        if (!gesture) return;
        _d3Selection.select(_d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
        _nodragJsDefault.default(_d3Selection.event.view);
        _noeventJs.nopropagation();
        mousemoving = false;
        mousedownx = _d3Selection.event.clientX;
        mousedowny = _d3Selection.event.clientY;
        gesture("start");
    }
    function mousemoved() {
        _noeventJsDefault.default();
        if (!mousemoving) {
            var dx = _d3Selection.event.clientX - mousedownx, dy = _d3Selection.event.clientY - mousedowny;
            mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag");
    }
    function mouseupped() {
        _d3Selection.select(_d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
        _nodragJs.yesdrag(_d3Selection.event.view, mousemoving);
        _noeventJsDefault.default();
        gestures.mouse("end");
    }
    function touchstarted() {
        if (!filter.apply(this, arguments)) return;
        var touches = _d3Selection.event.changedTouches, c = container1.apply(this, arguments), n = touches.length, i, gesture;
        for(i = 0; i < n; ++i)if (gesture = beforestart(touches[i].identifier, c, _d3Selection.touch, this, arguments)) {
            _noeventJs.nopropagation();
            gesture("start");
        }
    }
    function touchmoved() {
        var touches = _d3Selection.event.changedTouches, n = touches.length, i, gesture;
        for(i = 0; i < n; ++i)if (gesture = gestures[touches[i].identifier]) {
            _noeventJsDefault.default();
            gesture("drag");
        }
    }
    function touchended() {
        var touches = _d3Selection.event.changedTouches, n = touches.length, i, gesture;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() {
            touchending = null;
        }, 500); // Ghost clicks are delayed!
        for(i = 0; i < n; ++i)if (gesture = gestures[touches[i].identifier]) {
            _noeventJs.nopropagation();
            gesture("end");
        }
    }
    function beforestart(id, container, point, that, args) {
        var p = point(container, id), s, dx, dy, sublisteners = listeners.copy();
        if (!_d3Selection.customEvent(new _eventJsDefault.default(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
            if ((_d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
            dx = s.x - p[0] || 0;
            dy = s.y - p[1] || 0;
            return true;
        })) return;
        return function gesture(type) {
            var p0 = p, n;
            switch(type){
                case "start":
                    gestures[id] = gesture, n = active++;
                    break;
                case "end":
                    delete gestures[id], --active; // nobreak
                case "drag":
                    p = point(container, id), n = active;
                    break;
            }
            _d3Selection.customEvent(new _eventJsDefault.default(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [
                type,
                that,
                args
            ]);
        };
    }
    drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : _constantJsDefault.default(!!_), drag) : filter;
    };
    drag.container = function(_) {
        return arguments.length ? (container1 = typeof _ === "function" ? _ : _constantJsDefault.default(_), drag) : container1;
    };
    drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : _constantJsDefault.default(_), drag) : subject;
    };
    drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : _constantJsDefault.default(!!_), drag) : touchable;
    };
    drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
    };
    drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
    };
    return drag;
};

},{"d3-dispatch":"9d2te","d3-selection":"hgWtk","./nodrag.js":"1WTbI","./noevent.js":"hhrgp","./constant.js":"kBgzJ","./event.js":"3Vdpe","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hgWtk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>_createDefault.default
);
parcelHelpers.export(exports, "creator", ()=>_creatorDefault.default
);
parcelHelpers.export(exports, "local", ()=>_localDefault.default
);
parcelHelpers.export(exports, "matcher", ()=>_matcherDefault.default
);
parcelHelpers.export(exports, "mouse", ()=>_mouseDefault.default
);
parcelHelpers.export(exports, "namespace", ()=>_namespaceDefault.default
);
parcelHelpers.export(exports, "namespaces", ()=>_namespacesDefault.default
);
parcelHelpers.export(exports, "clientPoint", ()=>_pointDefault.default
);
parcelHelpers.export(exports, "select", ()=>_selectDefault.default
);
parcelHelpers.export(exports, "selectAll", ()=>_selectAllDefault.default
);
parcelHelpers.export(exports, "selection", ()=>_indexDefault.default
);
parcelHelpers.export(exports, "selector", ()=>_selectorDefault.default
);
parcelHelpers.export(exports, "selectorAll", ()=>_selectorAllDefault.default
);
parcelHelpers.export(exports, "style", ()=>_style.styleValue
);
parcelHelpers.export(exports, "touch", ()=>_touchDefault.default
);
parcelHelpers.export(exports, "touches", ()=>_touchesDefault.default
);
parcelHelpers.export(exports, "window", ()=>_windowDefault.default
);
parcelHelpers.export(exports, "event", ()=>_on.event
);
parcelHelpers.export(exports, "customEvent", ()=>_on.customEvent
);
var _create = require("./create");
var _createDefault = parcelHelpers.interopDefault(_create);
var _creator = require("./creator");
var _creatorDefault = parcelHelpers.interopDefault(_creator);
var _local = require("./local");
var _localDefault = parcelHelpers.interopDefault(_local);
var _matcher = require("./matcher");
var _matcherDefault = parcelHelpers.interopDefault(_matcher);
var _mouse = require("./mouse");
var _mouseDefault = parcelHelpers.interopDefault(_mouse);
var _namespace = require("./namespace");
var _namespaceDefault = parcelHelpers.interopDefault(_namespace);
var _namespaces = require("./namespaces");
var _namespacesDefault = parcelHelpers.interopDefault(_namespaces);
var _point = require("./point");
var _pointDefault = parcelHelpers.interopDefault(_point);
var _select = require("./select");
var _selectDefault = parcelHelpers.interopDefault(_select);
var _selectAll = require("./selectAll");
var _selectAllDefault = parcelHelpers.interopDefault(_selectAll);
var _index = require("./selection/index");
var _indexDefault = parcelHelpers.interopDefault(_index);
var _selector = require("./selector");
var _selectorDefault = parcelHelpers.interopDefault(_selector);
var _selectorAll = require("./selectorAll");
var _selectorAllDefault = parcelHelpers.interopDefault(_selectorAll);
var _style = require("./selection/style");
var _touch = require("./touch");
var _touchDefault = parcelHelpers.interopDefault(_touch);
var _touches = require("./touches");
var _touchesDefault = parcelHelpers.interopDefault(_touches);
var _window = require("./window");
var _windowDefault = parcelHelpers.interopDefault(_window);
var _on = require("./selection/on");

},{"./create":"luWz7","./creator":"hzFln","./local":"85ofP","./matcher":"5hMoc","./mouse":"eVYQP","./namespace":"k6t5I","./namespaces":"jlwhh","./point":"4ZAQb","./select":"g0UZK","./selectAll":"lhfgm","./selection/index":"f38xv","./selector":"e9mWc","./selectorAll":"6FR5I","./selection/style":"lVr8f","./touch":"3Slti","./touches":"kvGcQ","./window":"c51LV","./selection/on":"6sHag","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"luWz7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _creator = require("./creator");
var _creatorDefault = parcelHelpers.interopDefault(_creator);
var _select = require("./select");
var _selectDefault = parcelHelpers.interopDefault(_select);
exports.default = function(name) {
    return _selectDefault.default(_creatorDefault.default(name).call(document.documentElement));
};

},{"./creator":"hzFln","./select":"g0UZK","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hzFln":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _namespace = require("./namespace");
var _namespaceDefault = parcelHelpers.interopDefault(_namespace);
var _namespaces = require("./namespaces");
function creatorInherit(name) {
    return function() {
        var document = this.ownerDocument, uri = this.namespaceURI;
        return uri === _namespaces.xhtml && document.documentElement.namespaceURI === _namespaces.xhtml ? document.createElement(name) : document.createElementNS(uri, name);
    };
}
function creatorFixed(fullname) {
    return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
}
exports.default = function(name) {
    var fullname = _namespaceDefault.default(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
};

},{"./namespace":"k6t5I","./namespaces":"jlwhh","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k6t5I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _namespaces = require("./namespaces");
var _namespacesDefault = parcelHelpers.interopDefault(_namespaces);
exports.default = function(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return _namespacesDefault.default.hasOwnProperty(prefix) ? {
        space: _namespacesDefault.default[prefix],
        local: name
    } : name;
};

},{"./namespaces":"jlwhh","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jlwhh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "xhtml", ()=>xhtml
);
var xhtml = "http://www.w3.org/1999/xhtml";
exports.default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g0UZK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _index = require("./selection/index");
exports.default = function(selector) {
    return typeof selector === "string" ? new _index.Selection([
        [
            document.querySelector(selector)
        ]
    ], [
        document.documentElement
    ]) : new _index.Selection([
        [
            selector
        ]
    ], _index.root);
};

},{"./selection/index":"f38xv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"f38xv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "root", ()=>root
);
parcelHelpers.export(exports, "Selection", ()=>Selection
);
var _select = require("./select");
var _selectDefault = parcelHelpers.interopDefault(_select);
var _selectAll = require("./selectAll");
var _selectAllDefault = parcelHelpers.interopDefault(_selectAll);
var _filter = require("./filter");
var _filterDefault = parcelHelpers.interopDefault(_filter);
var _data = require("./data");
var _dataDefault = parcelHelpers.interopDefault(_data);
var _enter = require("./enter");
var _enterDefault = parcelHelpers.interopDefault(_enter);
var _exit = require("./exit");
var _exitDefault = parcelHelpers.interopDefault(_exit);
var _join = require("./join");
var _joinDefault = parcelHelpers.interopDefault(_join);
var _merge = require("./merge");
var _mergeDefault = parcelHelpers.interopDefault(_merge);
var _order = require("./order");
var _orderDefault = parcelHelpers.interopDefault(_order);
var _sort = require("./sort");
var _sortDefault = parcelHelpers.interopDefault(_sort);
var _call = require("./call");
var _callDefault = parcelHelpers.interopDefault(_call);
var _nodes = require("./nodes");
var _nodesDefault = parcelHelpers.interopDefault(_nodes);
var _node = require("./node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
var _size = require("./size");
var _sizeDefault = parcelHelpers.interopDefault(_size);
var _empty = require("./empty");
var _emptyDefault = parcelHelpers.interopDefault(_empty);
var _each = require("./each");
var _eachDefault = parcelHelpers.interopDefault(_each);
var _attr = require("./attr");
var _attrDefault = parcelHelpers.interopDefault(_attr);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _property = require("./property");
var _propertyDefault = parcelHelpers.interopDefault(_property);
var _classed = require("./classed");
var _classedDefault = parcelHelpers.interopDefault(_classed);
var _text = require("./text");
var _textDefault = parcelHelpers.interopDefault(_text);
var _html = require("./html");
var _htmlDefault = parcelHelpers.interopDefault(_html);
var _raise = require("./raise");
var _raiseDefault = parcelHelpers.interopDefault(_raise);
var _lower = require("./lower");
var _lowerDefault = parcelHelpers.interopDefault(_lower);
var _append = require("./append");
var _appendDefault = parcelHelpers.interopDefault(_append);
var _insert = require("./insert");
var _insertDefault = parcelHelpers.interopDefault(_insert);
var _remove = require("./remove");
var _removeDefault = parcelHelpers.interopDefault(_remove);
var _clone = require("./clone");
var _cloneDefault = parcelHelpers.interopDefault(_clone);
var _datum = require("./datum");
var _datumDefault = parcelHelpers.interopDefault(_datum);
var _on = require("./on");
var _onDefault = parcelHelpers.interopDefault(_on);
var _dispatch = require("./dispatch");
var _dispatchDefault = parcelHelpers.interopDefault(_dispatch);
var root = [
    null
];
function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
}
function selection() {
    return new Selection([
        [
            document.documentElement
        ]
    ], root);
}
Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: _selectDefault.default,
    selectAll: _selectAllDefault.default,
    filter: _filterDefault.default,
    data: _dataDefault.default,
    enter: _enterDefault.default,
    exit: _exitDefault.default,
    join: _joinDefault.default,
    merge: _mergeDefault.default,
    order: _orderDefault.default,
    sort: _sortDefault.default,
    call: _callDefault.default,
    nodes: _nodesDefault.default,
    node: _nodeDefault.default,
    size: _sizeDefault.default,
    empty: _emptyDefault.default,
    each: _eachDefault.default,
    attr: _attrDefault.default,
    style: _styleDefault.default,
    property: _propertyDefault.default,
    classed: _classedDefault.default,
    text: _textDefault.default,
    html: _htmlDefault.default,
    raise: _raiseDefault.default,
    lower: _lowerDefault.default,
    append: _appendDefault.default,
    insert: _insertDefault.default,
    remove: _removeDefault.default,
    clone: _cloneDefault.default,
    datum: _datumDefault.default,
    on: _onDefault.default,
    dispatch: _dispatchDefault.default
};
exports.default = selection;

},{"./select":"1jbDi","./selectAll":"cGFzy","./filter":"79RzA","./data":"4ZVP3","./enter":"iCNmI","./exit":"8hgeS","./join":"4nZM4","./merge":"2Dn1o","./order":"g79rT","./sort":"6sxcI","./call":"jtSbo","./nodes":"56G5R","./node":"kRhWy","./size":"26GBx","./empty":"2pmiA","./each":"50lbW","./attr":"aUlJ3","./style":"lVr8f","./property":"49sSE","./classed":"6VMaw","./text":"ch5qt","./html":"jyrYS","./raise":"aWlYS","./lower":"43Imn","./append":"62Ily","./insert":"4D2zc","./remove":"ezirt","./clone":"ERvNe","./datum":"cElUS","./on":"6sHag","./dispatch":"eo73B","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1jbDi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _index = require("./index");
var _selector = require("../selector");
var _selectorDefault = parcelHelpers.interopDefault(_selector);
exports.default = function(select) {
    if (typeof select !== "function") select = _selectorDefault.default(select);
    for(var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i)if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
        }
    }
    return new _index.Selection(subgroups, this._parents);
};

},{"./index":"f38xv","../selector":"e9mWc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e9mWc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function none() {
}
exports.default = function(selector) {
    return selector == null ? none : function() {
        return this.querySelector(selector);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cGFzy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _index = require("./index");
var _selectorAll = require("../selectorAll");
var _selectorAllDefault = parcelHelpers.interopDefault(_selectorAll);
exports.default = function(select) {
    if (typeof select !== "function") select = _selectorAllDefault.default(select);
    for(var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, node, i = 0; i < n; ++i)if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
        }
    }
    return new _index.Selection(subgroups, parents);
};

},{"./index":"f38xv","../selectorAll":"6FR5I","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6FR5I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function empty() {
    return [];
}
exports.default = function(selector) {
    return selector == null ? empty : function() {
        return this.querySelectorAll(selector);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"79RzA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _index = require("./index");
var _matcher = require("../matcher");
var _matcherDefault = parcelHelpers.interopDefault(_matcher);
exports.default = function(match) {
    if (typeof match !== "function") match = _matcherDefault.default(match);
    for(var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i)if ((node = group[i]) && match.call(node, node.__data__, i, group)) subgroup.push(node);
    }
    return new _index.Selection(subgroups, this._parents);
};

},{"./index":"f38xv","../matcher":"5hMoc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5hMoc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(selector) {
    return function() {
        return this.matches(selector);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4ZVP3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _index = require("./index");
var _enter = require("./enter");
var _constant = require("../constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var keyPrefix = "$"; // Protect against keys like “__proto__”.
function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0, node, groupLength = group.length, dataLength = data.length;
    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for(; i < dataLength; ++i)if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
    } else enter[i] = new _enter.EnterNode(parent, data[i]);
    // Put any non-null nodes that don’t fit into exit.
    for(; i < groupLength; ++i)if (node = group[i]) exit[i] = node;
}
function bindKey(parent, group, enter, update, exit, data, key) {
    var i, node, nodeByKeyValue = {
    }, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for(i = 0; i < groupLength; ++i)if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) exit[i] = node;
        else nodeByKeyValue[keyValue] = node;
    }
    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for(i = 0; i < dataLength; ++i){
        keyValue = keyPrefix + key.call(parent, data[i], i, data);
        if (node = nodeByKeyValue[keyValue]) {
            update[i] = node;
            node.__data__ = data[i];
            nodeByKeyValue[keyValue] = null;
        } else enter[i] = new _enter.EnterNode(parent, data[i]);
    }
    // Add any remaining nodes that were not bound to data to exit.
    for(i = 0; i < groupLength; ++i)if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) exit[i] = node;
}
exports.default = function(value, key) {
    if (!value) {
        data = new Array(this.size()), j = -1;
        this.each(function(d) {
            data[++j] = d;
        });
        return data;
    }
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function") value = _constantDefault.default(value);
    for(var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j){
        var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for(var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0)if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while(!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
        }
    }
    update = new _index.Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
};

},{"./index":"f38xv","./enter":"iCNmI","../constant":"2yBTe","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iCNmI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EnterNode", ()=>EnterNode
);
var _sparse = require("./sparse");
var _sparseDefault = parcelHelpers.interopDefault(_sparse);
var _index = require("./index");
exports.default = function() {
    return new _index.Selection(this._enter || this._groups.map(_sparseDefault.default), this._parents);
};
function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
}
EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector) {
        return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
        return this._parent.querySelectorAll(selector);
    }
};

},{"./sparse":"bkLEG","./index":"f38xv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bkLEG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(update) {
    return new Array(update.length);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2yBTe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8hgeS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sparse = require("./sparse");
var _sparseDefault = parcelHelpers.interopDefault(_sparse);
var _index = require("./index");
exports.default = function() {
    return new _index.Selection(this._exit || this._groups.map(_sparseDefault.default), this._parents);
};

},{"./sparse":"bkLEG","./index":"f38xv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4nZM4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null) update = onupdate(update);
    if (onexit == null) exit.remove();
    else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2Dn1o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _index = require("./index");
exports.default = function(selection) {
    for(var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j){
        for(var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i)if (node = group0[i] || group1[i]) merge[i] = node;
    }
    for(; j < m0; ++j)merges[j] = groups0[j];
    return new _index.Selection(merges, this._parents);
};

},{"./index":"f38xv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g79rT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    for(var groups = this._groups, j = -1, m = groups.length; ++j < m;){
        for(var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;)if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
        }
    }
    return this;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6sxcI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _index = require("./index");
exports.default = function(compare) {
    if (!compare) compare = ascending;
    function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }
    for(var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i)if (node = group[i]) sortgroup[i] = node;
        sortgroup.sort(compareNode);
    }
    return new _index.Selection(sortgroups, this._parents).order();
};
function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

},{"./index":"f38xv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jtSbo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"56G5R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() {
        nodes[++i] = this;
    });
    return nodes;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kRhWy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    for(var groups = this._groups, j = 0, m = groups.length; j < m; ++j)for(var group = groups[j], i = 0, n = group.length; i < n; ++i){
        var node = group[i];
        if (node) return node;
    }
    return null;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"26GBx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    var size = 0;
    this.each(function() {
        ++size;
    });
    return size;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2pmiA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    return !this.node();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"50lbW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(callback) {
    for(var groups = this._groups, j = 0, m = groups.length; j < m; ++j){
        for(var group = groups[j], i = 0, n = group.length, node; i < n; ++i)if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
    return this;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aUlJ3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _namespace = require("../namespace");
var _namespaceDefault = parcelHelpers.interopDefault(_namespace);
function attrRemove(name) {
    return function() {
        this.removeAttribute(name);
    };
}
function attrRemoveNS(fullname) {
    return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
    };
}
function attrConstant(name, value) {
    return function() {
        this.setAttribute(name, value);
    };
}
function attrConstantNS(fullname, value) {
    return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
    };
}
function attrFunction(name, value) {
    return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
    };
}
function attrFunctionNS(fullname, value) {
    return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
    };
}
exports.default = function(name, value) {
    var fullname = _namespaceDefault.default(name);
    if (arguments.length < 2) {
        var node = this.node();
        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
};

},{"../namespace":"k6t5I","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lVr8f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styleValue", ()=>styleValue
);
var _window = require("../window");
var _windowDefault = parcelHelpers.interopDefault(_window);
function styleRemove(name) {
    return function() {
        this.style.removeProperty(name);
    };
}
function styleConstant(name, value, priority) {
    return function() {
        this.style.setProperty(name, value, priority);
    };
}
function styleFunction(name, value, priority) {
    return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
    };
}
exports.default = function(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
};
function styleValue(node, name) {
    return node.style.getPropertyValue(name) || _windowDefault.default(node).getComputedStyle(node, null).getPropertyValue(name);
}

},{"../window":"c51LV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c51LV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView; // node is a Document
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"49sSE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function propertyRemove(name) {
    return function() {
        delete this[name];
    };
}
function propertyConstant(name, value) {
    return function() {
        this[name] = value;
    };
}
function propertyFunction(name, value) {
    return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
    };
}
exports.default = function(name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6VMaw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function classArray(string) {
    return string.trim().split(/^|\s+/);
}
function classList(node) {
    return node.classList || new ClassList(node);
}
function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
    add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
            this._names.push(name);
            this._node.setAttribute("class", this._names.join(" "));
        }
    },
    remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
            this._names.splice(i, 1);
            this._node.setAttribute("class", this._names.join(" "));
        }
    },
    contains: function(name) {
        return this._names.indexOf(name) >= 0;
    }
};
function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while(++i < n)list.add(names[i]);
}
function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while(++i < n)list.remove(names[i]);
}
function classedTrue(names) {
    return function() {
        classedAdd(this, names);
    };
}
function classedFalse(names) {
    return function() {
        classedRemove(this, names);
    };
}
function classedFunction(names, value) {
    return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
}
exports.default = function(name, value) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while(++i < n)if (!list.contains(names[i])) return false;
        return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ch5qt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function textRemove() {
    this.textContent = "";
}
function textConstant(value) {
    return function() {
        this.textContent = value;
    };
}
function textFunction(value) {
    return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
    };
}
exports.default = function(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jyrYS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function htmlRemove() {
    this.innerHTML = "";
}
function htmlConstant(value) {
    return function() {
        this.innerHTML = value;
    };
}
function htmlFunction(value) {
    return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
    };
}
exports.default = function(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aWlYS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
}
exports.default = function() {
    return this.each(raise);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"43Imn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
exports.default = function() {
    return this.each(lower);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"62Ily":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _creator = require("../creator");
var _creatorDefault = parcelHelpers.interopDefault(_creator);
exports.default = function(name) {
    var create = typeof name === "function" ? name : _creatorDefault.default(name);
    return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
    });
};

},{"../creator":"hzFln","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4D2zc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _creator = require("../creator");
var _creatorDefault = parcelHelpers.interopDefault(_creator);
var _selector = require("../selector");
var _selectorDefault = parcelHelpers.interopDefault(_selector);
function constantNull() {
    return null;
}
exports.default = function(name, before) {
    var create = typeof name === "function" ? name : _creatorDefault.default(name), select = before == null ? constantNull : typeof before === "function" ? before : _selectorDefault.default(before);
    return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
};

},{"../creator":"hzFln","../selector":"e9mWc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ezirt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
}
exports.default = function() {
    return this.each(remove);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ERvNe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
exports.default = function(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cElUS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6sHag":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "event", ()=>event1
);
parcelHelpers.export(exports, "customEvent", ()=>customEvent
);
var filterEvents = {
};
var event1 = null;
if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!("onmouseenter" in element)) filterEvents = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };
}
function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function(event) {
        var related = event.relatedTarget;
        if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) listener.call(this, event);
    };
}
function contextListener(listener, index, group) {
    return function(event11) {
        var event0 = event1; // Events can be reentrant (e.g., focus).
        event1 = event11;
        try {
            listener.call(this, this.__data__, index, group);
        } finally{
            event1 = event0;
        }
    };
}
function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {
            type: t,
            name: name
        };
    });
}
function onRemove(typename) {
    return function() {
        var on = this.__on;
        if (!on) return;
        for(var j = 0, i = -1, m = on.length, o; j < m; ++j)if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) this.removeEventListener(o.type, o.listener, o.capture);
        else on[++i] = o;
        if (++i) on.length = i;
        else delete this.__on;
    };
}
function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function(d, i, group) {
        var on = this.__on, o, listener = wrap(value, i, group);
        if (on) {
            for(var j = 0, m = on.length; j < m; ++j)if ((o = on[j]).type === typename.type && o.name === typename.name) {
                this.removeEventListener(o.type, o.listener, o.capture);
                this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                o.value = value;
                return;
            }
        }
        this.addEventListener(typename.type, listener, capture);
        o = {
            type: typename.type,
            name: typename.name,
            value: value,
            listener: listener,
            capture: capture
        };
        if (!on) this.__on = [
            o
        ];
        else on.push(o);
    };
}
exports.default = function(typename, value, capture) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
    if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for(var j = 0, m = on.length, o; j < m; ++j)for(i = 0, o = on[j]; i < n; ++i){
            if ((t = typenames[i]).type === o.type && t.name === o.name) return o.value;
        }
        return;
    }
    on = value ? onAdd : onRemove;
    if (capture == null) capture = false;
    for(i = 0; i < n; ++i)this.each(on(typenames[i], value, capture));
    return this;
};
function customEvent(event12, listener, that, args) {
    var event0 = event1;
    event12.sourceEvent = event1;
    event1 = event12;
    try {
        return listener.apply(that, args);
    } finally{
        event1 = event0;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eo73B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _window = require("../window");
var _windowDefault = parcelHelpers.interopDefault(_window);
function dispatchEvent(node, type, params) {
    var window = _windowDefault.default(node), event = window.CustomEvent;
    if (typeof event === "function") event = new event(type, params);
    else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
    }
    node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
    return function() {
        return dispatchEvent(this, type, params);
    };
}
function dispatchFunction(type, params) {
    return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
    };
}
exports.default = function(type, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
};

},{"../window":"c51LV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"85ofP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var nextId = 0;
function local() {
    return new Local;
}
exports.default = local;
function Local() {
    this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
    constructor: Local,
    get: function(node) {
        var id = this._;
        while(!(id in node))if (!(node = node.parentNode)) return;
        return node[id];
    },
    set: function(node, value) {
        return node[this._] = value;
    },
    remove: function(node) {
        return this._ in node && delete node[this._];
    },
    toString: function() {
        return this._;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eVYQP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sourceEvent = require("./sourceEvent");
var _sourceEventDefault = parcelHelpers.interopDefault(_sourceEvent);
var _point = require("./point");
var _pointDefault = parcelHelpers.interopDefault(_point);
exports.default = function(node) {
    var event = _sourceEventDefault.default();
    if (event.changedTouches) event = event.changedTouches[0];
    return _pointDefault.default(node, event);
};

},{"./sourceEvent":"3beDu","./point":"4ZAQb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3beDu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _on = require("./selection/on");
exports.default = function() {
    var current = _on.event, source;
    while(source = current.sourceEvent)current = source;
    return current;
};

},{"./selection/on":"6sHag","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4ZAQb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(node, event) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [
            point.x,
            point.y
        ];
    }
    var rect = node.getBoundingClientRect();
    return [
        event.clientX - rect.left - node.clientLeft,
        event.clientY - rect.top - node.clientTop
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lhfgm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _index = require("./selection/index");
exports.default = function(selector) {
    return typeof selector === "string" ? new _index.Selection([
        document.querySelectorAll(selector)
    ], [
        document.documentElement
    ]) : new _index.Selection([
        selector == null ? [] : selector
    ], _index.root);
};

},{"./selection/index":"f38xv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Slti":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sourceEvent = require("./sourceEvent");
var _sourceEventDefault = parcelHelpers.interopDefault(_sourceEvent);
var _point = require("./point");
var _pointDefault = parcelHelpers.interopDefault(_point);
exports.default = function(node, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = _sourceEventDefault.default().changedTouches;
    for(var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i){
        if ((touch = touches[i]).identifier === identifier) return _pointDefault.default(node, touch);
    }
    return null;
};

},{"./sourceEvent":"3beDu","./point":"4ZAQb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kvGcQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sourceEvent = require("./sourceEvent");
var _sourceEventDefault = parcelHelpers.interopDefault(_sourceEvent);
var _point = require("./point");
var _pointDefault = parcelHelpers.interopDefault(_point);
exports.default = function(node, touches) {
    if (touches == null) touches = _sourceEventDefault.default().touches;
    for(var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i)points[i] = _pointDefault.default(node, touches[i]);
    return points;
};

},{"./sourceEvent":"3beDu","./point":"4ZAQb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1WTbI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "yesdrag", ()=>yesdrag
);
var _d3Selection = require("d3-selection");
var _noeventJs = require("./noevent.js");
var _noeventJsDefault = parcelHelpers.interopDefault(_noeventJs);
exports.default = function(view) {
    var root = view.document.documentElement, selection = _d3Selection.select(view).on("dragstart.drag", _noeventJsDefault.default, true);
    if ("onselectstart" in root) selection.on("selectstart.drag", _noeventJsDefault.default, true);
    else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
    }
};
function yesdrag(view, noclick) {
    var root = view.document.documentElement, selection = _d3Selection.select(view).on("dragstart.drag", null);
    if (noclick) {
        selection.on("click.drag", _noeventJsDefault.default, true);
        setTimeout(function() {
            selection.on("click.drag", null);
        }, 0);
    }
    if ("onselectstart" in root) selection.on("selectstart.drag", null);
    else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
    }
}

},{"d3-selection":"hgWtk","./noevent.js":"hhrgp","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hhrgp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nopropagation", ()=>nopropagation
);
var _d3Selection = require("d3-selection");
function nopropagation() {
    _d3Selection.event.stopImmediatePropagation();
}
exports.default = function() {
    _d3Selection.event.preventDefault();
    _d3Selection.event.stopImmediatePropagation();
};

},{"d3-selection":"hgWtk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kBgzJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Vdpe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
    this.target = target;
    this.type = type;
    this.subject = subject;
    this.identifier = id;
    this.active = active;
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.dy = dy;
    this._ = dispatch;
}
exports.default = DragEvent;
DragEvent.prototype.on = function() {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e7XwA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "interpolate", ()=>_valueJsDefault.default
);
parcelHelpers.export(exports, "interpolateArray", ()=>_arrayJsDefault.default
);
parcelHelpers.export(exports, "interpolateBasis", ()=>_basisJsDefault.default
);
parcelHelpers.export(exports, "interpolateBasisClosed", ()=>_basisClosedJsDefault.default
);
parcelHelpers.export(exports, "interpolateDate", ()=>_dateJsDefault.default
);
parcelHelpers.export(exports, "interpolateDiscrete", ()=>_discreteJsDefault.default
);
parcelHelpers.export(exports, "interpolateHue", ()=>_hueJsDefault.default
);
parcelHelpers.export(exports, "interpolateNumber", ()=>_numberJsDefault.default
);
parcelHelpers.export(exports, "interpolateNumberArray", ()=>_numberArrayJsDefault.default
);
parcelHelpers.export(exports, "interpolateObject", ()=>_objectJsDefault.default
);
parcelHelpers.export(exports, "interpolateRound", ()=>_roundJsDefault.default
);
parcelHelpers.export(exports, "interpolateString", ()=>_stringJsDefault.default
);
parcelHelpers.export(exports, "interpolateTransformCss", ()=>_indexJs.interpolateTransformCss
);
parcelHelpers.export(exports, "interpolateTransformSvg", ()=>_indexJs.interpolateTransformSvg
);
parcelHelpers.export(exports, "interpolateZoom", ()=>_zoomJsDefault.default
);
parcelHelpers.export(exports, "interpolateRgb", ()=>_rgbJsDefault.default
);
parcelHelpers.export(exports, "interpolateRgbBasis", ()=>_rgbJs.rgbBasis
);
parcelHelpers.export(exports, "interpolateRgbBasisClosed", ()=>_rgbJs.rgbBasisClosed
);
parcelHelpers.export(exports, "interpolateHsl", ()=>_hslJsDefault.default
);
parcelHelpers.export(exports, "interpolateHslLong", ()=>_hslJs.hslLong
);
parcelHelpers.export(exports, "interpolateLab", ()=>_labJsDefault.default
);
parcelHelpers.export(exports, "interpolateHcl", ()=>_hclJsDefault.default
);
parcelHelpers.export(exports, "interpolateHclLong", ()=>_hclJs.hclLong
);
parcelHelpers.export(exports, "interpolateCubehelix", ()=>_cubehelixJsDefault.default
);
parcelHelpers.export(exports, "interpolateCubehelixLong", ()=>_cubehelixJs.cubehelixLong
);
parcelHelpers.export(exports, "piecewise", ()=>_piecewiseJsDefault.default
);
parcelHelpers.export(exports, "quantize", ()=>_quantizeJsDefault.default
);
var _valueJs = require("./value.js");
var _valueJsDefault = parcelHelpers.interopDefault(_valueJs);
var _arrayJs = require("./array.js");
var _arrayJsDefault = parcelHelpers.interopDefault(_arrayJs);
var _basisJs = require("./basis.js");
var _basisJsDefault = parcelHelpers.interopDefault(_basisJs);
var _basisClosedJs = require("./basisClosed.js");
var _basisClosedJsDefault = parcelHelpers.interopDefault(_basisClosedJs);
var _dateJs = require("./date.js");
var _dateJsDefault = parcelHelpers.interopDefault(_dateJs);
var _discreteJs = require("./discrete.js");
var _discreteJsDefault = parcelHelpers.interopDefault(_discreteJs);
var _hueJs = require("./hue.js");
var _hueJsDefault = parcelHelpers.interopDefault(_hueJs);
var _numberJs = require("./number.js");
var _numberJsDefault = parcelHelpers.interopDefault(_numberJs);
var _numberArrayJs = require("./numberArray.js");
var _numberArrayJsDefault = parcelHelpers.interopDefault(_numberArrayJs);
var _objectJs = require("./object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _roundJs = require("./round.js");
var _roundJsDefault = parcelHelpers.interopDefault(_roundJs);
var _stringJs = require("./string.js");
var _stringJsDefault = parcelHelpers.interopDefault(_stringJs);
var _indexJs = require("./transform/index.js");
var _zoomJs = require("./zoom.js");
var _zoomJsDefault = parcelHelpers.interopDefault(_zoomJs);
var _rgbJs = require("./rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
var _hslJs = require("./hsl.js");
var _hslJsDefault = parcelHelpers.interopDefault(_hslJs);
var _labJs = require("./lab.js");
var _labJsDefault = parcelHelpers.interopDefault(_labJs);
var _hclJs = require("./hcl.js");
var _hclJsDefault = parcelHelpers.interopDefault(_hclJs);
var _cubehelixJs = require("./cubehelix.js");
var _cubehelixJsDefault = parcelHelpers.interopDefault(_cubehelixJs);
var _piecewiseJs = require("./piecewise.js");
var _piecewiseJsDefault = parcelHelpers.interopDefault(_piecewiseJs);
var _quantizeJs = require("./quantize.js");
var _quantizeJsDefault = parcelHelpers.interopDefault(_quantizeJs);

},{"./value.js":"jfpB7","./array.js":"6pPWc","./basis.js":"1DJ3x","./basisClosed.js":"d28oA","./date.js":"9vQgC","./discrete.js":"kbqZc","./hue.js":"5ldU4","./number.js":"igEfY","./numberArray.js":"lBrzO","./object.js":"cDojd","./round.js":"c4KDA","./string.js":"hmd3K","./transform/index.js":"etDRQ","./zoom.js":"HiDI0","./rgb.js":"9bAoa","./hsl.js":"8lFt4","./lab.js":"h1Bcf","./hcl.js":"1qHkm","./cubehelix.js":"9aK10","./piecewise.js":"bex0T","./quantize.js":"fWEIz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jfpB7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Color = require("d3-color");
var _rgbJs = require("./rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
var _arrayJs = require("./array.js");
var _dateJs = require("./date.js");
var _dateJsDefault = parcelHelpers.interopDefault(_dateJs);
var _numberJs = require("./number.js");
var _numberJsDefault = parcelHelpers.interopDefault(_numberJs);
var _objectJs = require("./object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _stringJs = require("./string.js");
var _stringJsDefault = parcelHelpers.interopDefault(_stringJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _numberArrayJs = require("./numberArray.js");
var _numberArrayJsDefault = parcelHelpers.interopDefault(_numberArrayJs);
exports.default = function(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? _constantJsDefault.default(b) : (t === "number" ? _numberJsDefault.default : t === "string" ? (c = _d3Color.color(b)) ? (b = c, _rgbJsDefault.default) : _stringJsDefault.default : b instanceof _d3Color.color ? _rgbJsDefault.default : b instanceof Date ? _dateJsDefault.default : _numberArrayJs.isNumberArray(b) ? _numberArrayJsDefault.default : Array.isArray(b) ? _arrayJs.genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _objectJsDefault.default : _numberJsDefault.default)(a, b);
};

},{"d3-color":"ap3Jg","./rgb.js":"9bAoa","./array.js":"6pPWc","./date.js":"9vQgC","./number.js":"igEfY","./object.js":"cDojd","./string.js":"hmd3K","./constant.js":"hWtul","./numberArray.js":"lBrzO","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ap3Jg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "color", ()=>_colorJsDefault.default
);
parcelHelpers.export(exports, "rgb", ()=>_colorJs.rgb
);
parcelHelpers.export(exports, "hsl", ()=>_colorJs.hsl
);
parcelHelpers.export(exports, "lab", ()=>_labJsDefault.default
);
parcelHelpers.export(exports, "hcl", ()=>_labJs.hcl
);
parcelHelpers.export(exports, "lch", ()=>_labJs.lch
);
parcelHelpers.export(exports, "gray", ()=>_labJs.gray
);
parcelHelpers.export(exports, "cubehelix", ()=>_cubehelixJsDefault.default
);
var _colorJs = require("./color.js");
var _colorJsDefault = parcelHelpers.interopDefault(_colorJs);
var _labJs = require("./lab.js");
var _labJsDefault = parcelHelpers.interopDefault(_labJs);
var _cubehelixJs = require("./cubehelix.js");
var _cubehelixJsDefault = parcelHelpers.interopDefault(_cubehelixJs);

},{"./color.js":"hAUDV","./lab.js":"50Bjg","./cubehelix.js":"68X6M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hAUDV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Color", ()=>Color
);
parcelHelpers.export(exports, "darker", ()=>darker
);
parcelHelpers.export(exports, "brighter", ()=>brighter
);
parcelHelpers.export(exports, "rgbConvert", ()=>rgbConvert
);
parcelHelpers.export(exports, "rgb", ()=>rgb
);
parcelHelpers.export(exports, "Rgb", ()=>Rgb
);
parcelHelpers.export(exports, "hslConvert", ()=>hslConvert
);
parcelHelpers.export(exports, "hsl", ()=>hsl
);
var _defineJs = require("./define.js");
var _defineJsDefault = parcelHelpers.interopDefault(_defineJs);
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [
    reI,
    reI,
    reI
] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [
    reP,
    reP,
    reP
] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [
    reI,
    reI,
    reI,
    reN
] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [
    reP,
    reP,
    reP,
    reN
] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [
    reN,
    reP,
    reP
] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [
    reN,
    reP,
    reP,
    reN
] + "\\)$");
var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
};
_defineJsDefault.default(Color, color, {
    copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
    },
    displayable: function() {
        return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
});
function color_formatHex() {
    return this.rgb().formatHex();
}
function color_formatHsl() {
    return hslConvert(this).formatHsl();
}
function color_formatRgb() {
    return this.rgb().formatRgb();
}
function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
     : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) // #f00
     : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) // #ff000000
     : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) // #f000
     : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
     : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
     : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
     : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
     : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
     : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
     : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
     : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
exports.default = color;
function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
}
_defineJsDefault.default(Rgb, rgb, _defineJs.extend(Color, {
    brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
        return this;
    },
    displayable: function() {
        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
}));
function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
}
function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
    if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
    } else s = l > 0 && l < 1 ? 0 : h;
    return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
}
_defineJsDefault.default(Hsl, hsl, _defineJs.extend(Color, {
    brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl: function() {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
    }
}));
/* From FvD 13.37, CSS Color Module Level 3 */ function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

},{"./define.js":"5yZbK","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5yZbK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extend", ()=>extend
);
exports.default = function(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
};
function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for(var key in definition)prototype[key] = definition[key];
    return prototype;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"50Bjg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gray", ()=>gray
);
parcelHelpers.export(exports, "Lab", ()=>Lab
);
parcelHelpers.export(exports, "lch", ()=>lch
);
parcelHelpers.export(exports, "hcl", ()=>hcl
);
parcelHelpers.export(exports, "Hcl", ()=>Hcl
);
var _defineJs = require("./define.js");
var _defineJsDefault = parcelHelpers.interopDefault(_defineJs);
var _colorJs = require("./color.js");
var _mathJs = require("./math.js");
// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1;
function labConvert(o) {
    if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl) return hcl2lab(o);
    if (!(o instanceof _colorJs.Rgb)) o = _colorJs.rgbConvert(o);
    var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
    if (r === g && g === b) x = z = y;
    else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
    }
    return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function gray(l, opacity) {
    return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}
function lab(l, a, b, opacity) {
    return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
exports.default = lab;
function Lab(l, a, b, opacity) {
    this.l = +l;
    this.a = +a;
    this.b = +b;
    this.opacity = +opacity;
}
_defineJsDefault.default(Lab, lab, _defineJs.extend(_colorJs.Color, {
    brighter: function(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    darker: function(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    rgb: function() {
        var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new _colorJs.Rgb(lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
    }
}));
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
    if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab)) o = labConvert(o);
    if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
    var h = Math.atan2(o.b, o.a) * _mathJs.rad2deg;
    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function lch(l, c, h, opacity) {
    return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function hcl(h, c, l, opacity) {
    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
    this.h = +h;
    this.c = +c;
    this.l = +l;
    this.opacity = +opacity;
}
function hcl2lab(o) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * _mathJs.deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
_defineJsDefault.default(Hcl, hcl, _defineJs.extend(_colorJs.Color, {
    brighter: function(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
    },
    darker: function(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
    },
    rgb: function() {
        return hcl2lab(this).rgb();
    }
}));

},{"./define.js":"5yZbK","./color.js":"hAUDV","./math.js":"djUwo","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"djUwo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "deg2rad", ()=>deg2rad
);
parcelHelpers.export(exports, "rad2deg", ()=>rad2deg
);
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"68X6M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Cubehelix", ()=>Cubehelix
);
var _defineJs = require("./define.js");
var _defineJsDefault = parcelHelpers.interopDefault(_defineJs);
var _colorJs = require("./color.js");
var _mathJs = require("./math.js");
var A = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
function cubehelixConvert(o) {
    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof _colorJs.Rgb)) o = _colorJs.rgbConvert(o);
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * _mathJs.rad2deg - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
exports.default = cubehelix;
function Cubehelix(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
}
_defineJsDefault.default(Cubehelix, cubehelix, _defineJs.extend(_colorJs.Color, {
    brighter: function(k) {
        k = k == null ? _colorJs.brighter : Math.pow(_colorJs.brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
        k = k == null ? _colorJs.darker : Math.pow(_colorJs.darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * _mathJs.deg2rad, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
        return new _colorJs.Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
    }
}));

},{"./define.js":"5yZbK","./color.js":"hAUDV","./math.js":"djUwo","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9bAoa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rgbBasis", ()=>rgbBasis
);
parcelHelpers.export(exports, "rgbBasisClosed", ()=>rgbBasisClosed
);
var _d3Color = require("d3-color");
var _basisJs = require("./basis.js");
var _basisJsDefault = parcelHelpers.interopDefault(_basisJs);
var _basisClosedJs = require("./basisClosed.js");
var _basisClosedJsDefault = parcelHelpers.interopDefault(_basisClosedJs);
var _colorJs = require("./color.js");
var _colorJsDefault = parcelHelpers.interopDefault(_colorJs);
exports.default = (function rgbGamma(y) {
    var color = _colorJs.gamma(y);
    function rgb(start, end) {
        var r = color((start = _d3Color.rgb(start)).r, (end = _d3Color.rgb(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = _colorJsDefault.default(start.opacity, end.opacity);
        return function(t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
        };
    }
    rgb.gamma = rgbGamma;
    return rgb;
})(1);
function rgbSpline(spline) {
    return function(colors) {
        var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color;
        for(i = 0; i < n; ++i){
            color = _d3Color.rgb(colors[i]);
            r[i] = color.r || 0;
            g[i] = color.g || 0;
            b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
            color.r = r(t);
            color.g = g(t);
            color.b = b(t);
            return color + "";
        };
    };
}
var rgbBasis = rgbSpline(_basisJsDefault.default);
var rgbBasisClosed = rgbSpline(_basisClosedJsDefault.default);

},{"d3-color":"ap3Jg","./basis.js":"1DJ3x","./basisClosed.js":"d28oA","./color.js":"8Wcc3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1DJ3x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "basis", ()=>basis
);
function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
exports.default = function(values) {
    var n = values.length - 1;
    return function(t) {
        var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis((t - i / n) * n, v0, v1, v2, v3);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"d28oA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _basisJs = require("./basis.js");
exports.default = function(values) {
    var n = values.length;
    return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
        return _basisJs.basis((t - i / n) * n, v0, v1, v2, v3);
    };
};

},{"./basis.js":"1DJ3x","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8Wcc3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hue", ()=>hue
);
parcelHelpers.export(exports, "gamma", ()=>gamma
);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
function linear(a, d) {
    return function(t) {
        return a + t * d;
    };
}
function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
    };
}
function hue(a, b) {
    var d = b - a;
    return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : _constantJsDefault.default(isNaN(a) ? b : a);
}
function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y) : _constantJsDefault.default(isNaN(a) ? b : a);
    };
}
function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : _constantJsDefault.default(isNaN(a) ? b : a);
}
exports.default = nogamma;

},{"./constant.js":"hWtul","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hWtul":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6pPWc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "genericArray", ()=>genericArray
);
var _valueJs = require("./value.js");
var _valueJsDefault = parcelHelpers.interopDefault(_valueJs);
var _numberArrayJs = require("./numberArray.js");
var _numberArrayJsDefault = parcelHelpers.interopDefault(_numberArrayJs);
exports.default = function(a, b) {
    return (_numberArrayJs.isNumberArray(b) ? _numberArrayJsDefault.default : genericArray)(a, b);
};
function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for(i = 0; i < na; ++i)x[i] = _valueJsDefault.default(a[i], b[i]);
    for(; i < nb; ++i)c[i] = b[i];
    return function(t) {
        for(i = 0; i < na; ++i)c[i] = x[i](t);
        return c;
    };
}

},{"./value.js":"jfpB7","./numberArray.js":"lBrzO","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lBrzO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNumberArray", ()=>isNumberArray
);
exports.default = function(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
        for(i = 0; i < n; ++i)c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
    };
};
function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9vQgC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"igEfY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b) {
    return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cDojd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _valueJs = require("./value.js");
var _valueJsDefault = parcelHelpers.interopDefault(_valueJs);
exports.default = function(a, b) {
    var i = {
    }, c = {
    }, k;
    if (a === null || typeof a !== "object") a = {
    };
    if (b === null || typeof b !== "object") b = {
    };
    for(k in b)if (k in a) i[k] = _valueJsDefault.default(a[k], b[k]);
    else c[k] = b[k];
    return function(t) {
        for(k in i)c[k] = i[k](t);
        return c;
    };
};

},{"./value.js":"jfpB7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hmd3K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _numberJs = require("./number.js");
var _numberJsDefault = parcelHelpers.interopDefault(_numberJs);
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
    return function() {
        return b;
    };
}
function one(b) {
    return function(t) {
        return b(t) + "";
    };
}
exports.default = function(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i1 = -1, s = [], q = []; // number interpolators
    // Coerce inputs to strings.
    a = a + "", b = b + "";
    // Interpolate pairs of numbers in a & b.
    while((am = reA.exec(a)) && (bm = reB.exec(b))){
        if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i1]) s[i1] += bs; // coalesce with previous string
            else s[++i1] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
            if (s[i1]) s[i1] += bm; // coalesce with previous string
            else s[++i1] = bm;
        } else {
            s[++i1] = null;
            q.push({
                i: i1,
                x: _numberJsDefault.default(am, bm)
            });
        }
        bi = reB.lastIndex;
    }
    // Add remains of b.
    if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i1]) s[i1] += bs; // coalesce with previous string
        else s[++i1] = bs;
    }
    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
        for(var i = 0, o; i < b; ++i)s[(o = q[i]).i] = o.x(t);
        return s.join("");
    });
};

},{"./number.js":"igEfY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kbqZc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(range) {
    var n = range.length;
    return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5ldU4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorJs = require("./color.js");
exports.default = function(a, b) {
    var i = _colorJs.hue(+a, +b);
    return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
    };
};

},{"./color.js":"8Wcc3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c4KDA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b) {
    return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"etDRQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "interpolateTransformCss", ()=>interpolateTransformCss
);
parcelHelpers.export(exports, "interpolateTransformSvg", ()=>interpolateTransformSvg
);
var _numberJs = require("../number.js");
var _numberJsDefault = parcelHelpers.interopDefault(_numberJs);
var _parseJs = require("./parse.js");
function interpolateTransform(parse, pxComma, pxParen, degParen) {
    function pop(s) {
        return s.length ? s.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
            var i = s.push("translate(", null, pxComma, null, pxParen);
            q.push({
                i: i - 4,
                x: _numberJsDefault.default(xa, xb)
            }, {
                i: i - 2,
                x: _numberJsDefault.default(ya, yb)
            });
        } else if (xb || yb) s.push("translate(" + xb + pxComma + yb + pxParen);
    }
    function rotate(a, b, s, q) {
        if (a !== b) {
            if (a - b > 180) b += 360;
            else if (b - a > 180) a += 360; // shortest path
            q.push({
                i: s.push(pop(s) + "rotate(", null, degParen) - 2,
                x: _numberJsDefault.default(a, b)
            });
        } else if (b) s.push(pop(s) + "rotate(" + b + degParen);
    }
    function skewX(a, b, s, q) {
        if (a !== b) q.push({
            i: s.push(pop(s) + "skewX(", null, degParen) - 2,
            x: _numberJsDefault.default(a, b)
        });
        else if (b) s.push(pop(s) + "skewX(" + b + degParen);
    }
    function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
            var i = s.push(pop(s) + "scale(", null, ",", null, ")");
            q.push({
                i: i - 4,
                x: _numberJsDefault.default(xa, xb)
            }, {
                i: i - 2,
                x: _numberJsDefault.default(ya, yb)
            });
        } else if (xb !== 1 || yb !== 1) s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
    return function(a, b) {
        var s = [], q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
            var i = -1, n = q.length, o;
            while(++i < n)s[(o = q[i]).i] = o.x(t);
            return s.join("");
        };
    };
}
var interpolateTransformCss = interpolateTransform(_parseJs.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parseJs.parseSvg, ", ", ")", ")");

},{"../number.js":"igEfY","./parse.js":"TQc0q","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"TQc0q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseCss", ()=>parseCss
);
parcelHelpers.export(exports, "parseSvg", ()=>parseSvg
);
var _decomposeJs = require("./decompose.js");
var _decomposeJsDefault = parcelHelpers.interopDefault(_decomposeJs);
var cssNode, cssRoot, cssView, svgNode;
function parseCss(value) {
    if (value === "none") return _decomposeJs.identity;
    if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
    cssNode.style.transform = value;
    value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
    cssRoot.removeChild(cssNode);
    value = value.slice(7, -1).split(",");
    return _decomposeJsDefault.default(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
    if (value == null) return _decomposeJs.identity;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return _decomposeJs.identity;
    value = value.matrix;
    return _decomposeJsDefault.default(value.a, value.b, value.c, value.d, value.e, value.f);
}

},{"./decompose.js":"CTixW","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"CTixW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity
);
var degrees = 180 / Math.PI;
var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
};
exports.default = function(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX: scaleX,
        scaleY: scaleY
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"HiDI0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var rho = Math.SQRT2, rho2 = 2, rho4 = 4, epsilon2 = 0.000000000001;
function cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
exports.default = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
        S = Math.log(w1 / w0) / rho;
        i = function(t) {
            return [
                ux0 + t * dx,
                uy0 + t * dy,
                w0 * Math.exp(rho * t * S)
            ];
        };
    } else {
        var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S = (r1 - r0) / rho;
        i = function(t) {
            var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
                ux0 + u * dx,
                uy0 + u * dy,
                w0 * coshr0 / cosh(rho * s + r0)
            ];
        };
    }
    i.duration = S * 1000;
    return i;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8lFt4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hslLong", ()=>hslLong
);
var _d3Color = require("d3-color");
var _colorJs = require("./color.js");
var _colorJsDefault = parcelHelpers.interopDefault(_colorJs);
function hsl(hue) {
    return function(start, end) {
        var h = hue((start = _d3Color.hsl(start)).h, (end = _d3Color.hsl(end)).h), s = _colorJsDefault.default(start.s, end.s), l = _colorJsDefault.default(start.l, end.l), opacity = _colorJsDefault.default(start.opacity, end.opacity);
        return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(t);
            start.opacity = opacity(t);
            return start + "";
        };
    };
}
exports.default = hsl(_colorJs.hue);
var hslLong = hsl(_colorJsDefault.default);

},{"d3-color":"ap3Jg","./color.js":"8Wcc3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"h1Bcf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Color = require("d3-color");
var _colorJs = require("./color.js");
var _colorJsDefault = parcelHelpers.interopDefault(_colorJs);
function lab(start, end) {
    var l = _colorJsDefault.default((start = _d3Color.lab(start)).l, (end = _d3Color.lab(end)).l), a = _colorJsDefault.default(start.a, end.a), b = _colorJsDefault.default(start.b, end.b), opacity = _colorJsDefault.default(start.opacity, end.opacity);
    return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
    };
}
exports.default = lab;

},{"d3-color":"ap3Jg","./color.js":"8Wcc3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1qHkm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hclLong", ()=>hclLong
);
var _d3Color = require("d3-color");
var _colorJs = require("./color.js");
var _colorJsDefault = parcelHelpers.interopDefault(_colorJs);
function hcl(hue) {
    return function(start, end) {
        var h = hue((start = _d3Color.hcl(start)).h, (end = _d3Color.hcl(end)).h), c = _colorJsDefault.default(start.c, end.c), l = _colorJsDefault.default(start.l, end.l), opacity = _colorJsDefault.default(start.opacity, end.opacity);
        return function(t) {
            start.h = h(t);
            start.c = c(t);
            start.l = l(t);
            start.opacity = opacity(t);
            return start + "";
        };
    };
}
exports.default = hcl(_colorJs.hue);
var hclLong = hcl(_colorJsDefault.default);

},{"d3-color":"ap3Jg","./color.js":"8Wcc3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9aK10":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cubehelixLong", ()=>cubehelixLong
);
var _d3Color = require("d3-color");
var _colorJs = require("./color.js");
var _colorJsDefault = parcelHelpers.interopDefault(_colorJs);
function cubehelix1(hue) {
    return (function cubehelixGamma(y) {
        y = +y;
        function cubehelix(start, end) {
            var h = hue((start = _d3Color.cubehelix(start)).h, (end = _d3Color.cubehelix(end)).h), s = _colorJsDefault.default(start.s, end.s), l = _colorJsDefault.default(start.l, end.l), opacity = _colorJsDefault.default(start.opacity, end.opacity);
            return function(t) {
                start.h = h(t);
                start.s = s(t);
                start.l = l(Math.pow(t, y));
                start.opacity = opacity(t);
                return start + "";
            };
        }
        cubehelix.gamma = cubehelixGamma;
        return cubehelix;
    })(1);
}
exports.default = cubehelix1(_colorJs.hue);
var cubehelixLong = cubehelix1(_colorJsDefault.default);

},{"d3-color":"ap3Jg","./color.js":"8Wcc3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bex0T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function piecewise(interpolate, values) {
    var i1 = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
    while(i1 < n)I[i1] = interpolate(v, v = values[++i1]);
    return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
    };
}
exports.default = piecewise;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fWEIz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(interpolator, n) {
    var samples = new Array(n);
    for(var i = 0; i < n; ++i)samples[i] = interpolator(i / (n - 1));
    return samples;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cRYyR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transition", ()=>_indexJsDefault.default
);
parcelHelpers.export(exports, "active", ()=>_activeJsDefault.default
);
parcelHelpers.export(exports, "interrupt", ()=>_interruptJsDefault.default
);
var _indexJs = require("./selection/index.js");
var _indexJs1 = require("./transition/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs1);
var _activeJs = require("./active.js");
var _activeJsDefault = parcelHelpers.interopDefault(_activeJs);
var _interruptJs = require("./interrupt.js");
var _interruptJsDefault = parcelHelpers.interopDefault(_interruptJs);

},{"./selection/index.js":"gNdN5","./transition/index.js":"18i1e","./active.js":"e5Mev","./interrupt.js":"d4VjA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gNdN5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _d3Selection = require("d3-selection");
var _interruptJs = require("./interrupt.js");
var _interruptJsDefault = parcelHelpers.interopDefault(_interruptJs);
var _transitionJs = require("./transition.js");
var _transitionJsDefault = parcelHelpers.interopDefault(_transitionJs);
_d3Selection.selection.prototype.interrupt = _interruptJsDefault.default;
_d3Selection.selection.prototype.transition = _transitionJsDefault.default;

},{"d3-selection":"hgWtk","./interrupt.js":"hoP2s","./transition.js":"7r67v","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hoP2s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _interruptJs = require("../interrupt.js");
var _interruptJsDefault = parcelHelpers.interopDefault(_interruptJs);
exports.default = function(name) {
    return this.each(function() {
        _interruptJsDefault.default(this, name);
    });
};

},{"../interrupt.js":"d4VjA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"d4VjA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduleJs = require("./transition/schedule.js");
exports.default = function(node, name) {
    var schedules = node.__transition, schedule, active, empty = true, i;
    if (!schedules) return;
    name = name == null ? null : name + "";
    for(i in schedules){
        if ((schedule = schedules[i]).name !== name) {
            empty = false;
            continue;
        }
        active = schedule.state > _scheduleJs.STARTING && schedule.state < _scheduleJs.ENDING;
        schedule.state = _scheduleJs.ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
    }
    if (empty) delete node.__transition;
};

},{"./transition/schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dTpjR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CREATED", ()=>CREATED
);
parcelHelpers.export(exports, "SCHEDULED", ()=>SCHEDULED
);
parcelHelpers.export(exports, "STARTING", ()=>STARTING
);
parcelHelpers.export(exports, "STARTED", ()=>STARTED
);
parcelHelpers.export(exports, "RUNNING", ()=>RUNNING
);
parcelHelpers.export(exports, "ENDING", ()=>ENDING
);
parcelHelpers.export(exports, "ENDED", ()=>ENDED
);
parcelHelpers.export(exports, "init", ()=>init
);
parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "get", ()=>get
);
var _d3Dispatch = require("d3-dispatch");
var _d3Timer = require("d3-timer");
var emptyOn = _d3Dispatch.dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
exports.default = function(node, name, id, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules) node.__transition = {
    };
    else if (id in schedules) return;
    create(node, id, {
        name: name,
        index: index,
        group: group,
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
    });
};
function init(node, id) {
    var schedule = get(node, id);
    if (schedule.state > CREATED) throw new Error("too late; already scheduled");
    return schedule;
}
function set(node, id) {
    var schedule = get(node, id);
    if (schedule.state > STARTED) throw new Error("too late; already running");
    return schedule;
}
function get(node, id) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
    return schedule;
}
function create(node, id, self) {
    var schedules = node.__transition, tween;
    // Initialize the self timer when the transition is created.
    // Note the actual delay is not known until the first callback!
    schedules[id] = self;
    self.timer = _d3Timer.timer(schedule, 0, self.time);
    function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);
        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
    }
    function start(elapsed) {
        var i, j, n, o;
        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();
        for(i in schedules){
            o = schedules[i];
            if (o.name !== self.name) continue;
            // While this element already has a starting transition during this frame,
            // defer starting an interrupting transition until that transition has a
            // chance to tick (and possibly end); see d3/d3-transition#54!
            if (o.state === STARTED) return _d3Timer.timeout(start);
            // Interrupt the active transition, if any.
            if (o.state === RUNNING) {
                o.state = ENDED;
                o.timer.stop();
                o.on.call("interrupt", node, node.__data__, o.index, o.group);
                delete schedules[i];
            } else if (+i < id) {
                o.state = ENDED;
                o.timer.stop();
                o.on.call("cancel", node, node.__data__, o.index, o.group);
                delete schedules[i];
            }
        }
        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        _d3Timer.timeout(function() {
            if (self.state === STARTED) {
                self.state = RUNNING;
                self.timer.restart(tick, self.delay, self.time);
                tick(elapsed);
            }
        });
        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;
        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for(i = 0, j = -1; i < n; ++i)if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) tween[++j] = o;
        tween.length = j + 1;
    }
    function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
        while(++i < n)tween[i].call(node, t);
        // Dispatch the end event.
        if (self.state === ENDING) {
            self.on.call("end", node, node.__data__, self.index, self.group);
            stop();
        }
    }
    function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for(var i in schedules)return; // eslint-disable-line no-unused-vars
        delete node.__transition;
    }
}

},{"d3-dispatch":"9d2te","d3-timer":"82ygz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"82ygz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "now", ()=>_timerJs.now
);
parcelHelpers.export(exports, "timer", ()=>_timerJs.timer
);
parcelHelpers.export(exports, "timerFlush", ()=>_timerJs.timerFlush
);
parcelHelpers.export(exports, "timeout", ()=>_timeoutJsDefault.default
);
parcelHelpers.export(exports, "interval", ()=>_intervalJsDefault.default
);
var _timerJs = require("./timer.js");
var _timeoutJs = require("./timeout.js");
var _timeoutJsDefault = parcelHelpers.interopDefault(_timeoutJs);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);

},{"./timer.js":"e5Yqg","./timeout.js":"iPlus","./interval.js":"fIl4w","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e5Yqg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "now", ()=>now1
);
parcelHelpers.export(exports, "Timer", ()=>Timer
);
parcelHelpers.export(exports, "timer", ()=>timer
);
parcelHelpers.export(exports, "timerFlush", ()=>timerFlush
);
var frame = 0, timeout = 0, interval = 0, pokeDelay = 1000, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
};
function now1() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
    clockNow = 0;
}
function Timer() {
    this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now1() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
            if (taskTail) taskTail._next = this;
            else taskHead = this;
            taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
    },
    stop: function() {
        if (this._call) {
            this._call = null;
            this._time = Infinity;
            sleep();
        }
    }
};
function timer(callback, delay, time) {
    var t = new Timer;
    t.restart(callback, delay, time);
    return t;
}
function timerFlush() {
    now1(); // Get the current time, if not already set.
    ++frame; // Pretend we’ve set an alarm, if we haven’t already.
    var t = taskHead, e;
    while(t){
        if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
        t = t._next;
    }
    --frame;
}
function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
        timerFlush();
    } finally{
        frame = 0;
        nap();
        clockNow = 0;
    }
}
function poke() {
    var now = clock.now(), delay = now - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}
function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while(t1)if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
    } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
    taskTail = t0;
    sleep(time);
}
function sleep(time) {
    if (frame) return; // Soonest alarm already set, or will be.
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
    if (delay > 24) {
        if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval) interval = clearInterval(interval);
    } else {
        if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iPlus":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _timerJs = require("./timer.js");
exports.default = function(callback, delay, time) {
    var t = new _timerJs.Timer;
    delay = delay == null ? 0 : +delay;
    t.restart(function(elapsed) {
        t.stop();
        callback(elapsed + delay);
    }, delay, time);
    return t;
};

},{"./timer.js":"e5Yqg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fIl4w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _timerJs = require("./timer.js");
exports.default = function(callback, delay, time) {
    var t = new _timerJs.Timer, total = delay;
    if (delay == null) return t.restart(callback, delay, time), t;
    delay = +delay, time = time == null ? _timerJs.now() : +time;
    t.restart(function tick(elapsed) {
        elapsed += total;
        t.restart(tick, total += delay, time);
        callback(elapsed);
    }, delay, time);
    return t;
};

},{"./timer.js":"e5Yqg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7r67v":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../transition/index.js");
var _scheduleJs = require("../transition/schedule.js");
var _scheduleJsDefault = parcelHelpers.interopDefault(_scheduleJs);
var _d3Ease = require("d3-ease");
var _d3Timer = require("d3-timer");
var defaultTiming = {
    time: null,
    delay: 0,
    duration: 250,
    ease: _d3Ease.easeCubicInOut
};
function inherit(node, id) {
    var timing;
    while(!(timing = node.__transition) || !(timing = timing[id])){
        if (!(node = node.parentNode)) return defaultTiming.time = _d3Timer.now(), defaultTiming;
    }
    return timing;
}
exports.default = function(name) {
    var id, timing;
    if (name instanceof _indexJs.Transition) id = name._id, name = name._name;
    else id = _indexJs.newId(), (timing = defaultTiming).time = _d3Timer.now(), name = name == null ? null : name + "";
    for(var groups = this._groups, m = groups.length, j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, node, i = 0; i < n; ++i)if (node = group[i]) _scheduleJsDefault.default(node, name, id, i, group, timing || inherit(node, id));
    }
    return new _indexJs.Transition(groups, this._parents, name, id);
};

},{"../transition/index.js":"18i1e","../transition/schedule.js":"dTpjR","d3-ease":"elZFc","d3-timer":"82ygz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"18i1e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transition", ()=>Transition
);
parcelHelpers.export(exports, "newId", ()=>newId
);
var _d3Selection = require("d3-selection");
var _attrJs = require("./attr.js");
var _attrJsDefault = parcelHelpers.interopDefault(_attrJs);
var _attrTweenJs = require("./attrTween.js");
var _attrTweenJsDefault = parcelHelpers.interopDefault(_attrTweenJs);
var _delayJs = require("./delay.js");
var _delayJsDefault = parcelHelpers.interopDefault(_delayJs);
var _durationJs = require("./duration.js");
var _durationJsDefault = parcelHelpers.interopDefault(_durationJs);
var _easeJs = require("./ease.js");
var _easeJsDefault = parcelHelpers.interopDefault(_easeJs);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _mergeJs = require("./merge.js");
var _mergeJsDefault = parcelHelpers.interopDefault(_mergeJs);
var _onJs = require("./on.js");
var _onJsDefault = parcelHelpers.interopDefault(_onJs);
var _removeJs = require("./remove.js");
var _removeJsDefault = parcelHelpers.interopDefault(_removeJs);
var _selectJs = require("./select.js");
var _selectJsDefault = parcelHelpers.interopDefault(_selectJs);
var _selectAllJs = require("./selectAll.js");
var _selectAllJsDefault = parcelHelpers.interopDefault(_selectAllJs);
var _selectionJs = require("./selection.js");
var _selectionJsDefault = parcelHelpers.interopDefault(_selectionJs);
var _styleJs = require("./style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _styleTweenJs = require("./styleTween.js");
var _styleTweenJsDefault = parcelHelpers.interopDefault(_styleTweenJs);
var _textJs = require("./text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);
var _textTweenJs = require("./textTween.js");
var _textTweenJsDefault = parcelHelpers.interopDefault(_textTweenJs);
var _transitionJs = require("./transition.js");
var _transitionJsDefault = parcelHelpers.interopDefault(_transitionJs);
var _tweenJs = require("./tween.js");
var _tweenJsDefault = parcelHelpers.interopDefault(_tweenJs);
var _endJs = require("./end.js");
var _endJsDefault = parcelHelpers.interopDefault(_endJs);
var id1 = 0;
function Transition(groups, parents, name, id) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id;
}
function transition(name) {
    return _d3Selection.selection().transition(name);
}
exports.default = transition;
function newId() {
    return ++id1;
}
var selection_prototype = _d3Selection.selection.prototype;
Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: _selectJsDefault.default,
    selectAll: _selectAllJsDefault.default,
    filter: _filterJsDefault.default,
    merge: _mergeJsDefault.default,
    selection: _selectionJsDefault.default,
    transition: _transitionJsDefault.default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: _onJsDefault.default,
    attr: _attrJsDefault.default,
    attrTween: _attrTweenJsDefault.default,
    style: _styleJsDefault.default,
    styleTween: _styleTweenJsDefault.default,
    text: _textJsDefault.default,
    textTween: _textTweenJsDefault.default,
    remove: _removeJsDefault.default,
    tween: _tweenJsDefault.default,
    delay: _delayJsDefault.default,
    duration: _durationJsDefault.default,
    ease: _easeJsDefault.default,
    end: _endJsDefault.default
};

},{"d3-selection":"hgWtk","./attr.js":"a88nM","./attrTween.js":"4rwV3","./delay.js":"zwknt","./duration.js":"fXFoC","./ease.js":"d7SOb","./filter.js":"koiOg","./merge.js":"66rfJ","./on.js":"2whzO","./remove.js":"jdITm","./select.js":"fZfF3","./selectAll.js":"lJAHb","./selection.js":"a9rwa","./style.js":"8dHzR","./styleTween.js":"8Kz8d","./text.js":"hhhZ2","./textTween.js":"ezXKs","./transition.js":"eIPZ1","./tween.js":"8L0br","./end.js":"bGIdi","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"a88nM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Interpolate = require("d3-interpolate");
var _d3Selection = require("d3-selection");
var _tweenJs = require("./tween.js");
var _interpolateJs = require("./interpolate.js");
var _interpolateJsDefault = parcelHelpers.interopDefault(_interpolateJs);
function attrRemove(name) {
    return function() {
        this.removeAttribute(name);
    };
}
function attrRemoveNS(fullname) {
    return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
    };
}
function attrConstant(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
}
function attrConstantNS(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
}
function attrFunction(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
}
function attrFunctionNS(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
}
exports.default = function(name, value) {
    var fullname = _d3Selection.namespace(name), i = fullname === "transform" ? _d3Interpolate.interpolateTransformSvg : _interpolateJsDefault.default;
    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, _tweenJs.tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
};

},{"d3-interpolate":"e7XwA","d3-selection":"hgWtk","./tween.js":"8L0br","./interpolate.js":"1aR0B","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8L0br":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tweenValue", ()=>tweenValue
);
var _scheduleJs = require("./schedule.js");
function tweenRemove(id, name) {
    var tween0, tween1;
    return function() {
        var schedule = _scheduleJs.set(this, id), tween = schedule.tween;
        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
            tween1 = tween0 = tween;
            for(var i = 0, n = tween1.length; i < n; ++i)if (tween1[i].name === name) {
                tween1 = tween1.slice();
                tween1.splice(i, 1);
                break;
            }
        }
        schedule.tween = tween1;
    };
}
function tweenFunction(id, name, value) {
    var tween0, tween1;
    if (typeof value !== "function") throw new Error;
    return function() {
        var schedule = _scheduleJs.set(this, id), tween = schedule.tween;
        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
            tween1 = (tween0 = tween).slice();
            for(var t = {
                name: name,
                value: value
            }, i = 0, n = tween1.length; i < n; ++i)if (tween1[i].name === name) {
                tween1[i] = t;
                break;
            }
            if (i === n) tween1.push(t);
        }
        schedule.tween = tween1;
    };
}
exports.default = function(name, value) {
    var id = this._id;
    name += "";
    if (arguments.length < 2) {
        var tween = _scheduleJs.get(this.node(), id).tween;
        for(var i = 0, n = tween.length, t; i < n; ++i){
            if ((t = tween[i]).name === name) return t.value;
        }
        return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
};
function tweenValue(transition, name, value) {
    var id = transition._id;
    transition.each(function() {
        var schedule = _scheduleJs.set(this, id);
        (schedule.value || (schedule.value = {
        }))[name] = value.apply(this, arguments);
    });
    return function(node) {
        return _scheduleJs.get(node, id).value[name];
    };
}

},{"./schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1aR0B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Color = require("d3-color");
var _d3Interpolate = require("d3-interpolate");
exports.default = function(a, b) {
    var c;
    return (typeof b === "number" ? _d3Interpolate.interpolateNumber : b instanceof _d3Color.color ? _d3Interpolate.interpolateRgb : (c = _d3Color.color(b)) ? (b = c, _d3Interpolate.interpolateRgb) : _d3Interpolate.interpolateString)(a, b);
};

},{"d3-color":"ap3Jg","d3-interpolate":"e7XwA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4rwV3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Selection = require("d3-selection");
function attrInterpolate(name, i) {
    return function(t) {
        this.setAttribute(name, i.call(this, t));
    };
}
function attrInterpolateNS(fullname, i) {
    return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
    };
}
function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
    }
    tween._value = value;
    return tween;
}
function attrTween(name, value) {
    var t0, i0;
    function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
    }
    tween._value = value;
    return tween;
}
exports.default = function(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error;
    var fullname = _d3Selection.namespace(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
};

},{"d3-selection":"hgWtk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"zwknt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduleJs = require("./schedule.js");
function delayFunction(id, value) {
    return function() {
        _scheduleJs.init(this, id).delay = +value.apply(this, arguments);
    };
}
function delayConstant(id, value) {
    return value = +value, function() {
        _scheduleJs.init(this, id).delay = value;
    };
}
exports.default = function(value) {
    var id = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : _scheduleJs.get(this.node(), id).delay;
};

},{"./schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fXFoC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduleJs = require("./schedule.js");
function durationFunction(id, value) {
    return function() {
        _scheduleJs.set(this, id).duration = +value.apply(this, arguments);
    };
}
function durationConstant(id, value) {
    return value = +value, function() {
        _scheduleJs.set(this, id).duration = value;
    };
}
exports.default = function(value) {
    var id = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : _scheduleJs.get(this.node(), id).duration;
};

},{"./schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"d7SOb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduleJs = require("./schedule.js");
function easeConstant(id, value) {
    if (typeof value !== "function") throw new Error;
    return function() {
        _scheduleJs.set(this, id).ease = value;
    };
}
exports.default = function(value) {
    var id = this._id;
    return arguments.length ? this.each(easeConstant(id, value)) : _scheduleJs.get(this.node(), id).ease;
};

},{"./schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"koiOg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Selection = require("d3-selection");
var _indexJs = require("./index.js");
exports.default = function(match) {
    if (typeof match !== "function") match = _d3Selection.matcher(match);
    for(var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i)if ((node = group[i]) && match.call(node, node.__data__, i, group)) subgroup.push(node);
    }
    return new _indexJs.Transition(subgroups, this._parents, this._name, this._id);
};

},{"d3-selection":"hgWtk","./index.js":"18i1e","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"66rfJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./index.js");
exports.default = function(transition) {
    if (transition._id !== this._id) throw new Error;
    for(var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j){
        for(var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i)if (node = group0[i] || group1[i]) merge[i] = node;
    }
    for(; j < m0; ++j)merges[j] = groups0[j];
    return new _indexJs.Transition(merges, this._parents, this._name, this._id);
};

},{"./index.js":"18i1e","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2whzO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduleJs = require("./schedule.js");
function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
    });
}
function onFunction(id, name, listener) {
    var on0, on1, sit = start(name) ? _scheduleJs.init : _scheduleJs.set;
    return function() {
        var schedule = sit(this, id), on = schedule.on;
        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
        schedule.on = on1;
    };
}
exports.default = function(name, listener) {
    var id = this._id;
    return arguments.length < 2 ? _scheduleJs.get(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
};

},{"./schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jdITm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function removeFunction(id) {
    return function() {
        var parent = this.parentNode;
        for(var i in this.__transition)if (+i !== id) return;
        if (parent) parent.removeChild(this);
    };
}
exports.default = function() {
    return this.on("end.remove", removeFunction(this._id));
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fZfF3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Selection = require("d3-selection");
var _indexJs = require("./index.js");
var _scheduleJs = require("./schedule.js");
var _scheduleJsDefault = parcelHelpers.interopDefault(_scheduleJs);
exports.default = function(select) {
    var name = this._name, id = this._id;
    if (typeof select !== "function") select = _d3Selection.selector(select);
    for(var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i)if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            _scheduleJsDefault.default(subgroup[i], name, id, i, subgroup, _scheduleJs.get(node, id));
        }
    }
    return new _indexJs.Transition(subgroups, this._parents, name, id);
};

},{"d3-selection":"hgWtk","./index.js":"18i1e","./schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lJAHb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Selection = require("d3-selection");
var _indexJs = require("./index.js");
var _scheduleJs = require("./schedule.js");
var _scheduleJsDefault = parcelHelpers.interopDefault(_scheduleJs);
exports.default = function(select) {
    var name = this._name, id = this._id;
    if (typeof select !== "function") select = _d3Selection.selectorAll(select);
    for(var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, node, i = 0; i < n; ++i)if (node = group[i]) {
            for(var children = select.call(node, node.__data__, i, group), child, inherit = _scheduleJs.get(node, id), k = 0, l = children.length; k < l; ++k)if (child = children[k]) _scheduleJsDefault.default(child, name, id, k, children, inherit);
            subgroups.push(children);
            parents.push(node);
        }
    }
    return new _indexJs.Transition(subgroups, parents, name, id);
};

},{"d3-selection":"hgWtk","./index.js":"18i1e","./schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"a9rwa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Selection = require("d3-selection");
var Selection = _d3Selection.selection.prototype.constructor;
exports.default = function() {
    return new Selection(this._groups, this._parents);
};

},{"d3-selection":"hgWtk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8dHzR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Interpolate = require("d3-interpolate");
var _d3Selection = require("d3-selection");
var _scheduleJs = require("./schedule.js");
var _tweenJs = require("./tween.js");
var _interpolateJs = require("./interpolate.js");
var _interpolateJsDefault = parcelHelpers.interopDefault(_interpolateJs);
function styleNull(name, interpolate) {
    var string00, string10, interpolate0;
    return function() {
        var string0 = _d3Selection.style(this, name), string1 = (this.style.removeProperty(name), _d3Selection.style(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
}
function styleRemove(name) {
    return function() {
        this.style.removeProperty(name);
    };
}
function styleConstant(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
        var string0 = _d3Selection.style(this, name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
}
function styleFunction(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
        var string0 = _d3Selection.style(this, name), value1 = value(this), string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), _d3Selection.style(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
}
function styleMaybeRemove(id, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
    return function() {
        var schedule = _scheduleJs.set(this, id), on = schedule.on, listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;
        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
        schedule.on = on1;
    };
}
exports.default = function(name, value, priority) {
    var i = (name += "") === "transform" ? _d3Interpolate.interpolateTransformCss : _interpolateJsDefault.default;
    return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, _tweenJs.tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
};

},{"d3-interpolate":"e7XwA","d3-selection":"hgWtk","./schedule.js":"dTpjR","./tween.js":"8L0br","./interpolate.js":"1aR0B","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8Kz8d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function styleInterpolate(name, i, priority) {
    return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
    };
}
function styleTween(name, value, priority) {
    var t, i0;
    function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
    }
    tween._value = value;
    return tween;
}
exports.default = function(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error;
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hhhZ2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tweenJs = require("./tween.js");
function textConstant(value) {
    return function() {
        this.textContent = value;
    };
}
function textFunction(value) {
    return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
    };
}
exports.default = function(value) {
    return this.tween("text", typeof value === "function" ? textFunction(_tweenJs.tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
};

},{"./tween.js":"8L0br","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ezXKs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function textInterpolate(i) {
    return function(t) {
        this.textContent = i.call(this, t);
    };
}
function textTween(value) {
    var t0, i0;
    function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
    }
    tween._value = value;
    return tween;
}
exports.default = function(value) {
    var key = "text";
    if (arguments.length < 1) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error;
    return this.tween(key, textTween(value));
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eIPZ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./index.js");
var _scheduleJs = require("./schedule.js");
var _scheduleJsDefault = parcelHelpers.interopDefault(_scheduleJs);
exports.default = function() {
    var name = this._name, id0 = this._id, id1 = _indexJs.newId();
    for(var groups = this._groups, m = groups.length, j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, node, i = 0; i < n; ++i)if (node = group[i]) {
            var inherit = _scheduleJs.get(node, id0);
            _scheduleJsDefault.default(node, name, id1, i, group, {
                time: inherit.time + inherit.delay + inherit.duration,
                delay: 0,
                duration: inherit.duration,
                ease: inherit.ease
            });
        }
    }
    return new _indexJs.Transition(groups, this._parents, name, id1);
};

},{"./index.js":"18i1e","./schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bGIdi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduleJs = require("./schedule.js");
exports.default = function() {
    var on0, on1, that = this, id = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
        var cancel = {
            value: reject
        }, end = {
            value: function() {
                if (--size === 0) resolve();
            }
        };
        that.each(function() {
            var schedule = _scheduleJs.set(this, id), on = schedule.on;
            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and we’re done!
            // Otherwise, copy-on-write.
            if (on !== on0) {
                on1 = (on0 = on).copy();
                on1._.cancel.push(cancel);
                on1._.interrupt.push(cancel);
                on1._.end.push(end);
            }
            schedule.on = on1;
        });
    });
};

},{"./schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"elZFc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "easeLinear", ()=>_linearJs.linear
);
parcelHelpers.export(exports, "easeQuad", ()=>_quadJs.quadInOut
);
parcelHelpers.export(exports, "easeQuadIn", ()=>_quadJs.quadIn
);
parcelHelpers.export(exports, "easeQuadOut", ()=>_quadJs.quadOut
);
parcelHelpers.export(exports, "easeQuadInOut", ()=>_quadJs.quadInOut
);
parcelHelpers.export(exports, "easeCubic", ()=>_cubicJs.cubicInOut
);
parcelHelpers.export(exports, "easeCubicIn", ()=>_cubicJs.cubicIn
);
parcelHelpers.export(exports, "easeCubicOut", ()=>_cubicJs.cubicOut
);
parcelHelpers.export(exports, "easeCubicInOut", ()=>_cubicJs.cubicInOut
);
parcelHelpers.export(exports, "easePoly", ()=>_polyJs.polyInOut
);
parcelHelpers.export(exports, "easePolyIn", ()=>_polyJs.polyIn
);
parcelHelpers.export(exports, "easePolyOut", ()=>_polyJs.polyOut
);
parcelHelpers.export(exports, "easePolyInOut", ()=>_polyJs.polyInOut
);
parcelHelpers.export(exports, "easeSin", ()=>_sinJs.sinInOut
);
parcelHelpers.export(exports, "easeSinIn", ()=>_sinJs.sinIn
);
parcelHelpers.export(exports, "easeSinOut", ()=>_sinJs.sinOut
);
parcelHelpers.export(exports, "easeSinInOut", ()=>_sinJs.sinInOut
);
parcelHelpers.export(exports, "easeExp", ()=>_expJs.expInOut
);
parcelHelpers.export(exports, "easeExpIn", ()=>_expJs.expIn
);
parcelHelpers.export(exports, "easeExpOut", ()=>_expJs.expOut
);
parcelHelpers.export(exports, "easeExpInOut", ()=>_expJs.expInOut
);
parcelHelpers.export(exports, "easeCircle", ()=>_circleJs.circleInOut
);
parcelHelpers.export(exports, "easeCircleIn", ()=>_circleJs.circleIn
);
parcelHelpers.export(exports, "easeCircleOut", ()=>_circleJs.circleOut
);
parcelHelpers.export(exports, "easeCircleInOut", ()=>_circleJs.circleInOut
);
parcelHelpers.export(exports, "easeBounce", ()=>_bounceJs.bounceOut
);
parcelHelpers.export(exports, "easeBounceIn", ()=>_bounceJs.bounceIn
);
parcelHelpers.export(exports, "easeBounceOut", ()=>_bounceJs.bounceOut
);
parcelHelpers.export(exports, "easeBounceInOut", ()=>_bounceJs.bounceInOut
);
parcelHelpers.export(exports, "easeBack", ()=>_backJs.backInOut
);
parcelHelpers.export(exports, "easeBackIn", ()=>_backJs.backIn
);
parcelHelpers.export(exports, "easeBackOut", ()=>_backJs.backOut
);
parcelHelpers.export(exports, "easeBackInOut", ()=>_backJs.backInOut
);
parcelHelpers.export(exports, "easeElastic", ()=>_elasticJs.elasticOut
);
parcelHelpers.export(exports, "easeElasticIn", ()=>_elasticJs.elasticIn
);
parcelHelpers.export(exports, "easeElasticOut", ()=>_elasticJs.elasticOut
);
parcelHelpers.export(exports, "easeElasticInOut", ()=>_elasticJs.elasticInOut
);
var _linearJs = require("./linear.js");
var _quadJs = require("./quad.js");
var _cubicJs = require("./cubic.js");
var _polyJs = require("./poly.js");
var _sinJs = require("./sin.js");
var _expJs = require("./exp.js");
var _circleJs = require("./circle.js");
var _bounceJs = require("./bounce.js");
var _backJs = require("./back.js");
var _elasticJs = require("./elastic.js");

},{"./linear.js":"gHm7e","./quad.js":"hYhoX","./cubic.js":"aZIHk","./poly.js":"hNV3X","./sin.js":"zeJJc","./exp.js":"2ovMf","./circle.js":"acQDc","./bounce.js":"21QKc","./back.js":"enxiL","./elastic.js":"eIiW6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gHm7e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "linear", ()=>linear
);
function linear(t) {
    return +t;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hYhoX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "quadIn", ()=>quadIn
);
parcelHelpers.export(exports, "quadOut", ()=>quadOut
);
parcelHelpers.export(exports, "quadInOut", ()=>quadInOut
);
function quadIn(t) {
    return t * t;
}
function quadOut(t) {
    return t * (2 - t);
}
function quadInOut(t) {
    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aZIHk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cubicIn", ()=>cubicIn
);
parcelHelpers.export(exports, "cubicOut", ()=>cubicOut
);
parcelHelpers.export(exports, "cubicInOut", ()=>cubicInOut
);
function cubicIn(t) {
    return t * t * t;
}
function cubicOut(t) {
    return --t * t * t + 1;
}
function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hNV3X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "polyIn", ()=>polyIn1
);
parcelHelpers.export(exports, "polyOut", ()=>polyOut1
);
parcelHelpers.export(exports, "polyInOut", ()=>polyInOut1
);
var exponent = 3;
var polyIn1 = function custom(e) {
    e = +e;
    function polyIn(t) {
        return Math.pow(t, e);
    }
    polyIn.exponent = custom;
    return polyIn;
}(exponent);
var polyOut1 = function custom(e) {
    e = +e;
    function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
    }
    polyOut.exponent = custom;
    return polyOut;
}(exponent);
var polyInOut1 = function custom(e) {
    e = +e;
    function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
    }
    polyInOut.exponent = custom;
    return polyInOut;
}(exponent);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"zeJJc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sinIn", ()=>sinIn
);
parcelHelpers.export(exports, "sinOut", ()=>sinOut
);
parcelHelpers.export(exports, "sinInOut", ()=>sinInOut
);
var pi = Math.PI, halfPi = pi / 2;
function sinIn(t) {
    return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
    return Math.sin(t * halfPi);
}
function sinInOut(t) {
    return (1 - Math.cos(pi * t)) / 2;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2ovMf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "expIn", ()=>expIn
);
parcelHelpers.export(exports, "expOut", ()=>expOut
);
parcelHelpers.export(exports, "expInOut", ()=>expInOut
);
var _mathJs = require("./math.js");
function expIn(t) {
    return _mathJs.tpmt(1 - +t);
}
function expOut(t) {
    return 1 - _mathJs.tpmt(t);
}
function expInOut(t) {
    return ((t *= 2) <= 1 ? _mathJs.tpmt(1 - t) : 2 - _mathJs.tpmt(t - 1)) / 2;
}

},{"./math.js":"7Y1a5","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7Y1a5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// tpmt is two power minus ten times t scaled to [0,1]
parcelHelpers.export(exports, "tpmt", ()=>tpmt
);
function tpmt(x) {
    return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"acQDc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "circleIn", ()=>circleIn
);
parcelHelpers.export(exports, "circleOut", ()=>circleOut
);
parcelHelpers.export(exports, "circleInOut", ()=>circleInOut
);
function circleIn(t) {
    return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
    return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"21QKc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bounceIn", ()=>bounceIn
);
parcelHelpers.export(exports, "bounceOut", ()=>bounceOut
);
parcelHelpers.export(exports, "bounceInOut", ()=>bounceInOut
);
var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 0.75, b5 = 9 / 11, b6 = 10 / 11, b7 = 0.9375, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
function bounceIn(t) {
    return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
    return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
    return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"enxiL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "backIn", ()=>backIn1
);
parcelHelpers.export(exports, "backOut", ()=>backOut1
);
parcelHelpers.export(exports, "backInOut", ()=>backInOut1
);
var overshoot = 1.70158;
var backIn1 = function custom(s) {
    s = +s;
    function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
    }
    backIn.overshoot = custom;
    return backIn;
}(overshoot);
var backOut1 = function custom(s) {
    s = +s;
    function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
    }
    backOut.overshoot = custom;
    return backOut;
}(overshoot);
var backInOut1 = function custom(s) {
    s = +s;
    function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
    }
    backInOut.overshoot = custom;
    return backInOut;
}(overshoot);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eIiW6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "elasticIn", ()=>elasticIn1
);
parcelHelpers.export(exports, "elasticOut", ()=>elasticOut1
);
parcelHelpers.export(exports, "elasticInOut", ()=>elasticInOut1
);
var _mathJs = require("./math.js");
var tau = 2 * Math.PI, amplitude = 1, period = 0.3;
var elasticIn1 = function custom(a1, p1) {
    var s = Math.asin(1 / (a1 = Math.max(1, a1))) * (p1 /= tau);
    function elasticIn(t) {
        return a1 * _mathJs.tpmt(- --t) * Math.sin((s - t) / p1);
    }
    elasticIn.amplitude = function(a) {
        return custom(a, p1 * tau);
    };
    elasticIn.period = function(p) {
        return custom(a1, p);
    };
    return elasticIn;
}(amplitude, period);
var elasticOut1 = function custom(a2, p2) {
    var s = Math.asin(1 / (a2 = Math.max(1, a2))) * (p2 /= tau);
    function elasticOut(t) {
        return 1 - a2 * _mathJs.tpmt(t = +t) * Math.sin((t + s) / p2);
    }
    elasticOut.amplitude = function(a) {
        return custom(a, p2 * tau);
    };
    elasticOut.period = function(p) {
        return custom(a2, p);
    };
    return elasticOut;
}(amplitude, period);
var elasticInOut1 = function custom(a3, p3) {
    var s = Math.asin(1 / (a3 = Math.max(1, a3))) * (p3 /= tau);
    function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0 ? a3 * _mathJs.tpmt(-t) * Math.sin((s - t) / p3) : 2 - a3 * _mathJs.tpmt(t) * Math.sin((s + t) / p3)) / 2;
    }
    elasticInOut.amplitude = function(a) {
        return custom(a, p3 * tau);
    };
    elasticInOut.period = function(p) {
        return custom(a3, p);
    };
    return elasticInOut;
}(amplitude, period);

},{"./math.js":"7Y1a5","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e5Mev":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./transition/index.js");
var _scheduleJs = require("./transition/schedule.js");
var root = [
    null
];
exports.default = function(node, name) {
    var schedules = node.__transition, schedule, i;
    if (schedules) {
        name = name == null ? null : name + "";
        for(i in schedules){
            if ((schedule = schedules[i]).state > _scheduleJs.SCHEDULED && schedule.name === name) return new _indexJs.Transition([
                [
                    node
                ]
            ], root, name, +i);
        }
    }
    return null;
};

},{"./transition/index.js":"18i1e","./transition/schedule.js":"dTpjR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"j4KZw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Rq9l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(target, type, selection) {
    this.target = target;
    this.type = type;
    this.selection = selection;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9Mi58":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nopropagation", ()=>nopropagation
);
var _d3Selection = require("d3-selection");
function nopropagation() {
    _d3Selection.event.stopImmediatePropagation();
}
exports.default = function() {
    _d3Selection.event.preventDefault();
    _d3Selection.event.stopImmediatePropagation();
};

},{"d3-selection":"hgWtk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8oHeW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "chord", ()=>_chordDefault.default
);
parcelHelpers.export(exports, "ribbon", ()=>_ribbonDefault.default
);
var _chord = require("./chord");
var _chordDefault = parcelHelpers.interopDefault(_chord);
var _ribbon = require("./ribbon");
var _ribbonDefault = parcelHelpers.interopDefault(_ribbon);

},{"./chord":"dWLwE","./ribbon":"7QZI4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dWLwE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Array = require("d3-array");
var _math = require("./math");
function compareValue(compare) {
    return function(a, b) {
        return compare(a.source.value + a.target.value, b.source.value + b.target.value);
    };
}
exports.default = function() {
    var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;
    function chord(matrix) {
        var n = matrix.length, groupSums = [], groupIndex = _d3Array.range(n), subgroupIndex = [], chords = [], groups = chords.groups = new Array(n), subgroups = new Array(n * n), k, x, x0, dx, i, j;
        // Compute the sum.
        k = 0, i = -1;
        while(++i < n){
            x = 0, j = -1;
            while(++j < n)x += matrix[i][j];
            groupSums.push(x);
            subgroupIndex.push(_d3Array.range(n));
            k += x;
        }
        // Sort groups…
        if (sortGroups) groupIndex.sort(function(a, b) {
            return sortGroups(groupSums[a], groupSums[b]);
        });
        // Sort subgroups…
        if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
            d.sort(function(a, b) {
                return sortSubgroups(matrix[i][a], matrix[i][b]);
            });
        });
        // Convert the sum to scaling factor for [0, 2pi].
        // TODO Allow start and end angle to be specified?
        // TODO Allow padding to be specified as percentage?
        k = _math.max(0, _math.tau - padAngle * n) / k;
        dx = k ? padAngle : _math.tau / n;
        // Compute the start and end angle for each group and subgroup.
        // Note: Opera has a bug reordering object literal properties!
        x = 0, i = -1;
        while(++i < n){
            x0 = x, j = -1;
            while(++j < n){
                var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                subgroups[dj * n + di] = {
                    index: di,
                    subindex: dj,
                    startAngle: a0,
                    endAngle: a1,
                    value: v
                };
            }
            groups[di] = {
                index: di,
                startAngle: x0,
                endAngle: x,
                value: groupSums[di]
            };
            x += dx;
        }
        // Generate chords for each (non-empty) subgroup-subgroup link.
        i = -1;
        while(++i < n){
            j = i - 1;
            while(++j < n){
                var source = subgroups[j * n + i], target = subgroups[i * n + j];
                if (source.value || target.value) chords.push(source.value < target.value ? {
                    source: target,
                    target: source
                } : {
                    source: source,
                    target: target
                });
            }
        }
        return sortChords ? chords.sort(sortChords) : chords;
    }
    chord.padAngle = function(_) {
        return arguments.length ? (padAngle = _math.max(0, _), chord) : padAngle;
    };
    chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
    };
    chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
    };
    chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
    };
    return chord;
};

},{"d3-array":"dclxS","./math":"abL3d","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"abL3d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cos", ()=>cos
);
parcelHelpers.export(exports, "sin", ()=>sin
);
parcelHelpers.export(exports, "pi", ()=>pi
);
parcelHelpers.export(exports, "halfPi", ()=>halfPi
);
parcelHelpers.export(exports, "tau", ()=>tau
);
parcelHelpers.export(exports, "max", ()=>max
);
var cos = Math.cos;
var sin = Math.sin;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;
var max = Math.max;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7QZI4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _array = require("./array");
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var _math = require("./math");
var _d3Path = require("d3-path");
function defaultSource(d) {
    return d.source;
}
function defaultTarget(d) {
    return d.target;
}
function defaultRadius(d) {
    return d.radius;
}
function defaultStartAngle(d) {
    return d.startAngle;
}
function defaultEndAngle(d) {
    return d.endAngle;
}
exports.default = function() {
    var source = defaultSource, target = defaultTarget, radius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, context = null;
    function ribbon() {
        var buffer, argv = _array.slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv), sr = +radius.apply(this, (argv[0] = s, argv)), sa0 = startAngle.apply(this, argv) - _math.halfPi, sa1 = endAngle.apply(this, argv) - _math.halfPi, sx0 = sr * _math.cos(sa0), sy0 = sr * _math.sin(sa0), tr = +radius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - _math.halfPi, ta1 = endAngle.apply(this, argv) - _math.halfPi;
        if (!context) context = buffer = _d3Path.path();
        context.moveTo(sx0, sy0);
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) {
            context.quadraticCurveTo(0, 0, tr * _math.cos(ta0), tr * _math.sin(ta0));
            context.arc(0, 0, tr, ta0, ta1);
        }
        context.quadraticCurveTo(0, 0, sx0, sy0);
        context.closePath();
        if (buffer) return context = null, buffer + "" || null;
    }
    ribbon.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : _constantDefault.default(+_), ribbon) : radius;
    };
    ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : _constantDefault.default(+_), ribbon) : startAngle;
    };
    ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : _constantDefault.default(+_), ribbon) : endAngle;
    };
    ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
    };
    ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
    };
    ribbon.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, ribbon) : context;
    };
    return ribbon;
};

},{"./array":"8hI9H","./constant":"6QKYI","./math":"abL3d","d3-path":"4S67G","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8hI9H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "slice", ()=>slice
);
var slice = Array.prototype.slice;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6QKYI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4S67G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "path", ()=>_pathJsDefault.default
);
var _pathJs = require("./path.js");
var _pathJsDefault = parcelHelpers.interopDefault(_pathJs);

},{"./path.js":"5kGUo","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5kGUo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var pi = Math.PI, tau = 2 * pi, epsilon = 0.000001, tauEpsilon = tau - epsilon;
function Path() {
    this._x0 = this._y0 = this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
}
function path() {
    return new Path;
}
Path.prototype = path.prototype = {
    constructor: Path,
    moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function() {
        if (this._x1 !== null) {
            this._x1 = this._x0, this._y1 = this._y0;
            this._ += "Z";
        }
    },
    lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);
        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        else if (!(l01_2 > epsilon)) ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        else {
            var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
            // If the start tangent is not coincident with (x0,y0), line to.
            if (Math.abs(t01 - 1) > epsilon) this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
            this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
    },
    arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);
        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) this._ += "M" + x0 + "," + y0;
        else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += "L" + x0 + "," + y0;
        // Is this arc empty? We’re done.
        if (!r) return;
        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau + tau;
        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        else if (da > epsilon) this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    },
    rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
    },
    toString: function() {
        return this._;
    }
};
exports.default = path;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4zn9z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nest", ()=>_nestDefault.default
);
parcelHelpers.export(exports, "set", ()=>_setDefault.default
);
parcelHelpers.export(exports, "map", ()=>_mapDefault.default
);
parcelHelpers.export(exports, "keys", ()=>_keysDefault.default
);
parcelHelpers.export(exports, "values", ()=>_valuesDefault.default
);
parcelHelpers.export(exports, "entries", ()=>_entriesDefault.default
);
var _nest = require("./nest");
var _nestDefault = parcelHelpers.interopDefault(_nest);
var _set = require("./set");
var _setDefault = parcelHelpers.interopDefault(_set);
var _map = require("./map");
var _mapDefault = parcelHelpers.interopDefault(_map);
var _keys = require("./keys");
var _keysDefault = parcelHelpers.interopDefault(_keys);
var _values = require("./values");
var _valuesDefault = parcelHelpers.interopDefault(_values);
var _entries = require("./entries");
var _entriesDefault = parcelHelpers.interopDefault(_entries);

},{"./nest":"5q2nd","./set":"c5qL5","./map":"2qayx","./keys":"gXf2P","./values":"1LWTk","./entries":"aP8eL","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5q2nd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _map = require("./map");
var _mapDefault = parcelHelpers.interopDefault(_map);
exports.default = function() {
    var keys = [], sortKeys = [], sortValues, rollup, nest;
    function apply(array, depth, createResult, setResult) {
        if (depth >= keys.length) {
            if (sortValues != null) array.sort(sortValues);
            return rollup != null ? rollup(array) : array;
        }
        var i = -1, n = array.length, key1 = keys[depth++], keyValue, value, valuesByKey = _mapDefault.default(), values1, result = createResult();
        while(++i < n)if (values1 = valuesByKey.get(keyValue = key1(value = array[i]) + "")) values1.push(value);
        else valuesByKey.set(keyValue, [
            value
        ]);
        valuesByKey.each(function(values, key) {
            setResult(result, key, apply(values, depth, createResult, setResult));
        });
        return result;
    }
    function entries(map, depth) {
        if (++depth > keys.length) return map;
        var array, sortKey = sortKeys[depth - 1];
        if (rollup != null && depth >= keys.length) array = map.entries();
        else array = [], map.each(function(v, k) {
            array.push({
                key: k,
                values: entries(v, depth)
            });
        });
        return sortKey != null ? array.sort(function(a, b) {
            return sortKey(a.key, b.key);
        }) : array;
    }
    return nest = {
        object: function(array) {
            return apply(array, 0, createObject, setObject);
        },
        map: function(array) {
            return apply(array, 0, createMap, setMap);
        },
        entries: function(array) {
            return entries(apply(array, 0, createMap, setMap), 0);
        },
        key: function(d) {
            keys.push(d);
            return nest;
        },
        sortKeys: function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        },
        sortValues: function(order) {
            sortValues = order;
            return nest;
        },
        rollup: function(f) {
            rollup = f;
            return nest;
        }
    };
};
function createObject() {
    return {
    };
}
function setObject(object, key, value) {
    object[key] = value;
}
function createMap() {
    return _mapDefault.default();
}
function setMap(map, key, value) {
    map.set(key, value);
}

},{"./map":"2qayx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2qayx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prefix", ()=>prefix
);
var prefix = "$";
function Map() {
}
Map.prototype = map1.prototype = {
    constructor: Map,
    has: function(key) {
        return prefix + key in this;
    },
    get: function(key) {
        return this[prefix + key];
    },
    set: function(key, value) {
        this[prefix + key] = value;
        return this;
    },
    remove: function(key) {
        var property = prefix + key;
        return property in this && delete this[property];
    },
    clear: function() {
        for(var property in this)if (property[0] === prefix) delete this[property];
    },
    keys: function() {
        var keys = [];
        for(var property in this)if (property[0] === prefix) keys.push(property.slice(1));
        return keys;
    },
    values: function() {
        var values = [];
        for(var property in this)if (property[0] === prefix) values.push(this[property]);
        return values;
    },
    entries: function() {
        var entries = [];
        for(var property in this)if (property[0] === prefix) entries.push({
            key: property.slice(1),
            value: this[property]
        });
        return entries;
    },
    size: function() {
        var size = 0;
        for(var property in this)if (property[0] === prefix) ++size;
        return size;
    },
    empty: function() {
        for(var property in this)if (property[0] === prefix) return false;
        return true;
    },
    each: function(f) {
        for(var property in this)if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
};
function map1(object, f) {
    var map = new Map;
    // Copy constructor.
    if (object instanceof Map) object.each(function(value, key) {
        map.set(key, value);
    });
    else if (Array.isArray(object)) {
        var i = -1, n = object.length, o;
        if (f == null) while(++i < n)map.set(i, object[i]);
        else while(++i < n)map.set(f(o = object[i], i, object), o);
    } else if (object) for(var key1 in object)map.set(key1, object[key1]);
    return map;
}
exports.default = map1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c5qL5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _map = require("./map");
var _mapDefault = parcelHelpers.interopDefault(_map);
function Set() {
}
var proto = _mapDefault.default.prototype;
Set.prototype = set1.prototype = {
    constructor: Set,
    has: proto.has,
    add: function(value) {
        value += "";
        this[_map.prefix + value] = value;
        return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
};
function set1(object, f) {
    var set = new Set;
    // Copy constructor.
    if (object instanceof Set) object.each(function(value) {
        set.add(value);
    });
    else if (object) {
        var i = -1, n = object.length;
        if (f == null) while(++i < n)set.add(object[i]);
        else while(++i < n)set.add(f(object[i], i, object));
    }
    return set;
}
exports.default = set1;

},{"./map":"2qayx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gXf2P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(map) {
    var keys = [];
    for(var key in map)keys.push(key);
    return keys;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1LWTk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(map) {
    var values = [];
    for(var key in map)values.push(map[key]);
    return values;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aP8eL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(map) {
    var entries = [];
    for(var key in map)entries.push({
        key: key,
        value: map[key]
    });
    return entries;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jmn9V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "contours", ()=>_contoursDefault.default
);
parcelHelpers.export(exports, "contourDensity", ()=>_densityDefault.default
);
var _contours = require("./contours");
var _contoursDefault = parcelHelpers.interopDefault(_contours);
var _density = require("./density");
var _densityDefault = parcelHelpers.interopDefault(_density);

},{"./contours":"k2ecu","./density":"9HCA4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k2ecu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Array = require("d3-array");
var _array = require("./array");
var _ascending = require("./ascending");
var _ascendingDefault = parcelHelpers.interopDefault(_ascending);
var _area = require("./area");
var _areaDefault = parcelHelpers.interopDefault(_area);
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var _contains = require("./contains");
var _containsDefault = parcelHelpers.interopDefault(_contains);
var _noop = require("./noop");
var _noopDefault = parcelHelpers.interopDefault(_noop);
var cases = [
    [],
    [
        [
            [
                1,
                1.5
            ],
            [
                0.5,
                1
            ]
        ]
    ],
    [
        [
            [
                1.5,
                1
            ],
            [
                1,
                1.5
            ]
        ]
    ],
    [
        [
            [
                1.5,
                1
            ],
            [
                0.5,
                1
            ]
        ]
    ],
    [
        [
            [
                1,
                0.5
            ],
            [
                1.5,
                1
            ]
        ]
    ],
    [
        [
            [
                1,
                1.5
            ],
            [
                0.5,
                1
            ]
        ],
        [
            [
                1,
                0.5
            ],
            [
                1.5,
                1
            ]
        ]
    ],
    [
        [
            [
                1,
                0.5
            ],
            [
                1,
                1.5
            ]
        ]
    ],
    [
        [
            [
                1,
                0.5
            ],
            [
                0.5,
                1
            ]
        ]
    ],
    [
        [
            [
                0.5,
                1
            ],
            [
                1,
                0.5
            ]
        ]
    ],
    [
        [
            [
                1,
                1.5
            ],
            [
                1,
                0.5
            ]
        ]
    ],
    [
        [
            [
                0.5,
                1
            ],
            [
                1,
                0.5
            ]
        ],
        [
            [
                1.5,
                1
            ],
            [
                1,
                1.5
            ]
        ]
    ],
    [
        [
            [
                1.5,
                1
            ],
            [
                1,
                0.5
            ]
        ]
    ],
    [
        [
            [
                0.5,
                1
            ],
            [
                1.5,
                1
            ]
        ]
    ],
    [
        [
            [
                1,
                1.5
            ],
            [
                1.5,
                1
            ]
        ]
    ],
    [
        [
            [
                0.5,
                1
            ],
            [
                1,
                1.5
            ]
        ]
    ],
    []
];
exports.default = function() {
    var dx = 1, dy = 1, threshold = _d3Array.thresholdSturges, smooth = smoothLinear;
    function contours(values) {
        var tz = threshold(values);
        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
            var domain = _d3Array.extent(values), start = domain[0], stop = domain[1];
            tz = _d3Array.tickStep(start, stop, tz);
            tz = _d3Array.range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
        } else tz = tz.slice().sort(_ascendingDefault.default);
        return tz.map(function(value) {
            return contour(values, value);
        });
    }
    // Accumulate, smooth contour rings, assign holes to exterior rings.
    // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
    function contour(values, value) {
        var polygons = [], holes = [];
        isorings(values, value, function(ring) {
            smooth(ring, values, value);
            if (_areaDefault.default(ring) > 0) polygons.push([
                ring
            ]);
            else holes.push(ring);
        });
        holes.forEach(function(hole) {
            for(var i = 0, n = polygons.length, polygon; i < n; ++i)if (_containsDefault.default((polygon = polygons[i])[0], hole) !== -1) {
                polygon.push(hole);
                return;
            }
        });
        return {
            type: "MultiPolygon",
            value: value,
            coordinates: polygons
        };
    }
    // Marching squares with isolines stitched into rings.
    // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
    function isorings(values, value, callback) {
        var fragmentByStart = new Array, fragmentByEnd = new Array, x, y, t0, t1, t2, t3;
        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = values[0] >= value;
        cases[t1 << 1].forEach(stitch);
        while(++x < dx - 1){
            t0 = t1, t1 = values[x + 1] >= value;
            cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);
        // General case for the intermediate rows.
        while(++y < dy - 1){
            x = -1;
            t1 = values[y * dx + dx] >= value;
            t2 = values[y * dx] >= value;
            cases[t1 << 1 | t2 << 2].forEach(stitch);
            while(++x < dx - 1){
                t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
                t3 = t2, t2 = values[y * dx + x + 1] >= value;
                cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
            }
            cases[t1 | t2 << 3].forEach(stitch);
        }
        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while(++x < dx - 1){
            t3 = t2, t2 = values[y * dx + x + 1] >= value;
            cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);
        function stitch(line) {
            var start = [
                line[0][0] + x,
                line[0][1] + y
            ], end = [
                line[1][0] + x,
                line[1][1] + y
            ], startIndex = index(start), endIndex = index(end), f, g;
            if (f = fragmentByEnd[startIndex]) {
                if (g = fragmentByStart[endIndex]) {
                    delete fragmentByEnd[f.end];
                    delete fragmentByStart[g.start];
                    if (f === g) {
                        f.ring.push(end);
                        callback(f.ring);
                    } else fragmentByStart[f.start] = fragmentByEnd[g.end] = {
                        start: f.start,
                        end: g.end,
                        ring: f.ring.concat(g.ring)
                    };
                } else {
                    delete fragmentByEnd[f.end];
                    f.ring.push(end);
                    fragmentByEnd[f.end = endIndex] = f;
                }
            } else if (f = fragmentByStart[endIndex]) {
                if (g = fragmentByEnd[startIndex]) {
                    delete fragmentByStart[f.start];
                    delete fragmentByEnd[g.end];
                    if (f === g) {
                        f.ring.push(end);
                        callback(f.ring);
                    } else fragmentByStart[g.start] = fragmentByEnd[f.end] = {
                        start: g.start,
                        end: f.end,
                        ring: g.ring.concat(f.ring)
                    };
                } else {
                    delete fragmentByStart[f.start];
                    f.ring.unshift(start);
                    fragmentByStart[f.start = startIndex] = f;
                }
            } else fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
                start: startIndex,
                end: endIndex,
                ring: [
                    start,
                    end
                ]
            };
        }
    }
    function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
    }
    function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
            var x = point[0], y = point[1], xt = x | 0, yt = y | 0, v0, v1 = values[yt * dx + xt];
            if (x > 0 && x < dx && xt === x) {
                v0 = values[yt * dx + xt - 1];
                point[0] = x + (value - v0) / (v1 - v0) - 0.5;
            }
            if (y > 0 && y < dy && yt === y) {
                v0 = values[(yt - 1) * dx + xt];
                point[1] = y + (value - v0) / (v1 - v0) - 0.5;
            }
        });
    }
    contours.contour = contour;
    contours.size = function(_) {
        if (!arguments.length) return [
            dx,
            dy
        ];
        var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
        if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
    };
    contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? _constantDefault.default(_array.slice.call(_)) : _constantDefault.default(_), contours) : threshold;
    };
    contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : _noopDefault.default, contours) : smooth === smoothLinear;
    };
    return contours;
};

},{"d3-array":"dclxS","./array":"bnU0k","./ascending":"gLF4h","./area":"cSUZQ","./constant":"d3tM8","./contains":"akiFW","./noop":"h4Lcw","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bnU0k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "slice", ()=>slice
);
var array = Array.prototype;
var slice = array.slice;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gLF4h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b) {
    return a - b;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cSUZQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(ring) {
    var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
    while(++i < n)area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
    return area;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"d3tM8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"akiFW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(ring, hole) {
    var i = -1, n = hole.length, c;
    while(++i < n)if (c = ringContains(ring, hole[i])) return c;
    return 0;
};
function ringContains(ring, point) {
    var x = point[0], y = point[1], contains = -1;
    for(var i = 0, n = ring.length, j = n - 1; i < n; j = i++){
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;
    }
    return contains;
}
function segmentContains(a, b, c) {
    var i;
    return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}
function collinear(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}
function within(p, q, r) {
    return p <= q && q <= r || r <= q && q <= p;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"h4Lcw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9HCA4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Array = require("d3-array");
var _array = require("./array");
var _blur = require("./blur");
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var _contours = require("./contours");
var _contoursDefault = parcelHelpers.interopDefault(_contours);
function defaultX(d) {
    return d[0];
}
function defaultY(d) {
    return d[1];
}
function defaultWeight() {
    return 1;
}
exports.default = function() {
    var x = defaultX, y = defaultY, weight = defaultWeight, dx = 960, dy = 500, r = 20, k = 2, o = r * 3, n = dx + o * 2 >> k, m = dy + o * 2 >> k, threshold = _constantDefault.default(20);
    function density(data1) {
        var values0 = new Float32Array(n * m), values1 = new Float32Array(n * m);
        data1.forEach(function(d, i, data) {
            var xi = +x(d, i, data) + o >> k, yi = +y(d, i, data) + o >> k, wi = +weight(d, i, data);
            if (xi >= 0 && xi < n && yi >= 0 && yi < m) values0[xi + yi * n] += wi;
        });
        // TODO Optimize.
        _blur.blurX({
            width: n,
            height: m,
            data: values0
        }, {
            width: n,
            height: m,
            data: values1
        }, r >> k);
        _blur.blurY({
            width: n,
            height: m,
            data: values1
        }, {
            width: n,
            height: m,
            data: values0
        }, r >> k);
        _blur.blurX({
            width: n,
            height: m,
            data: values0
        }, {
            width: n,
            height: m,
            data: values1
        }, r >> k);
        _blur.blurY({
            width: n,
            height: m,
            data: values1
        }, {
            width: n,
            height: m,
            data: values0
        }, r >> k);
        _blur.blurX({
            width: n,
            height: m,
            data: values0
        }, {
            width: n,
            height: m,
            data: values1
        }, r >> k);
        _blur.blurY({
            width: n,
            height: m,
            data: values1
        }, {
            width: n,
            height: m,
            data: values0
        }, r >> k);
        var tz = threshold(values0);
        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
            var stop = _d3Array.max(values0);
            tz = _d3Array.tickStep(0, stop, tz);
            tz = _d3Array.range(0, Math.floor(stop / tz) * tz, tz);
            tz.shift();
        }
        return _contoursDefault.default().thresholds(tz).size([
            n,
            m
        ])(values0).map(transform);
    }
    function transform(geometry) {
        geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
    }
    function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
    }
    function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
    }
    // TODO Optimize.
    function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
    }
    function resize() {
        o = r * 3;
        n = dx + o * 2 >> k;
        m = dy + o * 2 >> k;
        return density;
    }
    density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : _constantDefault.default(+_), density) : x;
    };
    density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : _constantDefault.default(+_), density) : y;
    };
    density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : _constantDefault.default(+_), density) : weight;
    };
    density.size = function(_) {
        if (!arguments.length) return [
            dx,
            dy
        ];
        var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
        if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
    };
    density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
    };
    density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? _constantDefault.default(_array.slice.call(_)) : _constantDefault.default(_), density) : threshold;
    };
    density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
    };
    return density;
};

},{"d3-array":"dclxS","./array":"bnU0k","./blur":"kVtUS","./constant":"d3tM8","./contours":"k2ecu","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kVtUS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
parcelHelpers.export(exports, "blurX", ()=>blurX
);
// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
parcelHelpers.export(exports, "blurY", ()=>blurY
);
function blurX(source, target, r) {
    var n = source.width, m = source.height, w = (r << 1) + 1;
    for(var j = 0; j < m; ++j)for(var i = 0, sr = 0; i < n + r; ++i){
        if (i < n) sr += source.data[i + j * n];
        if (i >= r) {
            if (i >= w) sr -= source.data[i - w + j * n];
            target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
        }
    }
}
function blurY(source, target, r) {
    var n = source.width, m = source.height, w = (r << 1) + 1;
    for(var i = 0; i < n; ++i)for(var j = 0, sr = 0; j < m + r; ++j){
        if (j < m) sr += source.data[i + j * n];
        if (j >= r) {
            if (j >= w) sr -= source.data[i + (j - w) * n];
            target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
        }
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lK0ts":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dsvFormat", ()=>_dsvJsDefault.default
);
parcelHelpers.export(exports, "csvParse", ()=>_csvJs.csvParse
);
parcelHelpers.export(exports, "csvParseRows", ()=>_csvJs.csvParseRows
);
parcelHelpers.export(exports, "csvFormat", ()=>_csvJs.csvFormat
);
parcelHelpers.export(exports, "csvFormatBody", ()=>_csvJs.csvFormatBody
);
parcelHelpers.export(exports, "csvFormatRows", ()=>_csvJs.csvFormatRows
);
parcelHelpers.export(exports, "csvFormatRow", ()=>_csvJs.csvFormatRow
);
parcelHelpers.export(exports, "csvFormatValue", ()=>_csvJs.csvFormatValue
);
parcelHelpers.export(exports, "tsvParse", ()=>_tsvJs.tsvParse
);
parcelHelpers.export(exports, "tsvParseRows", ()=>_tsvJs.tsvParseRows
);
parcelHelpers.export(exports, "tsvFormat", ()=>_tsvJs.tsvFormat
);
parcelHelpers.export(exports, "tsvFormatBody", ()=>_tsvJs.tsvFormatBody
);
parcelHelpers.export(exports, "tsvFormatRows", ()=>_tsvJs.tsvFormatRows
);
parcelHelpers.export(exports, "tsvFormatRow", ()=>_tsvJs.tsvFormatRow
);
parcelHelpers.export(exports, "tsvFormatValue", ()=>_tsvJs.tsvFormatValue
);
parcelHelpers.export(exports, "autoType", ()=>_autoTypeJsDefault.default
);
var _dsvJs = require("./dsv.js");
var _dsvJsDefault = parcelHelpers.interopDefault(_dsvJs);
var _csvJs = require("./csv.js");
var _tsvJs = require("./tsv.js");
var _autoTypeJs = require("./autoType.js");
var _autoTypeJsDefault = parcelHelpers.interopDefault(_autoTypeJs);

},{"./dsv.js":"9DCXB","./csv.js":"8PPRo","./tsv.js":"iCdK0","./autoType.js":"3EEEE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9DCXB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var EOL = {
}, EOF = {
}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
    }).join(",") + "}");
}
function customConverter(columns, f) {
    var object = objectConverter(columns);
    return function(row, i) {
        return f(object(row), i, columns);
    };
}
// Compute unique columns in order of discovery.
function inferColumns(rows) {
    var columnSet = Object.create(null), columns = [];
    rows.forEach(function(row) {
        for(var column in row)if (!(column in columnSet)) columns.push(columnSet[column] = column);
    });
    return columns;
}
function pad(value, width) {
    var s = value + "", length = s.length;
    return length < width ? new Array(width - length + 1).join(0) + s : s;
}
function formatYear(year) {
    return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}
function formatDate(date) {
    var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
    return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
exports.default = function(delimiter) {
    var reFormat = new RegExp("[\"" + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
    function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
            if (convert) return convert(row, i - 1);
            columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
    }
    function parseRows(text, f) {
        var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false; // current token followed by EOL?
        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;
        function token() {
            if (eof) return EOF;
            if (eol) return eol = false, EOL;
            // Unescape quotes.
            var i, j = I, c;
            if (text.charCodeAt(j) === QUOTE) {
                while((I++) < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
                if ((i = I) >= N) eof = true;
                else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
                else if (c === RETURN) {
                    eol = true;
                    if (text.charCodeAt(I) === NEWLINE) ++I;
                }
                return text.slice(j + 1, i - 1).replace(/""/g, "\"");
            }
            // Find next delimiter or newline.
            while(I < N){
                if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
                else if (c === RETURN) {
                    eol = true;
                    if (text.charCodeAt(I) === NEWLINE) ++I;
                } else if (c !== DELIMITER) continue;
                return text.slice(j, i);
            }
            // Return last token before EOF.
            return eof = true, text.slice(j, N);
        }
        while((t = token()) !== EOF){
            var row = [];
            while(t !== EOL && t !== EOF)row.push(t), t = token();
            if (f && (row = f(row, n++)) == null) continue;
            rows.push(row);
        }
        return rows;
    }
    function preformatBody(rows, columns) {
        return rows.map(function(row) {
            return columns.map(function(column) {
                return formatValue(row[column]);
            }).join(delimiter);
        });
    }
    function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [
            columns.map(formatValue).join(delimiter)
        ].concat(preformatBody(rows, columns)).join("\n");
    }
    function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
    }
    function formatRows(rows) {
        return rows.map(formatRow).join("\n");
    }
    function formatRow(row) {
        return row.map(formatValue).join(delimiter);
    }
    function formatValue(value) {
        return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\"" : value;
    }
    return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8PPRo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "csvParse", ()=>csvParse
);
parcelHelpers.export(exports, "csvParseRows", ()=>csvParseRows
);
parcelHelpers.export(exports, "csvFormat", ()=>csvFormat
);
parcelHelpers.export(exports, "csvFormatBody", ()=>csvFormatBody
);
parcelHelpers.export(exports, "csvFormatRows", ()=>csvFormatRows
);
parcelHelpers.export(exports, "csvFormatRow", ()=>csvFormatRow
);
parcelHelpers.export(exports, "csvFormatValue", ()=>csvFormatValue
);
var _dsvJs = require("./dsv.js");
var _dsvJsDefault = parcelHelpers.interopDefault(_dsvJs);
var csv = _dsvJsDefault.default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

},{"./dsv.js":"9DCXB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iCdK0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tsvParse", ()=>tsvParse
);
parcelHelpers.export(exports, "tsvParseRows", ()=>tsvParseRows
);
parcelHelpers.export(exports, "tsvFormat", ()=>tsvFormat
);
parcelHelpers.export(exports, "tsvFormatBody", ()=>tsvFormatBody
);
parcelHelpers.export(exports, "tsvFormatRows", ()=>tsvFormatRows
);
parcelHelpers.export(exports, "tsvFormatRow", ()=>tsvFormatRow
);
parcelHelpers.export(exports, "tsvFormatValue", ()=>tsvFormatValue
);
var _dsvJs = require("./dsv.js");
var _dsvJsDefault = parcelHelpers.interopDefault(_dsvJs);
var tsv = _dsvJsDefault.default("\t");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

},{"./dsv.js":"9DCXB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3EEEE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function autoType(object) {
    for(var key in object){
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
            if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
            value = new Date(value);
        } else continue;
        object[key] = value;
    }
    return object;
}
exports.default = autoType;
// https://github.com/d3/d3-dsv/issues/45
var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hPJXo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blob", ()=>_blobJsDefault.default
);
parcelHelpers.export(exports, "buffer", ()=>_bufferJsDefault.default
);
parcelHelpers.export(exports, "dsv", ()=>_dsvJsDefault.default
);
parcelHelpers.export(exports, "csv", ()=>_dsvJs.csv
);
parcelHelpers.export(exports, "tsv", ()=>_dsvJs.tsv
);
parcelHelpers.export(exports, "image", ()=>_imageJsDefault.default
);
parcelHelpers.export(exports, "json", ()=>_jsonJsDefault.default
);
parcelHelpers.export(exports, "text", ()=>_textJsDefault.default
);
parcelHelpers.export(exports, "xml", ()=>_xmlJsDefault.default
);
parcelHelpers.export(exports, "html", ()=>_xmlJs.html
);
parcelHelpers.export(exports, "svg", ()=>_xmlJs.svg
);
var _blobJs = require("./blob.js");
var _blobJsDefault = parcelHelpers.interopDefault(_blobJs);
var _bufferJs = require("./buffer.js");
var _bufferJsDefault = parcelHelpers.interopDefault(_bufferJs);
var _dsvJs = require("./dsv.js");
var _dsvJsDefault = parcelHelpers.interopDefault(_dsvJs);
var _imageJs = require("./image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _jsonJs = require("./json.js");
var _jsonJsDefault = parcelHelpers.interopDefault(_jsonJs);
var _textJs = require("./text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);
var _xmlJs = require("./xml.js");
var _xmlJsDefault = parcelHelpers.interopDefault(_xmlJs);

},{"./blob.js":"eTK94","./buffer.js":"gV8MU","./dsv.js":"lO4Xs","./image.js":"aZBG4","./json.js":"iyiKg","./text.js":"7uNAr","./xml.js":"cIjm1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eTK94":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function responseBlob(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.blob();
}
exports.default = function(input, init) {
    return fetch(input, init).then(responseBlob);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gV8MU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function responseArrayBuffer(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.arrayBuffer();
}
exports.default = function(input, init) {
    return fetch(input, init).then(responseArrayBuffer);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lO4Xs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "csv", ()=>csv
);
parcelHelpers.export(exports, "tsv", ()=>tsv
);
var _d3Dsv = require("d3-dsv");
var _textJs = require("./text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);
function dsvParse(parse) {
    return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return _textJsDefault.default(input, init).then(function(response) {
            return parse(response, row);
        });
    };
}
function dsv(delimiter, input, init, row) {
    if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
    var format = _d3Dsv.dsvFormat(delimiter);
    return _textJsDefault.default(input, init).then(function(response) {
        return format.parse(response, row);
    });
}
exports.default = dsv;
var csv = dsvParse(_d3Dsv.csvParse);
var tsv = dsvParse(_d3Dsv.tsvParse);

},{"d3-dsv":"lK0ts","./text.js":"7uNAr","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7uNAr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function responseText(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.text();
}
exports.default = function(input, init) {
    return fetch(input, init).then(responseText);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aZBG4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(input, init) {
    return new Promise(function(resolve, reject) {
        var image = new Image;
        for(var key in init)image[key] = init[key];
        image.onerror = reject;
        image.onload = function() {
            resolve(image);
        };
        image.src = input;
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iyiKg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function responseJson(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    if (response.status === 204 || response.status === 205) return;
    return response.json();
}
exports.default = function(input, init) {
    return fetch(input, init).then(responseJson);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cIjm1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "html", ()=>html
);
parcelHelpers.export(exports, "svg", ()=>svg
);
var _textJs = require("./text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);
function parser(type) {
    return function(input, init) {
        return _textJsDefault.default(input, init).then(function(text) {
            return (new DOMParser).parseFromString(text, type);
        });
    };
}
exports.default = parser("application/xml");
var html = parser("text/html");
var svg = parser("image/svg+xml");

},{"./text.js":"7uNAr","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5HM4e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "forceCenter", ()=>_centerDefault.default
);
parcelHelpers.export(exports, "forceCollide", ()=>_collideDefault.default
);
parcelHelpers.export(exports, "forceLink", ()=>_linkDefault.default
);
parcelHelpers.export(exports, "forceManyBody", ()=>_manyBodyDefault.default
);
parcelHelpers.export(exports, "forceRadial", ()=>_radialDefault.default
);
parcelHelpers.export(exports, "forceSimulation", ()=>_simulationDefault.default
);
parcelHelpers.export(exports, "forceX", ()=>_xDefault.default
);
parcelHelpers.export(exports, "forceY", ()=>_yDefault.default
);
var _center = require("./center");
var _centerDefault = parcelHelpers.interopDefault(_center);
var _collide = require("./collide");
var _collideDefault = parcelHelpers.interopDefault(_collide);
var _link = require("./link");
var _linkDefault = parcelHelpers.interopDefault(_link);
var _manyBody = require("./manyBody");
var _manyBodyDefault = parcelHelpers.interopDefault(_manyBody);
var _radial = require("./radial");
var _radialDefault = parcelHelpers.interopDefault(_radial);
var _simulation = require("./simulation");
var _simulationDefault = parcelHelpers.interopDefault(_simulation);
var _x = require("./x");
var _xDefault = parcelHelpers.interopDefault(_x);
var _y = require("./y");
var _yDefault = parcelHelpers.interopDefault(_y);

},{"./center":"8COnD","./collide":"8SXlV","./link":"fubRB","./manyBody":"kQ23N","./radial":"f9FCw","./simulation":"eTFSL","./x":"cvqxl","./y":"cmEL4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8COnD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x, y) {
    var nodes;
    if (x == null) x = 0;
    if (y == null) y = 0;
    function force() {
        var i, n = nodes.length, node, sx = 0, sy = 0;
        for(i = 0; i < n; ++i)node = nodes[i], sx += node.x, sy += node.y;
        for(sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i)node = nodes[i], node.x -= sx, node.y -= sy;
    }
    force.initialize = function(_) {
        nodes = _;
    };
    force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
    };
    force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
    };
    return force;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8SXlV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var _jiggle = require("./jiggle");
var _jiggleDefault = parcelHelpers.interopDefault(_jiggle);
var _d3Quadtree = require("d3-quadtree");
function x2(d) {
    return d.x + d.vx;
}
function y2(d) {
    return d.y + d.vy;
}
exports.default = function(radius) {
    var nodes, radii, strength = 1, iterations = 1;
    if (typeof radius !== "function") radius = _constantDefault.default(radius == null ? 1 : +radius);
    function force() {
        var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
        for(var k = 0; k < iterations; ++k){
            tree = _d3Quadtree.quadtree(nodes, x2, y2).visitAfter(prepare);
            for(i = 0; i < n; ++i){
                node = nodes[i];
                ri = radii[node.index], ri2 = ri * ri;
                xi = node.x + node.vx;
                yi = node.y + node.vy;
                tree.visit(apply);
            }
        }
        function apply(quad, x0, y0, x1, y1) {
            var data = quad.data, rj = quad.r, r = ri + rj;
            if (data) {
                if (data.index > node.index) {
                    var x = xi - data.x - data.vx, y = yi - data.y - data.vy, l = x * x + y * y;
                    if (l < r * r) {
                        if (x === 0) x = _jiggleDefault.default(), l += x * x;
                        if (y === 0) y = _jiggleDefault.default(), l += y * y;
                        l = (r - (l = Math.sqrt(l))) / l * strength;
                        node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                        node.vy += (y *= l) * r;
                        data.vx -= x * (r = 1 - r);
                        data.vy -= y * r;
                    }
                }
                return;
            }
            return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
    }
    function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for(var i = quad.r = 0; i < 4; ++i)if (quad[i] && quad[i].r > quad.r) quad.r = quad[i].r;
    }
    function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for(i = 0; i < n; ++i)node = nodes[i], radii[node.index] = +radius(node, i, nodes);
    }
    force.initialize = function(_) {
        nodes = _;
        initialize();
    };
    force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
    };
    force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
    };
    force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : _constantDefault.default(+_), initialize(), force) : radius;
    };
    return force;
};

},{"./constant":"fKGMF","./jiggle":"iluGX","d3-quadtree":"1oyVd","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fKGMF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iluGX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    return (Math.random() - 0.5) * 0.000001;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1oyVd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "quadtree", ()=>_quadtreeJsDefault.default
);
var _quadtreeJs = require("./quadtree.js");
var _quadtreeJsDefault = parcelHelpers.interopDefault(_quadtreeJs);

},{"./quadtree.js":"aqMV5","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aqMV5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _addJs = require("./add.js");
var _addJsDefault = parcelHelpers.interopDefault(_addJs);
var _coverJs = require("./cover.js");
var _coverJsDefault = parcelHelpers.interopDefault(_coverJs);
var _dataJs = require("./data.js");
var _dataJsDefault = parcelHelpers.interopDefault(_dataJs);
var _extentJs = require("./extent.js");
var _extentJsDefault = parcelHelpers.interopDefault(_extentJs);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _removeJs = require("./remove.js");
var _removeJsDefault = parcelHelpers.interopDefault(_removeJs);
var _rootJs = require("./root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
var _sizeJs = require("./size.js");
var _sizeJsDefault = parcelHelpers.interopDefault(_sizeJs);
var _visitJs = require("./visit.js");
var _visitJsDefault = parcelHelpers.interopDefault(_visitJs);
var _visitAfterJs = require("./visitAfter.js");
var _visitAfterJsDefault = parcelHelpers.interopDefault(_visitAfterJs);
var _xJs = require("./x.js");
var _xJsDefault = parcelHelpers.interopDefault(_xJs);
var _yJs = require("./y.js");
var _yJsDefault = parcelHelpers.interopDefault(_yJs);
function quadtree(nodes, x, y) {
    var tree = new Quadtree(x == null ? _xJs.defaultX : x, y == null ? _yJs.defaultY : y, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
}
exports.default = quadtree;
function Quadtree(x, y, x0, y0, x1, y1) {
    this._x = x;
    this._y = y;
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    this._root = undefined;
}
function leaf_copy(leaf) {
    var copy = {
        data: leaf.data
    }, next = copy;
    while(leaf = leaf.next)next = next.next = {
        data: leaf.data
    };
    return copy;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
    if (!node) return copy;
    if (!node.length) return copy._root = leaf_copy(node), copy;
    nodes = [
        {
            source: node,
            target: copy._root = new Array(4)
        }
    ];
    while(node = nodes.pop()){
        for(var i = 0; i < 4; ++i)if (child = node.source[i]) {
            if (child.length) nodes.push({
                source: child,
                target: node.target[i] = new Array(4)
            });
            else node.target[i] = leaf_copy(child);
        }
    }
    return copy;
};
treeProto.add = _addJsDefault.default;
treeProto.addAll = _addJs.addAll;
treeProto.cover = _coverJsDefault.default;
treeProto.data = _dataJsDefault.default;
treeProto.extent = _extentJsDefault.default;
treeProto.find = _findJsDefault.default;
treeProto.remove = _removeJsDefault.default;
treeProto.removeAll = _removeJs.removeAll;
treeProto.root = _rootJsDefault.default;
treeProto.size = _sizeJsDefault.default;
treeProto.visit = _visitJsDefault.default;
treeProto.visitAfter = _visitAfterJsDefault.default;
treeProto.x = _xJsDefault.default;
treeProto.y = _yJsDefault.default;

},{"./add.js":"63uWd","./cover.js":"e4eHZ","./data.js":"eZHi2","./extent.js":"6QWx2","./find.js":"8oAlt","./remove.js":"20jcn","./root.js":"gXhtT","./size.js":"5miFk","./visit.js":"feDAT","./visitAfter.js":"6BIou","./x.js":"02xGA","./y.js":"cLUJb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"63uWd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addAll", ()=>addAll
);
exports.default = function(d) {
    var x = +this._x.call(null, d), y = +this._y.call(null, d);
    return add(this.cover(x, y), x, y, d);
};
function add(tree, x, y, d) {
    if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points
    var parent, node = tree._root, leaf = {
        data: d
    }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
    // If the tree is empty, initialize the root as a leaf.
    if (!node) return tree._root = leaf, tree;
    // Find the existing leaf for the new point, or add it.
    while(node.length){
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;
        else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;
        else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
    }
    // Is the new point is exactly coincident with the existing point?
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
    // Otherwise, split the leaf node until the old and new point are separated.
    do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;
        else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;
        else y1 = ym;
    }while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm))
    return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data) {
    var d, i, n = data.length, x, y, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
    // Compute the points and their extent.
    for(i = 0; i < n; ++i){
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
    }
    // If there were no (valid) points, abort.
    if (x0 > x1 || y0 > y1) return this;
    // Expand the tree to cover the new points.
    this.cover(x0, y0).cover(x1, y1);
    // Add the new points.
    for(i = 0; i < n; ++i)add(this, xz[i], yz[i], data[i]);
    return this;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e4eHZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x, y) {
    if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points
    var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
    // If the quadtree has no extent, initialize them.
    // Integer extent are necessary so that if we later double the extent,
    // the existing quadrant boundaries don’t change due to floating point error!
    if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
    } else {
        var z = x1 - x0, node = this._root, parent, i;
        while(x0 > x || x >= x1 || y0 > y || y >= y1){
            i = (y < y0) << 1 | x < x0;
            parent = new Array(4), parent[i] = node, node = parent, z *= 2;
            switch(i){
                case 0:
                    x1 = x0 + z, y1 = y0 + z;
                    break;
                case 1:
                    x0 = x1 - z, y1 = y0 + z;
                    break;
                case 2:
                    x1 = x0 + z, y0 = y1 - z;
                    break;
                case 3:
                    x0 = x1 - z, y0 = y1 - z;
                    break;
            }
        }
        if (this._root && this._root.length) this._root = node;
    }
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    return this;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eZHi2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    var data = [];
    this.visit(function(node) {
        if (!node.length) do data.push(node.data);
        while (node = node.next)
    });
    return data;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6QWx2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(_) {
    return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [
        [
            this._x0,
            this._y0
        ],
        [
            this._x1,
            this._y1
        ]
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8oAlt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _quadJs = require("./quad.js");
var _quadJsDefault = parcelHelpers.interopDefault(_quadJs);
exports.default = function(x, y, radius) {
    var data, x0 = this._x0, y0 = this._y0, x1, y1, x2, y2, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i;
    if (node) quads.push(new _quadJsDefault.default(node, x0, y0, x3, y3));
    if (radius == null) radius = Infinity;
    else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
    }
    while(q = quads.pop()){
        // Stop searching if this quadrant can’t contain a closer node.
        if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue;
        // Bisect the current quadrant.
        if (node.length) {
            var xm = (x1 + x2) / 2, ym = (y1 + y2) / 2;
            quads.push(new _quadJsDefault.default(node[3], xm, ym, x2, y2), new _quadJsDefault.default(node[2], x1, ym, xm, y2), new _quadJsDefault.default(node[1], xm, y1, x2, ym), new _quadJsDefault.default(node[0], x1, y1, xm, ym));
            // Visit the closest quadrant first.
            if (i = (y >= ym) << 1 | x >= xm) {
                q = quads[quads.length - 1];
                quads[quads.length - 1] = quads[quads.length - 1 - i];
                quads[quads.length - 1 - i] = q;
            }
        } else {
            var dx = x - +this._x.call(null, node.data), dy = y - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
            if (d2 < radius) {
                var d = Math.sqrt(radius = d2);
                x0 = x - d, y0 = y - d;
                x3 = x + d, y3 = y + d;
                data = node.data;
            }
        }
    }
    return data;
};

},{"./quad.js":"F8aMC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"F8aMC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(node, x0, y0, x1, y1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"20jcn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "removeAll", ()=>removeAll
);
exports.default = function(d) {
    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points
    var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x, y, xm, ym, right, bottom, i, j;
    // If the tree is empty, initialize the root as a leaf.
    if (!node) return this;
    // Find the leaf node for the point.
    // While descending, also retain the deepest parent with a non-removed sibling.
    if (node.length) while(true){
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;
        else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;
        else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
    }
    // Find the point to remove.
    while(node.data !== d)if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;
    // If there are multiple coincident points, remove just the point.
    if (previous) return next ? previous.next = next : delete previous.next, this;
    // If this is the root point, remove it.
    if (!parent) return this._root = next, this;
    // Remove this leaf.
    next ? parent[i] = next : delete parent[i];
    // If the parent now contains exactly one leaf, collapse superfluous parents.
    if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
    }
    return this;
};
function removeAll(data) {
    for(var i = 0, n = data.length; i < n; ++i)this.remove(data[i]);
    return this;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gXhtT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    return this._root;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5miFk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    var size = 0;
    this.visit(function(node) {
        if (!node.length) do ++size;
        while (node = node.next)
    });
    return size;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"feDAT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _quadJs = require("./quad.js");
var _quadJsDefault = parcelHelpers.interopDefault(_quadJs);
exports.default = function(callback) {
    var quads = [], q, node = this._root, child, x0, y0, x1, y1;
    if (node) quads.push(new _quadJsDefault.default(node, this._x0, this._y0, this._x1, this._y1));
    while(q = quads.pop())if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[3]) quads.push(new _quadJsDefault.default(child, xm, ym, x1, y1));
        if (child = node[2]) quads.push(new _quadJsDefault.default(child, x0, ym, xm, y1));
        if (child = node[1]) quads.push(new _quadJsDefault.default(child, xm, y0, x1, ym));
        if (child = node[0]) quads.push(new _quadJsDefault.default(child, x0, y0, xm, ym));
    }
    return this;
};

},{"./quad.js":"F8aMC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6BIou":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _quadJs = require("./quad.js");
var _quadJsDefault = parcelHelpers.interopDefault(_quadJs);
exports.default = function(callback) {
    var quads = [], next = [], q;
    if (this._root) quads.push(new _quadJsDefault.default(this._root, this._x0, this._y0, this._x1, this._y1));
    while(q = quads.pop()){
        var node = q.node;
        if (node.length) {
            var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
            if (child = node[0]) quads.push(new _quadJsDefault.default(child, x0, y0, xm, ym));
            if (child = node[1]) quads.push(new _quadJsDefault.default(child, xm, y0, x1, ym));
            if (child = node[2]) quads.push(new _quadJsDefault.default(child, x0, ym, xm, y1));
            if (child = node[3]) quads.push(new _quadJsDefault.default(child, xm, ym, x1, y1));
        }
        next.push(q);
    }
    while(q = next.pop())callback(q.node, q.x0, q.y0, q.x1, q.y1);
    return this;
};

},{"./quad.js":"F8aMC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"02xGA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultX", ()=>defaultX
);
function defaultX(d) {
    return d[0];
}
exports.default = function(_) {
    return arguments.length ? (this._x = _, this) : this._x;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cLUJb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultY", ()=>defaultY
);
function defaultY(d) {
    return d[1];
}
exports.default = function(_) {
    return arguments.length ? (this._y = _, this) : this._y;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fubRB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var _jiggle = require("./jiggle");
var _jiggleDefault = parcelHelpers.interopDefault(_jiggle);
var _d3Collection = require("d3-collection");
function index(d) {
    return d.index;
}
function find(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node) throw new Error("missing: " + nodeId);
    return node;
}
exports.default = function(links) {
    var id = index, strength = defaultStrength, strengths, distance = _constantDefault.default(30), distances, nodes, count, bias, iterations = 1;
    if (links == null) links = [];
    function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
    }
    function force(alpha) {
        for(var k = 0, n = links.length; k < iterations; ++k)for(var i = 0, link, source, target, x, y, l, b; i < n; ++i){
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || _jiggleDefault.default();
            y = target.y + target.vy - source.y - source.vy || _jiggleDefault.default();
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
        }
    }
    function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, m = links.length, nodeById = _d3Collection.map(nodes, id), link;
        for(i = 0, count = new Array(n); i < m; ++i){
            link = links[i], link.index = i;
            if (typeof link.source !== "object") link.source = find(nodeById, link.source);
            if (typeof link.target !== "object") link.target = find(nodeById, link.target);
            count[link.source.index] = (count[link.source.index] || 0) + 1;
            count[link.target.index] = (count[link.target.index] || 0) + 1;
        }
        for(i = 0, bias = new Array(m); i < m; ++i)link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
    }
    function initializeStrength() {
        if (!nodes) return;
        for(var i = 0, n = links.length; i < n; ++i)strengths[i] = +strength(links[i], i, links);
    }
    function initializeDistance() {
        if (!nodes) return;
        for(var i = 0, n = links.length; i < n; ++i)distances[i] = +distance(links[i], i, links);
    }
    force.initialize = function(_) {
        nodes = _;
        initialize();
    };
    force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
    };
    force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
    };
    force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
    };
    force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : _constantDefault.default(+_), initializeStrength(), force) : strength;
    };
    force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : _constantDefault.default(+_), initializeDistance(), force) : distance;
    };
    return force;
};

},{"./constant":"fKGMF","./jiggle":"iluGX","d3-collection":"4zn9z","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kQ23N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var _jiggle = require("./jiggle");
var _jiggleDefault = parcelHelpers.interopDefault(_jiggle);
var _d3Quadtree = require("d3-quadtree");
var _simulation = require("./simulation");
exports.default = function() {
    var nodes, node1, alpha, strength1 = _constantDefault.default(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
    function force(_) {
        var i, n = nodes.length, tree = _d3Quadtree.quadtree(nodes, _simulation.x, _simulation.y).visitAfter(accumulate);
        for(alpha = _, i = 0; i < n; ++i)node1 = nodes[i], tree.visit(apply);
    }
    function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for(i = 0; i < n; ++i)node = nodes[i], strengths[node.index] = +strength1(node, i, nodes);
    }
    function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;
        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
            for(x = y = i = 0; i < 4; ++i)if ((q = quad[i]) && (c = Math.abs(q.value))) strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            quad.x = x / weight;
            quad.y = y / weight;
        } else {
            q = quad;
            q.x = q.data.x;
            q.y = q.data.y;
            do strength += strengths[q.data.index];
            while (q = q.next)
        }
        quad.value = strength;
    }
    function apply(quad, x1, _, x2) {
        if (!quad.value) return true;
        var x = quad.x - node1.x, y = quad.y - node1.y, w = x2 - x1, l = x * x + y * y;
        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
            if (l < distanceMax2) {
                if (x === 0) x = _jiggleDefault.default(), l += x * x;
                if (y === 0) y = _jiggleDefault.default(), l += y * y;
                if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
                node1.vx += x * quad.value * alpha / l;
                node1.vy += y * quad.value * alpha / l;
            }
            return true;
        } else if (quad.length || l >= distanceMax2) return;
        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node1 || quad.next) {
            if (x === 0) x = _jiggleDefault.default(), l += x * x;
            if (y === 0) y = _jiggleDefault.default(), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }
        do if (quad.data !== node1) {
            w = strengths[quad.data.index] * alpha / l;
            node1.vx += x * w;
            node1.vy += y * w;
        }
        while (quad = quad.next)
    }
    force.initialize = function(_) {
        nodes = _;
        initialize();
    };
    force.strength = function(_) {
        return arguments.length ? (strength1 = typeof _ === "function" ? _ : _constantDefault.default(+_), initialize(), force) : strength1;
    };
    force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
    };
    force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
    };
    force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
    };
    return force;
};

},{"./constant":"fKGMF","./jiggle":"iluGX","d3-quadtree":"1oyVd","./simulation":"eTFSL","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eTFSL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "x", ()=>x1
);
parcelHelpers.export(exports, "y", ()=>y1
);
var _d3Dispatch = require("d3-dispatch");
var _d3Collection = require("d3-collection");
var _d3Timer = require("d3-timer");
function x1(d) {
    return d.x;
}
function y1(d) {
    return d.y;
}
var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
exports.default = function(nodes) {
    var simulation, alpha = 1, alphaMin = 0.001, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = _d3Collection.map(), stepper = _d3Timer.timer(step), event = _d3Dispatch.dispatch("tick", "end");
    if (nodes == null) nodes = [];
    function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
            stepper.stop();
            event.call("end", simulation);
        }
    }
    function tick(iterations) {
        var i, n = nodes.length, node;
        if (iterations === undefined) iterations = 1;
        for(var k = 0; k < iterations; ++k){
            alpha += (alphaTarget - alpha) * alphaDecay;
            forces.each(function(force) {
                force(alpha);
            });
            for(i = 0; i < n; ++i){
                node = nodes[i];
                if (node.fx == null) node.x += node.vx *= velocityDecay;
                else node.x = node.fx, node.vx = 0;
                if (node.fy == null) node.y += node.vy *= velocityDecay;
                else node.y = node.fy, node.vy = 0;
            }
        }
        return simulation;
    }
    function initializeNodes() {
        for(var i = 0, n = nodes.length, node; i < n; ++i){
            node = nodes[i], node.index = i;
            if (node.fx != null) node.x = node.fx;
            if (node.fy != null) node.y = node.fy;
            if (isNaN(node.x) || isNaN(node.y)) {
                var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
                node.x = radius * Math.cos(angle);
                node.y = radius * Math.sin(angle);
            }
            if (isNaN(node.vx) || isNaN(node.vy)) node.vx = node.vy = 0;
        }
    }
    function initializeForce(force) {
        if (force.initialize) force.initialize(nodes);
        return force;
    }
    initializeNodes();
    return simulation = {
        tick: tick,
        restart: function() {
            return stepper.restart(step), simulation;
        },
        stop: function() {
            return stepper.stop(), simulation;
        },
        nodes: function(_) {
            return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
        },
        alpha: function(_) {
            return arguments.length ? (alpha = +_, simulation) : alpha;
        },
        alphaMin: function(_) {
            return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },
        alphaDecay: function(_) {
            return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },
        alphaTarget: function(_) {
            return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },
        velocityDecay: function(_) {
            return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },
        force: function(name, _) {
            return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
        },
        find: function(x, y, radius) {
            var i = 0, n = nodes.length, dx, dy, d2, node, closest;
            if (radius == null) radius = Infinity;
            else radius *= radius;
            for(i = 0; i < n; ++i){
                node = nodes[i];
                dx = x - node.x;
                dy = y - node.y;
                d2 = dx * dx + dy * dy;
                if (d2 < radius) closest = node, radius = d2;
            }
            return closest;
        },
        on: function(name, _) {
            return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
    };
};

},{"d3-dispatch":"9d2te","d3-collection":"4zn9z","d3-timer":"82ygz","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"f9FCw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
exports.default = function(radius, x, y) {
    var nodes, strength = _constantDefault.default(0.1), strengths, radiuses;
    if (typeof radius !== "function") radius = _constantDefault.default(+radius);
    if (x == null) x = 0;
    if (y == null) y = 0;
    function force(alpha) {
        for(var i = 0, n = nodes.length; i < n; ++i){
            var node = nodes[i], dx = node.x - x || 0.000001, dy = node.y - y || 0.000001, r = Math.sqrt(dx * dx + dy * dy), k = (radiuses[i] - r) * strengths[i] * alpha / r;
            node.vx += dx * k;
            node.vy += dy * k;
        }
    }
    function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for(i = 0; i < n; ++i){
            radiuses[i] = +radius(nodes[i], i, nodes);
            strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
    }
    force.initialize = function(_) {
        nodes = _, initialize();
    };
    force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : _constantDefault.default(+_), initialize(), force) : strength;
    };
    force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : _constantDefault.default(+_), initialize(), force) : radius;
    };
    force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
    };
    force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
    };
    return force;
};

},{"./constant":"fKGMF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cvqxl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
exports.default = function(x) {
    var strength = _constantDefault.default(0.1), nodes, strengths, xz;
    if (typeof x !== "function") x = _constantDefault.default(x == null ? 0 : +x);
    function force(alpha) {
        for(var i = 0, n = nodes.length, node; i < n; ++i)node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
    function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for(i = 0; i < n; ++i)strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
    force.initialize = function(_) {
        nodes = _;
        initialize();
    };
    force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : _constantDefault.default(+_), initialize(), force) : strength;
    };
    force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : _constantDefault.default(+_), initialize(), force) : x;
    };
    return force;
};

},{"./constant":"fKGMF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cmEL4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
exports.default = function(y) {
    var strength = _constantDefault.default(0.1), nodes, strengths, yz;
    if (typeof y !== "function") y = _constantDefault.default(y == null ? 0 : +y);
    function force(alpha) {
        for(var i = 0, n = nodes.length, node; i < n; ++i)node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
    function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for(i = 0; i < n; ++i)strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
    force.initialize = function(_) {
        nodes = _;
        initialize();
    };
    force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : _constantDefault.default(+_), initialize(), force) : strength;
    };
    force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : _constantDefault.default(+_), initialize(), force) : y;
    };
    return force;
};

},{"./constant":"fKGMF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hzInr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatDefaultLocale", ()=>_defaultLocaleJsDefault.default
);
parcelHelpers.export(exports, "format", ()=>_defaultLocaleJs.format
);
parcelHelpers.export(exports, "formatPrefix", ()=>_defaultLocaleJs.formatPrefix
);
parcelHelpers.export(exports, "formatLocale", ()=>_localeJsDefault.default
);
parcelHelpers.export(exports, "formatSpecifier", ()=>_formatSpecifierJsDefault.default
);
parcelHelpers.export(exports, "FormatSpecifier", ()=>_formatSpecifierJs.FormatSpecifier
);
parcelHelpers.export(exports, "precisionFixed", ()=>_precisionFixedJsDefault.default
);
parcelHelpers.export(exports, "precisionPrefix", ()=>_precisionPrefixJsDefault.default
);
parcelHelpers.export(exports, "precisionRound", ()=>_precisionRoundJsDefault.default
);
var _defaultLocaleJs = require("./defaultLocale.js");
var _defaultLocaleJsDefault = parcelHelpers.interopDefault(_defaultLocaleJs);
var _localeJs = require("./locale.js");
var _localeJsDefault = parcelHelpers.interopDefault(_localeJs);
var _formatSpecifierJs = require("./formatSpecifier.js");
var _formatSpecifierJsDefault = parcelHelpers.interopDefault(_formatSpecifierJs);
var _precisionFixedJs = require("./precisionFixed.js");
var _precisionFixedJsDefault = parcelHelpers.interopDefault(_precisionFixedJs);
var _precisionPrefixJs = require("./precisionPrefix.js");
var _precisionPrefixJsDefault = parcelHelpers.interopDefault(_precisionPrefixJs);
var _precisionRoundJs = require("./precisionRound.js");
var _precisionRoundJsDefault = parcelHelpers.interopDefault(_precisionRoundJs);

},{"./defaultLocale.js":"2xO5L","./locale.js":"j5r27","./formatSpecifier.js":"55yO4","./precisionFixed.js":"e3JIq","./precisionPrefix.js":"7GxX5","./precisionRound.js":"1ZF1R","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2xO5L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "format", ()=>format
);
parcelHelpers.export(exports, "formatPrefix", ()=>formatPrefix
);
var _localeJs = require("./locale.js");
var _localeJsDefault = parcelHelpers.interopDefault(_localeJs);
var locale;
var format;
var formatPrefix;
defaultLocale({
    decimal: ".",
    thousands: ",",
    grouping: [
        3
    ],
    currency: [
        "$",
        ""
    ],
    minus: "-"
});
function defaultLocale(definition) {
    locale = _localeJsDefault.default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
}
exports.default = defaultLocale;

},{"./locale.js":"j5r27","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"j5r27":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exponentJs = require("./exponent.js");
var _exponentJsDefault = parcelHelpers.interopDefault(_exponentJs);
var _formatGroupJs = require("./formatGroup.js");
var _formatGroupJsDefault = parcelHelpers.interopDefault(_formatGroupJs);
var _formatNumeralsJs = require("./formatNumerals.js");
var _formatNumeralsJsDefault = parcelHelpers.interopDefault(_formatNumeralsJs);
var _formatSpecifierJs = require("./formatSpecifier.js");
var _formatSpecifierJsDefault = parcelHelpers.interopDefault(_formatSpecifierJs);
var _formatTrimJs = require("./formatTrim.js");
var _formatTrimJsDefault = parcelHelpers.interopDefault(_formatTrimJs);
var _formatTypesJs = require("./formatTypes.js");
var _formatTypesJsDefault = parcelHelpers.interopDefault(_formatTypesJs);
var _formatPrefixAutoJs = require("./formatPrefixAuto.js");
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var map = Array.prototype.map, prefixes = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "µ",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
];
exports.default = function(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? _identityJsDefault.default : _formatGroupJsDefault.default(map.call(locale.grouping, Number), locale.thousands + ""), currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "", currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "", decimal = locale.decimal === undefined ? "." : locale.decimal + "", numerals = locale.numerals === undefined ? _identityJsDefault.default : _formatNumeralsJsDefault.default(map.call(locale.numerals, String)), percent = locale.percent === undefined ? "%" : locale.percent + "", minus = locale.minus === undefined ? "-" : locale.minus + "", nan = locale.nan === undefined ? "NaN" : locale.nan + "";
    function newFormat(specifier) {
        specifier = _formatSpecifierJsDefault.default(specifier);
        var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";
        else if (!_formatTypesJsDefault.default[type]) precision === undefined && (precision = 12), trim = true, type = "g";
        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = _formatTypesJsDefault.default[type], maybeSuffix = /[defgprs%]/.test(type);
        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format(value) {
            var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
            if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
            } else {
                value = +value;
                // Determine the sign. -0 is not less than 0, but 1 / -0 is!
                var valueNegative = value < 0 || 1 / value < 0;
                // Perform the initial formatting.
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                // Trim insignificant zeros.
                if (trim) value = _formatTrimJsDefault.default(value);
                // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
                if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
                // Compute the prefix and suffix.
                valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAutoJs.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                // Break the formatted value into the integer “value” part that can be
                // grouped, and fractional or exponential “suffix” part that is not.
                if (maybeSuffix) {
                    i = -1, n = value.length;
                    while(++i < n)if (c = value.charCodeAt(i), 48 > c || c > 57) {
                        valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                        value = value.slice(0, i);
                        break;
                    }
                }
            }
            // If the fill character is not "0", grouping is applied before padding.
            if (comma && !zero) value = group(value, Infinity);
            // Compute the padding.
            var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
            // If the fill character is "0", grouping is applied after padding.
            if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
            // Reconstruct the final output based on the desired alignment.
            switch(align){
                case "<":
                    value = valuePrefix + value + valueSuffix + padding;
                    break;
                case "=":
                    value = valuePrefix + padding + value + valueSuffix;
                    break;
                case "^":
                    value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                    break;
                default:
                    value = padding + valuePrefix + value + valueSuffix;
                    break;
            }
            return numerals(value);
        }
        format.toString = function() {
            return specifier + "";
        };
        return format;
    }
    function formatPrefix(specifier, value1) {
        var f = newFormat((specifier = _formatSpecifierJsDefault.default(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(_exponentJsDefault.default(value1) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
        return function(value) {
            return f(k * value) + prefix;
        };
    }
    return {
        format: newFormat,
        formatPrefix: formatPrefix
    };
};

},{"./exponent.js":"6DGHE","./formatGroup.js":"cmI8S","./formatNumerals.js":"eiMiB","./formatSpecifier.js":"55yO4","./formatTrim.js":"4KDv5","./formatTypes.js":"8CE7u","./formatPrefixAuto.js":"4a8Al","./identity.js":"dcSc8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6DGHE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _formatDecimalJs = require("./formatDecimal.js");
exports.default = function(x) {
    return x = _formatDecimalJs.formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
};

},{"./formatDecimal.js":"eFLdP","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eFLdP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
parcelHelpers.export(exports, "formatDecimalParts", ()=>formatDecimalParts
);
exports.default = function(x) {
    return Math.abs(x = Math.round(x)) >= 1000000000000000000000 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
};
function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);
    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cmI8S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(grouping, thousands) {
    return function(value, width) {
        var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
        while(i > 0 && g > 0){
            if (length + g + 1 > width) g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width) break;
            g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eiMiB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(numerals) {
    return function(value) {
        return value.replace(/[0-9]/g, function(i) {
            return numerals[+i];
        });
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"55yO4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FormatSpecifier", ()=>FormatSpecifier
);
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
    });
}
exports.default = formatSpecifier;
formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof
function FormatSpecifier(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4KDv5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(s) {
    out: for(var n = s.length, i = 1, i0 = -1, i1; i < n; ++i)switch(s[i]){
        case ".":
            i0 = i1 = i;
            break;
        case "0":
            if (i0 === 0) i0 = i;
            i1 = i;
            break;
        default:
            if (!+s[i]) break out;
            if (i0 > 0) i0 = 0;
            break;
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8CE7u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _formatDecimalJs = require("./formatDecimal.js");
var _formatDecimalJsDefault = parcelHelpers.interopDefault(_formatDecimalJs);
var _formatPrefixAutoJs = require("./formatPrefixAuto.js");
var _formatPrefixAutoJsDefault = parcelHelpers.interopDefault(_formatPrefixAutoJs);
var _formatRoundedJs = require("./formatRounded.js");
var _formatRoundedJsDefault = parcelHelpers.interopDefault(_formatRoundedJs);
exports.default = {
    "%": function(x, p) {
        return (x * 100).toFixed(p);
    },
    "b": function(x) {
        return Math.round(x).toString(2);
    },
    "c": function(x) {
        return x + "";
    },
    "d": _formatDecimalJsDefault.default,
    "e": function(x, p) {
        return x.toExponential(p);
    },
    "f": function(x, p) {
        return x.toFixed(p);
    },
    "g": function(x, p) {
        return x.toPrecision(p);
    },
    "o": function(x) {
        return Math.round(x).toString(8);
    },
    "p": function(x, p) {
        return _formatRoundedJsDefault.default(x * 100, p);
    },
    "r": _formatRoundedJsDefault.default,
    "s": _formatPrefixAutoJsDefault.default,
    "X": function(x) {
        return Math.round(x).toString(16).toUpperCase();
    },
    "x": function(x) {
        return Math.round(x).toString(16);
    }
};

},{"./formatDecimal.js":"eFLdP","./formatPrefixAuto.js":"4a8Al","./formatRounded.js":"lzDqS","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4a8Al":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prefixExponent", ()=>prefixExponent
);
var _formatDecimalJs = require("./formatDecimal.js");
var prefixExponent;
exports.default = function(x, p) {
    var d = _formatDecimalJs.formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + _formatDecimalJs.formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
};

},{"./formatDecimal.js":"eFLdP","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lzDqS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _formatDecimalJs = require("./formatDecimal.js");
exports.default = function(x, p) {
    var d = _formatDecimalJs.formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
};

},{"./formatDecimal.js":"eFLdP","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dcSc8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return x;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e3JIq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exponentJs = require("./exponent.js");
var _exponentJsDefault = parcelHelpers.interopDefault(_exponentJs);
exports.default = function(step) {
    return Math.max(0, -_exponentJsDefault.default(Math.abs(step)));
};

},{"./exponent.js":"6DGHE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7GxX5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exponentJs = require("./exponent.js");
var _exponentJsDefault = parcelHelpers.interopDefault(_exponentJs);
exports.default = function(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(_exponentJsDefault.default(value) / 3))) * 3 - _exponentJsDefault.default(Math.abs(step)));
};

},{"./exponent.js":"6DGHE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1ZF1R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exponentJs = require("./exponent.js");
var _exponentJsDefault = parcelHelpers.interopDefault(_exponentJs);
exports.default = function(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, _exponentJsDefault.default(max) - _exponentJsDefault.default(step)) + 1;
};

},{"./exponent.js":"6DGHE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"euFVP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "geoArea", ()=>_areaJsDefault.default
);
parcelHelpers.export(exports, "geoBounds", ()=>_boundsJsDefault.default
);
parcelHelpers.export(exports, "geoCentroid", ()=>_centroidJsDefault.default
);
parcelHelpers.export(exports, "geoCircle", ()=>_circleJsDefault.default
);
parcelHelpers.export(exports, "geoClipAntimeridian", ()=>_antimeridianJsDefault.default
);
parcelHelpers.export(exports, "geoClipCircle", ()=>_circleJsDefault1.default
);
parcelHelpers.export(exports, "geoClipExtent", ()=>_extentJsDefault.default
) // DEPRECATED! Use d3.geoIdentity().clipExtent(…).
;
parcelHelpers.export(exports, "geoClipRectangle", ()=>_rectangleJsDefault.default
);
parcelHelpers.export(exports, "geoContains", ()=>_containsJsDefault.default
);
parcelHelpers.export(exports, "geoDistance", ()=>_distanceJsDefault.default
);
parcelHelpers.export(exports, "geoGraticule", ()=>_graticuleJsDefault.default
);
parcelHelpers.export(exports, "geoGraticule10", ()=>_graticuleJs.graticule10
);
parcelHelpers.export(exports, "geoInterpolate", ()=>_interpolateJsDefault.default
);
parcelHelpers.export(exports, "geoLength", ()=>_lengthJsDefault.default
);
parcelHelpers.export(exports, "geoPath", ()=>_indexJsDefault.default
);
parcelHelpers.export(exports, "geoAlbers", ()=>_albersJsDefault.default
);
parcelHelpers.export(exports, "geoAlbersUsa", ()=>_albersUsaJsDefault.default
);
parcelHelpers.export(exports, "geoAzimuthalEqualArea", ()=>_azimuthalEqualAreaJsDefault.default
);
parcelHelpers.export(exports, "geoAzimuthalEqualAreaRaw", ()=>_azimuthalEqualAreaJs.azimuthalEqualAreaRaw
);
parcelHelpers.export(exports, "geoAzimuthalEquidistant", ()=>_azimuthalEquidistantJsDefault.default
);
parcelHelpers.export(exports, "geoAzimuthalEquidistantRaw", ()=>_azimuthalEquidistantJs.azimuthalEquidistantRaw
);
parcelHelpers.export(exports, "geoConicConformal", ()=>_conicConformalJsDefault.default
);
parcelHelpers.export(exports, "geoConicConformalRaw", ()=>_conicConformalJs.conicConformalRaw
);
parcelHelpers.export(exports, "geoConicEqualArea", ()=>_conicEqualAreaJsDefault.default
);
parcelHelpers.export(exports, "geoConicEqualAreaRaw", ()=>_conicEqualAreaJs.conicEqualAreaRaw
);
parcelHelpers.export(exports, "geoConicEquidistant", ()=>_conicEquidistantJsDefault.default
);
parcelHelpers.export(exports, "geoConicEquidistantRaw", ()=>_conicEquidistantJs.conicEquidistantRaw
);
parcelHelpers.export(exports, "geoEqualEarth", ()=>_equalEarthJsDefault.default
);
parcelHelpers.export(exports, "geoEqualEarthRaw", ()=>_equalEarthJs.equalEarthRaw
);
parcelHelpers.export(exports, "geoEquirectangular", ()=>_equirectangularJsDefault.default
);
parcelHelpers.export(exports, "geoEquirectangularRaw", ()=>_equirectangularJs.equirectangularRaw
);
parcelHelpers.export(exports, "geoGnomonic", ()=>_gnomonicJsDefault.default
);
parcelHelpers.export(exports, "geoGnomonicRaw", ()=>_gnomonicJs.gnomonicRaw
);
parcelHelpers.export(exports, "geoIdentity", ()=>_identityJsDefault.default
);
parcelHelpers.export(exports, "geoProjection", ()=>_indexJsDefault1.default
);
parcelHelpers.export(exports, "geoProjectionMutator", ()=>_indexJs1.projectionMutator
);
parcelHelpers.export(exports, "geoMercator", ()=>_mercatorJsDefault.default
);
parcelHelpers.export(exports, "geoMercatorRaw", ()=>_mercatorJs.mercatorRaw
);
parcelHelpers.export(exports, "geoNaturalEarth1", ()=>_naturalEarth1JsDefault.default
);
parcelHelpers.export(exports, "geoNaturalEarth1Raw", ()=>_naturalEarth1Js.naturalEarth1Raw
);
parcelHelpers.export(exports, "geoOrthographic", ()=>_orthographicJsDefault.default
);
parcelHelpers.export(exports, "geoOrthographicRaw", ()=>_orthographicJs.orthographicRaw
);
parcelHelpers.export(exports, "geoStereographic", ()=>_stereographicJsDefault.default
);
parcelHelpers.export(exports, "geoStereographicRaw", ()=>_stereographicJs.stereographicRaw
);
parcelHelpers.export(exports, "geoTransverseMercator", ()=>_transverseMercatorJsDefault.default
);
parcelHelpers.export(exports, "geoTransverseMercatorRaw", ()=>_transverseMercatorJs.transverseMercatorRaw
);
parcelHelpers.export(exports, "geoRotation", ()=>_rotationJsDefault.default
);
parcelHelpers.export(exports, "geoStream", ()=>_streamJsDefault.default
);
parcelHelpers.export(exports, "geoTransform", ()=>_transformJsDefault.default
);
var _areaJs = require("./area.js");
var _areaJsDefault = parcelHelpers.interopDefault(_areaJs);
var _boundsJs = require("./bounds.js");
var _boundsJsDefault = parcelHelpers.interopDefault(_boundsJs);
var _centroidJs = require("./centroid.js");
var _centroidJsDefault = parcelHelpers.interopDefault(_centroidJs);
var _circleJs = require("./circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _antimeridianJs = require("./clip/antimeridian.js");
var _antimeridianJsDefault = parcelHelpers.interopDefault(_antimeridianJs);
var _circleJs1 = require("./clip/circle.js");
var _circleJsDefault1 = parcelHelpers.interopDefault(_circleJs1);
var _extentJs = require("./clip/extent.js");
var _extentJsDefault = parcelHelpers.interopDefault(_extentJs);
var _rectangleJs = require("./clip/rectangle.js");
var _rectangleJsDefault = parcelHelpers.interopDefault(_rectangleJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _distanceJs = require("./distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
var _graticuleJs = require("./graticule.js");
var _graticuleJsDefault = parcelHelpers.interopDefault(_graticuleJs);
var _interpolateJs = require("./interpolate.js");
var _interpolateJsDefault = parcelHelpers.interopDefault(_interpolateJs);
var _lengthJs = require("./length.js");
var _lengthJsDefault = parcelHelpers.interopDefault(_lengthJs);
var _indexJs = require("./path/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _albersJs = require("./projection/albers.js");
var _albersJsDefault = parcelHelpers.interopDefault(_albersJs);
var _albersUsaJs = require("./projection/albersUsa.js");
var _albersUsaJsDefault = parcelHelpers.interopDefault(_albersUsaJs);
var _azimuthalEqualAreaJs = require("./projection/azimuthalEqualArea.js");
var _azimuthalEqualAreaJsDefault = parcelHelpers.interopDefault(_azimuthalEqualAreaJs);
var _azimuthalEquidistantJs = require("./projection/azimuthalEquidistant.js");
var _azimuthalEquidistantJsDefault = parcelHelpers.interopDefault(_azimuthalEquidistantJs);
var _conicConformalJs = require("./projection/conicConformal.js");
var _conicConformalJsDefault = parcelHelpers.interopDefault(_conicConformalJs);
var _conicEqualAreaJs = require("./projection/conicEqualArea.js");
var _conicEqualAreaJsDefault = parcelHelpers.interopDefault(_conicEqualAreaJs);
var _conicEquidistantJs = require("./projection/conicEquidistant.js");
var _conicEquidistantJsDefault = parcelHelpers.interopDefault(_conicEquidistantJs);
var _equalEarthJs = require("./projection/equalEarth.js");
var _equalEarthJsDefault = parcelHelpers.interopDefault(_equalEarthJs);
var _equirectangularJs = require("./projection/equirectangular.js");
var _equirectangularJsDefault = parcelHelpers.interopDefault(_equirectangularJs);
var _gnomonicJs = require("./projection/gnomonic.js");
var _gnomonicJsDefault = parcelHelpers.interopDefault(_gnomonicJs);
var _identityJs = require("./projection/identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _indexJs1 = require("./projection/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _mercatorJs = require("./projection/mercator.js");
var _mercatorJsDefault = parcelHelpers.interopDefault(_mercatorJs);
var _naturalEarth1Js = require("./projection/naturalEarth1.js");
var _naturalEarth1JsDefault = parcelHelpers.interopDefault(_naturalEarth1Js);
var _orthographicJs = require("./projection/orthographic.js");
var _orthographicJsDefault = parcelHelpers.interopDefault(_orthographicJs);
var _stereographicJs = require("./projection/stereographic.js");
var _stereographicJsDefault = parcelHelpers.interopDefault(_stereographicJs);
var _transverseMercatorJs = require("./projection/transverseMercator.js");
var _transverseMercatorJsDefault = parcelHelpers.interopDefault(_transverseMercatorJs);
var _rotationJs = require("./rotation.js");
var _rotationJsDefault = parcelHelpers.interopDefault(_rotationJs);
var _streamJs = require("./stream.js");
var _streamJsDefault = parcelHelpers.interopDefault(_streamJs);
var _transformJs = require("./transform.js");
var _transformJsDefault = parcelHelpers.interopDefault(_transformJs);

},{"./area.js":"cBTzh","./bounds.js":"8IvkG","./centroid.js":"hDVEJ","./circle.js":"5kSQi","./clip/antimeridian.js":"5t4iH","./clip/circle.js":"iIbFI","./clip/extent.js":"g626F","./clip/rectangle.js":"2xswT","./contains.js":"eYBc9","./distance.js":"glEIa","./graticule.js":"71CK6","./interpolate.js":"9aGW3","./length.js":"9Miu7","./path/index.js":"k9P5v","./projection/albers.js":"3Xlta","./projection/albersUsa.js":"YtNMK","./projection/azimuthalEqualArea.js":"7HnSn","./projection/azimuthalEquidistant.js":"ggmAs","./projection/conicConformal.js":"qkL9e","./projection/conicEqualArea.js":"c9BXq","./projection/conicEquidistant.js":"i4E3R","./projection/equalEarth.js":"2iIrI","./projection/equirectangular.js":"6r5uk","./projection/gnomonic.js":"gz9Xc","./projection/identity.js":"ipPmW","./projection/index.js":"i24sF","./projection/mercator.js":"fE71g","./projection/naturalEarth1.js":"gQDpu","./projection/orthographic.js":"3Wbli","./projection/stereographic.js":"hIzPd","./projection/transverseMercator.js":"4SRkZ","./rotation.js":"54Lv8","./stream.js":"jck2Y","./transform.js":"feffG","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cBTzh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "areaRingSum", ()=>areaRingSum
);
parcelHelpers.export(exports, "areaStream", ()=>areaStream
);
var _adderJs = require("./adder.js");
var _adderJsDefault = parcelHelpers.interopDefault(_adderJs);
var _mathJs = require("./math.js");
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _streamJs = require("./stream.js");
var _streamJsDefault = parcelHelpers.interopDefault(_streamJs);
var areaRingSum = _adderJsDefault.default();
var areaSum = _adderJsDefault.default(), lambda00, phi00, lambda0, cosPhi0, sinPhi0;
var areaStream = {
    point: _noopJsDefault.default,
    lineStart: _noopJsDefault.default,
    lineEnd: _noopJsDefault.default,
    polygonStart: function() {
        areaRingSum.reset();
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
        var areaRing = +areaRingSum;
        areaSum.add(areaRing < 0 ? _mathJs.tau + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = _noopJsDefault.default;
    },
    sphere: function() {
        areaSum.add(_mathJs.tau);
    }
};
function areaRingStart() {
    areaStream.point = areaPointFirst;
}
function areaRingEnd() {
    areaPoint(lambda00, phi00);
}
function areaPointFirst(lambda, phi) {
    areaStream.point = areaPoint;
    lambda00 = lambda, phi00 = phi;
    lambda *= _mathJs.radians, phi *= _mathJs.radians;
    lambda0 = lambda, cosPhi0 = _mathJs.cos(phi = phi / 2 + _mathJs.quarterPi), sinPhi0 = _mathJs.sin(phi);
}
function areaPoint(lambda, phi) {
    lambda *= _mathJs.radians, phi *= _mathJs.radians;
    phi = phi / 2 + _mathJs.quarterPi; // half the angular distance from south pole
    // Spherical excess E for a spherical triangle with vertices: south pole,
    // previous point, current point.  Uses a formula derived from Cagnoli’s
    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
    var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = _mathJs.cos(phi), sinPhi = _mathJs.sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * _mathJs.cos(adLambda), v = k * sdLambda * _mathJs.sin(adLambda);
    areaRingSum.add(_mathJs.atan2(v, u));
    // Advance the previous points.
    lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}
exports.default = function(object) {
    areaSum.reset();
    _streamJsDefault.default(object, areaStream);
    return areaSum * 2;
};

},{"./adder.js":"67wVm","./math.js":"7JyYl","./noop.js":"a5Top","./stream.js":"jck2Y","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"67wVm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    return new Adder;
};
function Adder() {
    this.reset();
}
Adder.prototype = {
    constructor: Adder,
    reset: function() {
        this.s = this.t = 0; // exact error
    },
    add: function(y) {
        add(temp, y, this.t);
        add(this, temp.s, this.s);
        if (this.s) this.t += temp.t;
        else this.s = temp.t;
    },
    valueOf: function() {
        return this.s;
    }
};
var temp = new Adder;
function add(adder, a, b) {
    var x = adder.s = a + b, bv = x - a, av = x - bv;
    adder.t = a - av + (b - bv);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7JyYl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "epsilon", ()=>epsilon
);
parcelHelpers.export(exports, "epsilon2", ()=>epsilon2
);
parcelHelpers.export(exports, "pi", ()=>pi
);
parcelHelpers.export(exports, "halfPi", ()=>halfPi
);
parcelHelpers.export(exports, "quarterPi", ()=>quarterPi
);
parcelHelpers.export(exports, "tau", ()=>tau
);
parcelHelpers.export(exports, "degrees", ()=>degrees
);
parcelHelpers.export(exports, "radians", ()=>radians
);
parcelHelpers.export(exports, "abs", ()=>abs
);
parcelHelpers.export(exports, "atan", ()=>atan
);
parcelHelpers.export(exports, "atan2", ()=>atan2
);
parcelHelpers.export(exports, "cos", ()=>cos
);
parcelHelpers.export(exports, "ceil", ()=>ceil
);
parcelHelpers.export(exports, "exp", ()=>exp
);
parcelHelpers.export(exports, "floor", ()=>floor
);
parcelHelpers.export(exports, "log", ()=>log
);
parcelHelpers.export(exports, "pow", ()=>pow
);
parcelHelpers.export(exports, "sin", ()=>sin
);
parcelHelpers.export(exports, "sign", ()=>sign
);
parcelHelpers.export(exports, "sqrt", ()=>sqrt
);
parcelHelpers.export(exports, "tan", ()=>tan
);
parcelHelpers.export(exports, "acos", ()=>acos
);
parcelHelpers.export(exports, "asin", ()=>asin
);
parcelHelpers.export(exports, "haversin", ()=>haversin
);
var epsilon = 0.000001;
var epsilon2 = 0.000000000001;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
    return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function haversin(x) {
    return (x = sin(x / 2)) * x;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"a5Top":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function noop() {
}
exports.default = noop;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jck2Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) streamGeometryType[geometry.type](geometry, stream);
}
var streamObjectType = {
    Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while(++i < n)streamGeometry(features[i].geometry, stream);
    }
};
var streamGeometryType = {
    Sphere: function(object, stream) {
        stream.sphere();
    },
    Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while(++i < n)object = coordinates[i], stream.point(object[0], object[1], object[2]);
    },
    LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while(++i < n)streamLine(coordinates[i], stream, 0);
    },
    Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while(++i < n)streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while(++i < n)streamGeometry(geometries[i], stream);
    }
};
function streamLine(coordinates, stream, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    stream.lineStart();
    while(++i < n)coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
    var i = -1, n = coordinates.length;
    stream.polygonStart();
    while(++i < n)streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
}
exports.default = function(object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) streamObjectType[object.type](object, stream);
    else streamGeometry(object, stream);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8IvkG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adderJs = require("./adder.js");
var _adderJsDefault = parcelHelpers.interopDefault(_adderJs);
var _areaJs = require("./area.js");
var _cartesianJs = require("./cartesian.js");
var _mathJs = require("./math.js");
var _streamJs = require("./stream.js");
var _streamJsDefault = parcelHelpers.interopDefault(_streamJs);
var lambda01, phi0, lambda11, phi1, lambda2, lambda00, phi00, p0, deltaSum = _adderJsDefault.default(), ranges, range1;
var boundsStream = {
    point: boundsPoint,
    lineStart: boundsLineStart,
    lineEnd: boundsLineEnd,
    polygonStart: function() {
        boundsStream.point = boundsRingPoint;
        boundsStream.lineStart = boundsRingStart;
        boundsStream.lineEnd = boundsRingEnd;
        deltaSum.reset();
        _areaJs.areaStream.polygonStart();
    },
    polygonEnd: function() {
        _areaJs.areaStream.polygonEnd();
        boundsStream.point = boundsPoint;
        boundsStream.lineStart = boundsLineStart;
        boundsStream.lineEnd = boundsLineEnd;
        if (_areaJs.areaRingSum < 0) lambda01 = -(lambda11 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > _mathJs.epsilon) phi1 = 90;
        else if (deltaSum < -_mathJs.epsilon) phi0 = -90;
        range1[0] = lambda01, range1[1] = lambda11;
    },
    sphere: function() {
        lambda01 = -(lambda11 = 180), phi0 = -(phi1 = 90);
    }
};
function boundsPoint(lambda, phi) {
    ranges.push(range1 = [
        lambda01 = lambda,
        lambda11 = lambda
    ]);
    if (phi < phi0) phi0 = phi;
    if (phi > phi1) phi1 = phi;
}
function linePoint(lambda, phi) {
    var p = _cartesianJs.cartesian([
        lambda * _mathJs.radians,
        phi * _mathJs.radians
    ]);
    if (p0) {
        var normal = _cartesianJs.cartesianCross(p0, p), equatorial = [
            normal[1],
            -normal[0],
            0
        ], inflection = _cartesianJs.cartesianCross(equatorial, normal);
        _cartesianJs.cartesianNormalizeInPlace(inflection);
        inflection = _cartesianJs.spherical(inflection);
        var delta = lambda - lambda2, sign = delta > 0 ? 1 : -1, lambdai = inflection[0] * _mathJs.degrees * sign, phii, antimeridian = _mathJs.abs(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
            phii = inflection[1] * _mathJs.degrees;
            if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
            phii = -inflection[1] * _mathJs.degrees;
            if (phii < phi0) phi0 = phii;
        } else {
            if (phi < phi0) phi0 = phi;
            if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
            if (lambda < lambda2) {
                if (angle(lambda01, lambda) > angle(lambda01, lambda11)) lambda11 = lambda;
            } else if (angle(lambda, lambda11) > angle(lambda01, lambda11)) lambda01 = lambda;
        } else if (lambda11 >= lambda01) {
            if (lambda < lambda01) lambda01 = lambda;
            if (lambda > lambda11) lambda11 = lambda;
        } else {
            if (lambda > lambda2) {
                if (angle(lambda01, lambda) > angle(lambda01, lambda11)) lambda11 = lambda;
            } else if (angle(lambda, lambda11) > angle(lambda01, lambda11)) lambda01 = lambda;
        }
    } else ranges.push(range1 = [
        lambda01 = lambda,
        lambda11 = lambda
    ]);
    if (phi < phi0) phi0 = phi;
    if (phi > phi1) phi1 = phi;
    p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
    boundsStream.point = linePoint;
}
function boundsLineEnd() {
    range1[0] = lambda01, range1[1] = lambda11;
    boundsStream.point = boundsPoint;
    p0 = null;
}
function boundsRingPoint(lambda, phi) {
    if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(_mathJs.abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
    } else lambda00 = lambda, phi00 = phi;
    _areaJs.areaStream.point(lambda, phi);
    linePoint(lambda, phi);
}
function boundsRingStart() {
    _areaJs.areaStream.lineStart();
}
function boundsRingEnd() {
    boundsRingPoint(lambda00, phi00);
    _areaJs.areaStream.lineEnd();
    if (_mathJs.abs(deltaSum) > _mathJs.epsilon) lambda01 = -(lambda11 = 180);
    range1[0] = lambda01, range1[1] = lambda11;
    p0 = null;
}
// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function angle(lambda0, lambda1) {
    return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}
function rangeCompare(a, b) {
    return a[0] - b[0];
}
function rangeContains(range, x) {
    return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}
exports.default = function(feature) {
    var i, n, a, b, merged, deltaMax, delta;
    phi1 = lambda11 = -(lambda01 = phi0 = Infinity);
    ranges = [];
    _streamJsDefault.default(feature, boundsStream);
    // First, sort ranges by their minimum longitudes.
    if (n = ranges.length) {
        ranges.sort(rangeCompare);
        // Then, merge any ranges that overlap.
        for(i = 1, a = ranges[0], merged = [
            a
        ]; i < n; ++i){
            b = ranges[i];
            if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
                if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
            } else merged.push(a = b);
        }
        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for(deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i){
            b = merged[i];
            if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda01 = b[0], lambda11 = a[1];
        }
    }
    ranges = range1 = null;
    return lambda01 === Infinity || phi0 === Infinity ? [
        [
            NaN,
            NaN
        ],
        [
            NaN,
            NaN
        ]
    ] : [
        [
            lambda01,
            phi0
        ],
        [
            lambda11,
            phi1
        ]
    ];
};

},{"./adder.js":"67wVm","./area.js":"cBTzh","./cartesian.js":"evaJG","./math.js":"7JyYl","./stream.js":"jck2Y","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"evaJG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "spherical", ()=>spherical1
);
parcelHelpers.export(exports, "cartesian", ()=>cartesian1
);
parcelHelpers.export(exports, "cartesianDot", ()=>cartesianDot
);
parcelHelpers.export(exports, "cartesianCross", ()=>cartesianCross
);
// TODO return a
parcelHelpers.export(exports, "cartesianAddInPlace", ()=>cartesianAddInPlace
);
parcelHelpers.export(exports, "cartesianScale", ()=>cartesianScale
);
// TODO return d
parcelHelpers.export(exports, "cartesianNormalizeInPlace", ()=>cartesianNormalizeInPlace
);
var _mathJs = require("./math.js");
function spherical1(cartesian) {
    return [
        _mathJs.atan2(cartesian[1], cartesian[0]),
        _mathJs.asin(cartesian[2])
    ];
}
function cartesian1(spherical) {
    var lambda = spherical[0], phi = spherical[1], cosPhi = _mathJs.cos(phi);
    return [
        cosPhi * _mathJs.cos(lambda),
        cosPhi * _mathJs.sin(lambda),
        _mathJs.sin(phi)
    ];
}
function cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
    return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
    ];
}
function cartesianAddInPlace(a, b) {
    a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
    return [
        vector[0] * k,
        vector[1] * k,
        vector[2] * k
    ];
}
function cartesianNormalizeInPlace(d) {
    var l = _mathJs.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
}

},{"./math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hDVEJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mathJs = require("./math.js");
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _streamJs = require("./stream.js");
var _streamJsDefault = parcelHelpers.interopDefault(_streamJs);
var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, x0, y0, z0; // previous point
var centroidStream = {
    sphere: _noopJsDefault.default,
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
    }
};
// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
    lambda *= _mathJs.radians, phi *= _mathJs.radians;
    var cosPhi = _mathJs.cos(phi);
    centroidPointCartesian(cosPhi * _mathJs.cos(lambda), cosPhi * _mathJs.sin(lambda), _mathJs.sin(phi));
}
function centroidPointCartesian(x, y, z) {
    ++W0;
    X0 += (x - X0) / W0;
    Y0 += (y - Y0) / W0;
    Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
    centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi) {
    lambda *= _mathJs.radians, phi *= _mathJs.radians;
    var cosPhi = _mathJs.cos(phi);
    x0 = cosPhi * _mathJs.cos(lambda);
    y0 = cosPhi * _mathJs.sin(lambda);
    z0 = _mathJs.sin(phi);
    centroidStream.point = centroidLinePoint;
    centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi) {
    lambda *= _mathJs.radians, phi *= _mathJs.radians;
    var cosPhi = _mathJs.cos(phi), x = cosPhi * _mathJs.cos(lambda), y = cosPhi * _mathJs.sin(lambda), z = _mathJs.sin(phi), w = _mathJs.atan2(_mathJs.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
    W1 += w;
    X1 += w * (x0 + (x0 = x));
    Y1 += w * (y0 + (y0 = y));
    Z1 += w * (z0 + (z0 = z));
    centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
    centroidStream.point = centroidPoint;
}
// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
    centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
    centroidRingPoint(lambda00, phi00);
    centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi) {
    lambda00 = lambda, phi00 = phi;
    lambda *= _mathJs.radians, phi *= _mathJs.radians;
    centroidStream.point = centroidRingPoint;
    var cosPhi = _mathJs.cos(phi);
    x0 = cosPhi * _mathJs.cos(lambda);
    y0 = cosPhi * _mathJs.sin(lambda);
    z0 = _mathJs.sin(phi);
    centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi) {
    lambda *= _mathJs.radians, phi *= _mathJs.radians;
    var cosPhi = _mathJs.cos(phi), x = cosPhi * _mathJs.cos(lambda), y = cosPhi * _mathJs.sin(lambda), z = _mathJs.sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = _mathJs.sqrt(cx * cx + cy * cy + cz * cz), w = _mathJs.asin(m), v = m && -w / m; // area weight multiplier
    X2 += v * cx;
    Y2 += v * cy;
    Z2 += v * cz;
    W1 += w;
    X1 += w * (x0 + (x0 = x));
    Y1 += w * (y0 + (y0 = y));
    Z1 += w * (z0 + (z0 = z));
    centroidPointCartesian(x0, y0, z0);
}
exports.default = function(object) {
    W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    _streamJsDefault.default(object, centroidStream);
    var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;
    // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
    if (m < _mathJs.epsilon2) {
        x = X1, y = Y1, z = Z1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < _mathJs.epsilon) x = X0, y = Y0, z = Z0;
        m = x * x + y * y + z * z;
        // If the feature still has an undefined ccentroid, then return.
        if (m < _mathJs.epsilon2) return [
            NaN,
            NaN
        ];
    }
    return [
        _mathJs.atan2(y, x) * _mathJs.degrees,
        _mathJs.asin(z / _mathJs.sqrt(m)) * _mathJs.degrees
    ];
};

},{"./math.js":"7JyYl","./noop.js":"a5Top","./stream.js":"jck2Y","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5kSQi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Generates a circle centered at [0°, 0°], with a given radius and precision.
parcelHelpers.export(exports, "circleStream", ()=>circleStream
);
var _cartesianJs = require("./cartesian.js");
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _mathJs = require("./math.js");
var _rotationJs = require("./rotation.js");
function circleStream(stream, radius, delta, direction, t0, t1) {
    if (!delta) return;
    var cosRadius = _mathJs.cos(radius), sinRadius = _mathJs.sin(radius), step = direction * delta;
    if (t0 == null) {
        t0 = radius + direction * _mathJs.tau;
        t1 = radius - step / 2;
    } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _mathJs.tau;
    }
    for(var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step){
        point = _cartesianJs.spherical([
            cosRadius,
            -sinRadius * _mathJs.cos(t),
            -sinRadius * _mathJs.sin(t)
        ]);
        stream.point(point[0], point[1]);
    }
}
// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
    point = _cartesianJs.cartesian(point), point[0] -= cosRadius;
    _cartesianJs.cartesianNormalizeInPlace(point);
    var radius = _mathJs.acos(-point[1]);
    return ((-point[2] < 0 ? -radius : radius) + _mathJs.tau - _mathJs.epsilon) % _mathJs.tau;
}
exports.default = function() {
    var center = _constantJsDefault.default([
        0,
        0
    ]), radius = _constantJsDefault.default(90), precision = _constantJsDefault.default(6), ring, rotate, stream = {
        point: point
    };
    function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= _mathJs.degrees, x[1] *= _mathJs.degrees;
    }
    function circle() {
        var c = center.apply(this, arguments), r = radius.apply(this, arguments) * _mathJs.radians, p = precision.apply(this, arguments) * _mathJs.radians;
        ring = [];
        rotate = _rotationJs.rotateRadians(-c[0] * _mathJs.radians, -c[1] * _mathJs.radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = {
            type: "Polygon",
            coordinates: [
                ring
            ]
        };
        ring = rotate = null;
        return c;
    }
    circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : _constantJsDefault.default([
            +_[0],
            +_[1]
        ]), circle) : center;
    };
    circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : _constantJsDefault.default(+_), circle) : radius;
    };
    circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : _constantJsDefault.default(+_), circle) : precision;
    };
    return circle;
};

},{"./cartesian.js":"evaJG","./constant.js":"1mMcT","./math.js":"7JyYl","./rotation.js":"54Lv8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1mMcT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"54Lv8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateRadians", ()=>rotateRadians
);
var _composeJs = require("./compose.js");
var _composeJsDefault = parcelHelpers.interopDefault(_composeJs);
var _mathJs = require("./math.js");
function rotationIdentity(lambda, phi) {
    return [
        _mathJs.abs(lambda) > _mathJs.pi ? lambda + Math.round(-lambda / _mathJs.tau) * _mathJs.tau : lambda,
        phi
    ];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= _mathJs.tau) ? deltaPhi || deltaGamma ? _composeJsDefault.default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi) {
        return lambda += deltaLambda, [
            lambda > _mathJs.pi ? lambda - _mathJs.tau : lambda < -_mathJs.pi ? lambda + _mathJs.tau : lambda,
            phi
        ];
    };
}
function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = _mathJs.cos(deltaPhi), sinDeltaPhi = _mathJs.sin(deltaPhi), cosDeltaGamma = _mathJs.cos(deltaGamma), sinDeltaGamma = _mathJs.sin(deltaGamma);
    function rotation(lambda, phi) {
        var cosPhi = _mathJs.cos(phi), x = _mathJs.cos(lambda) * cosPhi, y = _mathJs.sin(lambda) * cosPhi, z = _mathJs.sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
            _mathJs.atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
            _mathJs.asin(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
    }
    rotation.invert = function(lambda, phi) {
        var cosPhi = _mathJs.cos(phi), x = _mathJs.cos(lambda) * cosPhi, y = _mathJs.sin(lambda) * cosPhi, z = _mathJs.sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
            _mathJs.atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
            _mathJs.asin(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
    };
    return rotation;
}
exports.default = function(rotate) {
    rotate = rotateRadians(rotate[0] * _mathJs.radians, rotate[1] * _mathJs.radians, rotate.length > 2 ? rotate[2] * _mathJs.radians : 0);
    function forward(coordinates) {
        coordinates = rotate(coordinates[0] * _mathJs.radians, coordinates[1] * _mathJs.radians);
        return coordinates[0] *= _mathJs.degrees, coordinates[1] *= _mathJs.degrees, coordinates;
    }
    forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * _mathJs.radians, coordinates[1] * _mathJs.radians);
        return coordinates[0] *= _mathJs.degrees, coordinates[1] *= _mathJs.degrees, coordinates;
    };
    return forward;
};

},{"./compose.js":"hx08x","./math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hx08x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b) {
    function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5t4iH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _mathJs = require("../math.js");
exports.default = _indexJsDefault.default(function() {
    return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [
    -_mathJs.pi,
    -_mathJs.halfPi
]);
// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
    var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean; // no intersections
    return {
        lineStart: function() {
            stream.lineStart();
            clean = 1;
        },
        point: function(lambda1, phi1) {
            var sign1 = lambda1 > 0 ? _mathJs.pi : -_mathJs.pi, delta = _mathJs.abs(lambda1 - lambda0);
            if (_mathJs.abs(delta - _mathJs.pi) < _mathJs.epsilon) {
                stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _mathJs.halfPi : -_mathJs.halfPi);
                stream.point(sign0, phi0);
                stream.lineEnd();
                stream.lineStart();
                stream.point(sign1, phi0);
                stream.point(lambda1, phi0);
                clean = 0;
            } else if (sign0 !== sign1 && delta >= _mathJs.pi) {
                if (_mathJs.abs(lambda0 - sign0) < _mathJs.epsilon) lambda0 -= sign0 * _mathJs.epsilon; // handle degeneracies
                if (_mathJs.abs(lambda1 - sign1) < _mathJs.epsilon) lambda1 -= sign1 * _mathJs.epsilon;
                phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
                stream.point(sign0, phi0);
                stream.lineEnd();
                stream.lineStart();
                stream.point(sign1, phi0);
                clean = 0;
            }
            stream.point(lambda0 = lambda1, phi0 = phi1);
            sign0 = sign1;
        },
        lineEnd: function() {
            stream.lineEnd();
            lambda0 = phi0 = NaN;
        },
        clean: function() {
            return 2 - clean; // if intersections, rejoin first and last segments
        }
    };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0, cosPhi1, sinLambda0Lambda1 = _mathJs.sin(lambda0 - lambda1);
    return _mathJs.abs(sinLambda0Lambda1) > _mathJs.epsilon ? _mathJs.atan((_mathJs.sin(phi0) * (cosPhi1 = _mathJs.cos(phi1)) * _mathJs.sin(lambda1) - _mathJs.sin(phi1) * (cosPhi0 = _mathJs.cos(phi0)) * _mathJs.sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
        phi = direction * _mathJs.halfPi;
        stream.point(-_mathJs.pi, phi);
        stream.point(0, phi);
        stream.point(_mathJs.pi, phi);
        stream.point(_mathJs.pi, 0);
        stream.point(_mathJs.pi, -phi);
        stream.point(0, -phi);
        stream.point(-_mathJs.pi, -phi);
        stream.point(-_mathJs.pi, 0);
        stream.point(-_mathJs.pi, phi);
    } else if (_mathJs.abs(from[0] - to[0]) > _mathJs.epsilon) {
        var lambda = from[0] < to[0] ? _mathJs.pi : -_mathJs.pi;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
    } else stream.point(to[0], to[1]);
}

},{"./index.js":"fwcyD","../math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fwcyD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bufferJs = require("./buffer.js");
var _bufferJsDefault = parcelHelpers.interopDefault(_bufferJs);
var _rejoinJs = require("./rejoin.js");
var _rejoinJsDefault = parcelHelpers.interopDefault(_rejoinJs);
var _mathJs = require("../math.js");
var _polygonContainsJs = require("../polygonContains.js");
var _polygonContainsJsDefault = parcelHelpers.interopDefault(_polygonContainsJs);
var _d3Array = require("d3-array");
exports.default = function(pointVisible, clipLine, interpolate, start) {
    return function(sink) {
        var line = clipLine(sink), ringBuffer = _bufferJsDefault.default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
        var clip = {
            point: point1,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
                clip.point = pointRing;
                clip.lineStart = ringStart;
                clip.lineEnd = ringEnd;
                segments = [];
                polygon = [];
            },
            polygonEnd: function() {
                clip.point = point1;
                clip.lineStart = lineStart;
                clip.lineEnd = lineEnd;
                segments = _d3Array.merge(segments);
                var startInside = _polygonContainsJsDefault.default(polygon, start);
                if (segments.length) {
                    if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                    _rejoinJsDefault.default(segments, compareIntersection, startInside, interpolate, sink);
                } else if (startInside) {
                    if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                    sink.lineStart();
                    interpolate(null, null, 1, sink);
                    sink.lineEnd();
                }
                if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
                segments = polygon = null;
            },
            sphere: function() {
                sink.polygonStart();
                sink.lineStart();
                interpolate(null, null, 1, sink);
                sink.lineEnd();
                sink.polygonEnd();
            }
        };
        function point1(lambda, phi) {
            if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }
        function pointLine(lambda, phi) {
            line.point(lambda, phi);
        }
        function lineStart() {
            clip.point = pointLine;
            line.lineStart();
        }
        function lineEnd() {
            clip.point = point1;
            line.lineEnd();
        }
        function pointRing(lambda, phi) {
            ring.push([
                lambda,
                phi
            ]);
            ringSink.point(lambda, phi);
        }
        function ringStart() {
            ringSink.lineStart();
            ring = [];
        }
        function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringSink.lineEnd();
            var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n) return;
            // No intersections.
            if (clean & 1) {
                segment = ringSegments[0];
                if ((m = segment.length - 1) > 0) {
                    if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                    sink.lineStart();
                    for(i = 0; i < m; ++i)sink.point((point = segment[i])[0], point[1]);
                    sink.lineEnd();
                }
                return;
            }
            // Rejoin connected segments.
            // TODO reuse ringBuffer.rejoin()?
            if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(validSegment));
        }
        return clip;
    };
};
function validSegment(segment) {
    return segment.length > 1;
}
// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - _mathJs.halfPi - _mathJs.epsilon : _mathJs.halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _mathJs.halfPi - _mathJs.epsilon : _mathJs.halfPi - b[1]);
}

},{"./buffer.js":"1YOxa","./rejoin.js":"a6HiF","../math.js":"7JyYl","../polygonContains.js":"FktDW","d3-array":"dclxS","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1YOxa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
exports.default = function() {
    var lines = [], line;
    return {
        point: function(x, y, m) {
            line.push([
                x,
                y,
                m
            ]);
        },
        lineStart: function() {
            lines.push(line = []);
        },
        lineEnd: _noopJsDefault.default,
        rejoin: function() {
            if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
            var result = lines;
            lines = [];
            line = null;
            return result;
        }
    };
};

},{"../noop.js":"a5Top","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"a6HiF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointEqualJs = require("../pointEqual.js");
var _pointEqualJsDefault = parcelHelpers.interopDefault(_pointEqualJs);
var _mathJs = require("../math.js");
function Intersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other; // another intersection
    this.e = entry; // is an entry?
    this.v = false; // visited
    this.n = this.p = null; // next & previous
}
exports.default = function(segments, compareIntersection, startInside, interpolate, stream) {
    var subject = [], clip = [], i, n1;
    segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;
        if (_pointEqualJsDefault.default(p0, p1)) {
            if (!p0[2] && !p1[2]) {
                stream.lineStart();
                for(i = 0; i < n; ++i)stream.point((p0 = segment[i])[0], p0[1]);
                stream.lineEnd();
                return;
            }
            // handle degenerate cases by moving the point
            p1[0] += 2 * _mathJs.epsilon;
        }
        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
    });
    if (!subject.length) return;
    clip.sort(compareIntersection);
    link(subject);
    link(clip);
    for(i = 0, n1 = clip.length; i < n1; ++i)clip[i].e = startInside = !startInside;
    var start = subject[0], points, point;
    while(true){
        // Find first unvisited intersection.
        var current = start, isSubject = true;
        while(current.v)if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
            current.v = current.o.v = true;
            if (current.e) {
                if (isSubject) for(i = 0, n1 = points.length; i < n1; ++i)stream.point((point = points[i])[0], point[1]);
                else interpolate(current.x, current.n.x, 1, stream);
                current = current.n;
            } else {
                if (isSubject) {
                    points = current.p.z;
                    for(i = points.length - 1; i >= 0; --i)stream.point((point = points[i])[0], point[1]);
                } else interpolate(current.x, current.p.x, -1, stream);
                current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
        }while (!current.v)
        stream.lineEnd();
    }
};
function link(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while(++i < n){
        a.n = b = array[i];
        b.p = a;
        a = b;
    }
    a.n = b = array[0];
    b.p = a;
}

},{"../pointEqual.js":"kT0x8","../math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kT0x8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mathJs = require("./math.js");
exports.default = function(a, b) {
    return _mathJs.abs(a[0] - b[0]) < _mathJs.epsilon && _mathJs.abs(a[1] - b[1]) < _mathJs.epsilon;
};

},{"./math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"FktDW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adderJs = require("./adder.js");
var _adderJsDefault = parcelHelpers.interopDefault(_adderJs);
var _cartesianJs = require("./cartesian.js");
var _mathJs = require("./math.js");
var sum = _adderJsDefault.default();
function longitude(point) {
    if (_mathJs.abs(point[0]) <= _mathJs.pi) return point[0];
    else return _mathJs.sign(point[0]) * ((_mathJs.abs(point[0]) + _mathJs.pi) % _mathJs.tau - _mathJs.pi);
}
exports.default = function(polygon, point) {
    var lambda = longitude(point), phi = point[1], sinPhi = _mathJs.sin(phi), normal = [
        _mathJs.sin(lambda),
        -_mathJs.cos(lambda),
        0
    ], angle = 0, winding = 0;
    sum.reset();
    if (sinPhi === 1) phi = _mathJs.halfPi + _mathJs.epsilon;
    else if (sinPhi === -1) phi = -_mathJs.halfPi - _mathJs.epsilon;
    for(var i = 0, n = polygon.length; i < n; ++i){
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring, m, point0 = ring[m - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + _mathJs.quarterPi, sinPhi0 = _mathJs.sin(phi0), cosPhi0 = _mathJs.cos(phi0);
        for(var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1){
            var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + _mathJs.quarterPi, sinPhi1 = _mathJs.sin(phi1), cosPhi1 = _mathJs.cos(phi1), delta = lambda1 - lambda0, sign = delta >= 0 ? 1 : -1, absDelta = sign * delta, antimeridian = absDelta > _mathJs.pi, k = sinPhi0 * sinPhi1;
            sum.add(_mathJs.atan2(k * sign * _mathJs.sin(absDelta), cosPhi0 * cosPhi1 + k * _mathJs.cos(absDelta)));
            angle += antimeridian ? delta + sign * _mathJs.tau : delta;
            // Are the longitudes either side of the point’s meridian (lambda),
            // and are the latitudes smaller than the parallel (phi)?
            if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
                var arc = _cartesianJs.cartesianCross(_cartesianJs.cartesian(point0), _cartesianJs.cartesian(point1));
                _cartesianJs.cartesianNormalizeInPlace(arc);
                var intersection = _cartesianJs.cartesianCross(normal, arc);
                _cartesianJs.cartesianNormalizeInPlace(intersection);
                var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * _mathJs.asin(intersection[2]);
                if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
        }
    }
    // First, determine whether the South pole is inside or outside:
    //
    // It is inside if:
    // * the polygon winds around it in a clockwise direction.
    // * the polygon does not (cumulatively) wind around it, but has a negative
    //   (counter-clockwise) area.
    //
    // Second, count the (signed) number of times a segment crosses a lambda
    // from the point to the South pole.  If it is zero, then the point is the
    // same side as the South pole.
    return (angle < -_mathJs.epsilon || angle < _mathJs.epsilon && sum < -_mathJs.epsilon) ^ winding & 1;
};

},{"./adder.js":"67wVm","./cartesian.js":"evaJG","./math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iIbFI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cartesianJs = require("../cartesian.js");
var _circleJs = require("../circle.js");
var _mathJs = require("../math.js");
var _pointEqualJs = require("../pointEqual.js");
var _pointEqualJsDefault = parcelHelpers.interopDefault(_pointEqualJs);
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = function(radius) {
    var cr = _mathJs.cos(radius), delta1 = 6 * _mathJs.radians, smallRadius = cr > 0, notHemisphere = _mathJs.abs(cr) > _mathJs.epsilon; // TODO optimise for this common case
    function interpolate(from, to, direction, stream) {
        _circleJs.circleStream(stream, radius, delta1, direction, from, to);
    }
    function visible(lambda, phi) {
        return _mathJs.cos(lambda) * _mathJs.cos(phi) > cr;
    }
    // Takes a line and cuts into visible segments. Return values used for polygon
    // clipping: 0 - there were intersections or the line was empty; 1 - no
    // intersections 2 - there were intersections, and the first and last segments
    // should be rejoined.
    function clipLine(stream) {
        var point0, c0, v0, v00, clean; // no intersections
        return {
            lineStart: function() {
                v00 = v0 = false;
                clean = 1;
            },
            point: function(lambda, phi) {
                var point1 = [
                    lambda,
                    phi
                ], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code1(lambda, phi) : v ? code1(lambda + (lambda < 0 ? _mathJs.pi : -_mathJs.pi), phi) : 0;
                if (!point0 && (v00 = v0 = v)) stream.lineStart();
                if (v !== v0) {
                    point2 = intersect(point0, point1);
                    if (!point2 || _pointEqualJsDefault.default(point0, point2) || _pointEqualJsDefault.default(point1, point2)) point1[2] = 1;
                }
                if (v !== v0) {
                    clean = 0;
                    if (v) {
                        // outside going in
                        stream.lineStart();
                        point2 = intersect(point1, point0);
                        stream.point(point2[0], point2[1]);
                    } else {
                        // inside going out
                        point2 = intersect(point0, point1);
                        stream.point(point2[0], point2[1], 2);
                        stream.lineEnd();
                    }
                    point0 = point2;
                } else if (notHemisphere && point0 && smallRadius ^ v) {
                    var t;
                    // If the codes for two points are different, or are both zero,
                    // and there this segment intersects with the small circle.
                    if (!(c & c0) && (t = intersect(point1, point0, true))) {
                        clean = 0;
                        if (smallRadius) {
                            stream.lineStart();
                            stream.point(t[0][0], t[0][1]);
                            stream.point(t[1][0], t[1][1]);
                            stream.lineEnd();
                        } else {
                            stream.point(t[1][0], t[1][1]);
                            stream.lineEnd();
                            stream.lineStart();
                            stream.point(t[0][0], t[0][1], 3);
                        }
                    }
                }
                if (v && (!point0 || !_pointEqualJsDefault.default(point0, point1))) stream.point(point1[0], point1[1]);
                point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function() {
                if (v0) stream.lineEnd();
                point0 = null;
            },
            // Rejoin first and last segments if there were intersections and the first
            // and last points were visible.
            clean: function() {
                return clean | (v00 && v0) << 1;
            }
        };
    }
    // Intersects the great circle between a and b with the clip circle.
    function intersect(a, b, two) {
        var pa = _cartesianJs.cartesian(a), pb = _cartesianJs.cartesian(b);
        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
        var n1 = [
            1,
            0,
            0
        ], n2 = _cartesianJs.cartesianCross(pa, pb), n2n2 = _cartesianJs.cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
        // Two polar points.
        if (!determinant) return !two && a;
        var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = _cartesianJs.cartesianCross(n1, n2), A = _cartesianJs.cartesianScale(n1, c1), B = _cartesianJs.cartesianScale(n2, c2);
        _cartesianJs.cartesianAddInPlace(A, B);
        // Solve |p(t)|^2 = 1.
        var u = n1xn2, w = _cartesianJs.cartesianDot(A, u), uu = _cartesianJs.cartesianDot(u, u), t2 = w * w - uu * (_cartesianJs.cartesianDot(A, A) - 1);
        if (t2 < 0) return;
        var t = _mathJs.sqrt(t2), q = _cartesianJs.cartesianScale(u, (-w - t) / uu);
        _cartesianJs.cartesianAddInPlace(q, A);
        q = _cartesianJs.spherical(q);
        if (!two) return q;
        // Two intersection points.
        var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;
        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
        var delta = lambda1 - lambda0, polar = _mathJs.abs(delta - _mathJs.pi) < _mathJs.epsilon, meridian = polar || delta < _mathJs.epsilon;
        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
        // Check that the first point is between a and b.
        if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (_mathJs.abs(q[0] - lambda0) < _mathJs.epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _mathJs.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
            var q1 = _cartesianJs.cartesianScale(u, (-w + t) / uu);
            _cartesianJs.cartesianAddInPlace(q1, A);
            return [
                q,
                _cartesianJs.spherical(q1)
            ];
        }
    }
    // Generates a 4-bit vector representing the location of a point relative to
    // the small circle's bounding box.
    function code1(lambda, phi) {
        var r = smallRadius ? radius : _mathJs.pi - radius, code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
    }
    return _indexJsDefault.default(visible, clipLine, interpolate, smallRadius ? [
        0,
        -radius
    ] : [
        -_mathJs.pi,
        radius - _mathJs.pi
    ]);
};

},{"../cartesian.js":"evaJG","../circle.js":"5kSQi","../math.js":"7JyYl","../pointEqual.js":"kT0x8","./index.js":"fwcyD","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g626F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rectangleJs = require("./rectangle.js");
var _rectangleJsDefault = parcelHelpers.interopDefault(_rectangleJs);
exports.default = function() {
    var x0 = 0, y0 = 0, x1 = 960, y1 = 500, cache, cacheStream, clip;
    return clip = {
        stream: function(stream) {
            return cache && cacheStream === stream ? cache : cache = _rectangleJsDefault.default(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
            return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [
                [
                    x0,
                    y0
                ],
                [
                    x1,
                    y1
                ]
            ];
        }
    };
};

},{"./rectangle.js":"2xswT","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2xswT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mathJs = require("../math.js");
var _bufferJs = require("./buffer.js");
var _bufferJsDefault = parcelHelpers.interopDefault(_bufferJs);
var _lineJs = require("./line.js");
var _lineJsDefault = parcelHelpers.interopDefault(_lineJs);
var _rejoinJs = require("./rejoin.js");
var _rejoinJsDefault = parcelHelpers.interopDefault(_rejoinJs);
var _d3Array = require("d3-array");
var clipMax = 1000000000, clipMin = -clipMax;
function clipRectangle(x0, y0, x1, y1) {
    function visible1(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
    }
    function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
        while ((a = (a + direction + 4) % 4) !== a1)
        else stream.point(to[0], to[1]);
    }
    function corner(p, direction) {
        return _mathJs.abs(p[0] - x0) < _mathJs.epsilon ? direction > 0 ? 0 : 3 : _mathJs.abs(p[0] - x1) < _mathJs.epsilon ? direction > 0 ? 2 : 1 : _mathJs.abs(p[1] - y0) < _mathJs.epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
    }
    function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
    }
    function comparePoint(a, b) {
        var ca = corner(a, 1), cb = corner(b, 1);
        return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
    return function(stream) {
        var activeStream = stream, bufferStream = _bufferJsDefault.default(), segments, polygon, ring1, x__, y__, v__, x_, y_, v_, first, clean;
        var clipStream = {
            point: point1,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: polygonStart,
            polygonEnd: polygonEnd
        };
        function point1(x, y) {
            if (visible1(x, y)) activeStream.point(x, y);
        }
        function polygonInside() {
            var winding = 0;
            for(var i = 0, n = polygon.length; i < n; ++i)for(var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j){
                a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
                if (a1 <= y1) {
                    if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
                } else if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
            }
            return winding;
        }
        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
            activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }
        function polygonEnd() {
            var startInside = polygonInside(), cleanInside = clean && startInside, visible = (segments = _d3Array.merge(segments)).length;
            if (cleanInside || visible) {
                stream.polygonStart();
                if (cleanInside) {
                    stream.lineStart();
                    interpolate(null, null, 1, stream);
                    stream.lineEnd();
                }
                if (visible) _rejoinJsDefault.default(segments, compareIntersection, startInside, interpolate, stream);
                stream.polygonEnd();
            }
            activeStream = stream, segments = polygon = ring1 = null;
        }
        function lineStart() {
            clipStream.point = linePoint;
            if (polygon) polygon.push(ring1 = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
        }
        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
            if (segments) {
                linePoint(x__, y__);
                if (v__ && v_) bufferStream.rejoin();
                segments.push(bufferStream.result());
            }
            clipStream.point = point1;
            if (v_) activeStream.lineEnd();
        }
        function linePoint(x, y) {
            var v = visible1(x, y);
            if (polygon) ring1.push([
                x,
                y
            ]);
            if (first) {
                x__ = x, y__ = y, v__ = v;
                first = false;
                if (v) {
                    activeStream.lineStart();
                    activeStream.point(x, y);
                }
            } else if (v && v_) activeStream.point(x, y);
            else {
                var a = [
                    x_ = Math.max(clipMin, Math.min(clipMax, x_)),
                    y_ = Math.max(clipMin, Math.min(clipMax, y_))
                ], b = [
                    x = Math.max(clipMin, Math.min(clipMax, x)),
                    y = Math.max(clipMin, Math.min(clipMax, y))
                ];
                if (_lineJsDefault.default(a, b, x0, y0, x1, y1)) {
                    if (!v_) {
                        activeStream.lineStart();
                        activeStream.point(a[0], a[1]);
                    }
                    activeStream.point(b[0], b[1]);
                    if (!v) activeStream.lineEnd();
                    clean = false;
                } else if (v) {
                    activeStream.lineStart();
                    activeStream.point(x, y);
                    clean = false;
                }
            }
            x_ = x, y_ = y, v_ = v;
        }
        return clipStream;
    };
}
exports.default = clipRectangle;

},{"../math.js":"7JyYl","./buffer.js":"1YOxa","./line.js":"7KlnJ","./rejoin.js":"a6HiF","d3-array":"dclxS","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7KlnJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b, x0, y0, x1, y1) {
    var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x0 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    }
    r = x1 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    }
    r = y0 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    }
    r = y1 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    }
    if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
    if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
    return true;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eYBc9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _polygonContainsJs = require("./polygonContains.js");
var _polygonContainsJsDefault = parcelHelpers.interopDefault(_polygonContainsJs);
var _distanceJs = require("./distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
var _mathJs = require("./math.js");
var containsObjectType = {
    Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
    },
    FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while(++i < n)if (containsGeometry(features[i].geometry, point)) return true;
        return false;
    }
};
var containsGeometryType = {
    Sphere: function() {
        return true;
    },
    Point: function(object, point) {
        return containsPoint(object.coordinates, point);
    },
    MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while(++i < n)if (containsPoint(coordinates[i], point)) return true;
        return false;
    },
    LineString: function(object, point) {
        return containsLine(object.coordinates, point);
    },
    MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while(++i < n)if (containsLine(coordinates[i], point)) return true;
        return false;
    },
    Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
    },
    MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while(++i < n)if (containsPolygon(coordinates[i], point)) return true;
        return false;
    },
    GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while(++i < n)if (containsGeometry(geometries[i], point)) return true;
        return false;
    }
};
function containsGeometry(geometry, point) {
    return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
}
function containsPoint(coordinates, point) {
    return _distanceJsDefault.default(coordinates, point) === 0;
}
function containsLine(coordinates, point) {
    var ao, bo, ab;
    for(var i = 0, n = coordinates.length; i < n; i++){
        bo = _distanceJsDefault.default(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
            ab = _distanceJsDefault.default(coordinates[i], coordinates[i - 1]);
            if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < _mathJs.epsilon2 * ab) return true;
        }
        ao = bo;
    }
    return false;
}
function containsPolygon(coordinates, point) {
    return !!_polygonContainsJsDefault.default(coordinates.map(ringRadians), pointRadians(point));
}
function ringRadians(ring) {
    return ring = ring.map(pointRadians), ring.pop(), ring;
}
function pointRadians(point) {
    return [
        point[0] * _mathJs.radians,
        point[1] * _mathJs.radians
    ];
}
exports.default = function(object, point) {
    return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);
};

},{"./polygonContains.js":"FktDW","./distance.js":"glEIa","./math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"glEIa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lengthJs = require("./length.js");
var _lengthJsDefault = parcelHelpers.interopDefault(_lengthJs);
var coordinates = [
    null,
    null
], object = {
    type: "LineString",
    coordinates: coordinates
};
exports.default = function(a, b) {
    coordinates[0] = a;
    coordinates[1] = b;
    return _lengthJsDefault.default(object);
};

},{"./length.js":"9Miu7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9Miu7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adderJs = require("./adder.js");
var _adderJsDefault = parcelHelpers.interopDefault(_adderJs);
var _mathJs = require("./math.js");
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _streamJs = require("./stream.js");
var _streamJsDefault = parcelHelpers.interopDefault(_streamJs);
var lengthSum = _adderJsDefault.default(), lambda0, sinPhi0, cosPhi0;
var lengthStream = {
    sphere: _noopJsDefault.default,
    point: _noopJsDefault.default,
    lineStart: lengthLineStart,
    lineEnd: _noopJsDefault.default,
    polygonStart: _noopJsDefault.default,
    polygonEnd: _noopJsDefault.default
};
function lengthLineStart() {
    lengthStream.point = lengthPointFirst;
    lengthStream.lineEnd = lengthLineEnd;
}
function lengthLineEnd() {
    lengthStream.point = lengthStream.lineEnd = _noopJsDefault.default;
}
function lengthPointFirst(lambda, phi) {
    lambda *= _mathJs.radians, phi *= _mathJs.radians;
    lambda0 = lambda, sinPhi0 = _mathJs.sin(phi), cosPhi0 = _mathJs.cos(phi);
    lengthStream.point = lengthPoint;
}
function lengthPoint(lambda, phi) {
    lambda *= _mathJs.radians, phi *= _mathJs.radians;
    var sinPhi = _mathJs.sin(phi), cosPhi = _mathJs.cos(phi), delta = _mathJs.abs(lambda - lambda0), cosDelta = _mathJs.cos(delta), sinDelta = _mathJs.sin(delta), x = cosPhi * sinDelta, y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta, z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
    lengthSum.add(_mathJs.atan2(_mathJs.sqrt(x * x + y * y), z));
    lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}
exports.default = function(object) {
    lengthSum.reset();
    _streamJsDefault.default(object, lengthStream);
    return +lengthSum;
};

},{"./adder.js":"67wVm","./math.js":"7JyYl","./noop.js":"a5Top","./stream.js":"jck2Y","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"71CK6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "graticule10", ()=>graticule10
);
var _d3Array = require("d3-array");
var _mathJs = require("./math.js");
function graticuleX(y0, y1, dy) {
    var y2 = _d3Array.range(y0, y1 - _mathJs.epsilon, dy).concat(y1);
    return function(x) {
        return y2.map(function(y) {
            return [
                x,
                y
            ];
        });
    };
}
function graticuleY(x0, x1, dx) {
    var x2 = _d3Array.range(x0, x1 - _mathJs.epsilon, dx).concat(x1);
    return function(y) {
        return x2.map(function(x) {
            return [
                x,
                y
            ];
        });
    };
}
function graticule1() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x3, y3, X, Y, precision = 2.5;
    function graticule() {
        return {
            type: "MultiLineString",
            coordinates: lines()
        };
    }
    function lines() {
        return _d3Array.range(_mathJs.ceil(X0 / DX) * DX, X1, DX).map(X).concat(_d3Array.range(_mathJs.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(_d3Array.range(_mathJs.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
            return _mathJs.abs(x % DX) > _mathJs.epsilon;
        }).map(x3)).concat(_d3Array.range(_mathJs.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
            return _mathJs.abs(y % DY) > _mathJs.epsilon;
        }).map(y3));
    }
    graticule.lines = function() {
        return lines().map(function(coordinates) {
            return {
                type: "LineString",
                coordinates: coordinates
            };
        });
    };
    graticule.outline = function() {
        return {
            type: "Polygon",
            coordinates: [
                X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))
            ]
        };
    };
    graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
    };
    graticule.extentMajor = function(_) {
        if (!arguments.length) return [
            [
                X0,
                Y0
            ],
            [
                X1,
                Y1
            ]
        ];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
    };
    graticule.extentMinor = function(_) {
        if (!arguments.length) return [
            [
                x0,
                y0
            ],
            [
                x1,
                y1
            ]
        ];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
    };
    graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
    };
    graticule.stepMajor = function(_) {
        if (!arguments.length) return [
            DX,
            DY
        ];
        DX = +_[0], DY = +_[1];
        return graticule;
    };
    graticule.stepMinor = function(_) {
        if (!arguments.length) return [
            dx,
            dy
        ];
        dx = +_[0], dy = +_[1];
        return graticule;
    };
    graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x3 = graticuleX(y0, y1, 90);
        y3 = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
    };
    return graticule.extentMajor([
        [
            -180,
            -90 + _mathJs.epsilon
        ],
        [
            180,
            90 - _mathJs.epsilon
        ]
    ]).extentMinor([
        [
            -180,
            -80 - _mathJs.epsilon
        ],
        [
            180,
            80 + _mathJs.epsilon
        ]
    ]);
}
exports.default = graticule1;
function graticule10() {
    return graticule1()();
}

},{"d3-array":"dclxS","./math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9aGW3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mathJs = require("./math.js");
exports.default = function(a, b) {
    var x0 = a[0] * _mathJs.radians, y0 = a[1] * _mathJs.radians, x1 = b[0] * _mathJs.radians, y1 = b[1] * _mathJs.radians, cy0 = _mathJs.cos(y0), sy0 = _mathJs.sin(y0), cy1 = _mathJs.cos(y1), sy1 = _mathJs.sin(y1), kx0 = cy0 * _mathJs.cos(x0), ky0 = cy0 * _mathJs.sin(x0), kx1 = cy1 * _mathJs.cos(x1), ky1 = cy1 * _mathJs.sin(x1), d = 2 * _mathJs.asin(_mathJs.sqrt(_mathJs.haversin(y1 - y0) + cy0 * cy1 * _mathJs.haversin(x1 - x0))), k = _mathJs.sin(d);
    var interpolate = d ? function(t) {
        var B = _mathJs.sin(t *= d) / k, A = _mathJs.sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
        return [
            _mathJs.atan2(y, x) * _mathJs.degrees,
            _mathJs.atan2(z, _mathJs.sqrt(x * x + y * y)) * _mathJs.degrees
        ];
    } : function() {
        return [
            x0 * _mathJs.degrees,
            y0 * _mathJs.degrees
        ];
    };
    interpolate.distance = d;
    return interpolate;
};

},{"./math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k9P5v":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _identityJs = require("../identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _streamJs = require("../stream.js");
var _streamJsDefault = parcelHelpers.interopDefault(_streamJs);
var _areaJs = require("./area.js");
var _areaJsDefault = parcelHelpers.interopDefault(_areaJs);
var _boundsJs = require("./bounds.js");
var _boundsJsDefault = parcelHelpers.interopDefault(_boundsJs);
var _centroidJs = require("./centroid.js");
var _centroidJsDefault = parcelHelpers.interopDefault(_centroidJs);
var _contextJs = require("./context.js");
var _contextJsDefault = parcelHelpers.interopDefault(_contextJs);
var _measureJs = require("./measure.js");
var _measureJsDefault = parcelHelpers.interopDefault(_measureJs);
var _stringJs = require("./string.js");
var _stringJsDefault = parcelHelpers.interopDefault(_stringJs);
exports.default = function(projection, context) {
    var pointRadius = 4.5, projectionStream, contextStream;
    function path(object) {
        if (object) {
            if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
            _streamJsDefault.default(object, projectionStream(contextStream));
        }
        return contextStream.result();
    }
    path.area = function(object) {
        _streamJsDefault.default(object, projectionStream(_areaJsDefault.default));
        return _areaJsDefault.default.result();
    };
    path.measure = function(object) {
        _streamJsDefault.default(object, projectionStream(_measureJsDefault.default));
        return _measureJsDefault.default.result();
    };
    path.bounds = function(object) {
        _streamJsDefault.default(object, projectionStream(_boundsJsDefault.default));
        return _boundsJsDefault.default.result();
    };
    path.centroid = function(object) {
        _streamJsDefault.default(object, projectionStream(_centroidJsDefault.default));
        return _centroidJsDefault.default.result();
    };
    path.projection = function(_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, _identityJsDefault.default) : (projection = _).stream, path) : projection;
    };
    path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new _stringJsDefault.default) : new _contextJsDefault.default(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
    };
    path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
    };
    return path.projection(projection).context(context);
};

},{"../identity.js":"kdbfP","../stream.js":"jck2Y","./area.js":"dU6mN","./bounds.js":"bA46O","./centroid.js":"22OCM","./context.js":"g2MCo","./measure.js":"fzRy5","./string.js":"9KApP","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kdbfP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return x;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dU6mN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adderJs = require("../adder.js");
var _adderJsDefault = parcelHelpers.interopDefault(_adderJs);
var _mathJs = require("../math.js");
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var areaSum = _adderJsDefault.default(), areaRingSum = _adderJsDefault.default(), x00, y00, x0, y0;
var areaStream = {
    point: _noopJsDefault.default,
    lineStart: _noopJsDefault.default,
    lineEnd: _noopJsDefault.default,
    polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noopJsDefault.default;
        areaSum.add(_mathJs.abs(areaRingSum));
        areaRingSum.reset();
    },
    result: function() {
        var area = areaSum / 2;
        areaSum.reset();
        return area;
    }
};
function areaRingStart() {
    areaStream.point = areaPointFirst;
}
function areaPointFirst(x, y) {
    areaStream.point = areaPoint;
    x00 = x0 = x, y00 = y0 = y;
}
function areaPoint(x, y) {
    areaRingSum.add(y0 * x - x0 * y);
    x0 = x, y0 = y;
}
function areaRingEnd() {
    areaPoint(x00, y00);
}
exports.default = areaStream;

},{"../adder.js":"67wVm","../math.js":"7JyYl","../noop.js":"a5Top","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bA46O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var x0 = Infinity, y0 = x0, x1 = -x0, y1 = x1;
var boundsStream = {
    point: boundsPoint,
    lineStart: _noopJsDefault.default,
    lineEnd: _noopJsDefault.default,
    polygonStart: _noopJsDefault.default,
    polygonEnd: _noopJsDefault.default,
    result: function() {
        var bounds = [
            [
                x0,
                y0
            ],
            [
                x1,
                y1
            ]
        ];
        x1 = y1 = -(y0 = x0 = Infinity);
        return bounds;
    }
};
function boundsPoint(x, y) {
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
}
exports.default = boundsStream;

},{"../noop.js":"a5Top","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"22OCM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mathJs = require("../math.js");
// TODO Enforce positive area for exterior, negative area for interior?
var X0 = 0, Y0 = 0, Z0 = 0, X1 = 0, Y1 = 0, Z1 = 0, X2 = 0, Y2 = 0, Z2 = 0, x00, y00, x0, y0;
var centroidStream = {
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
    },
    result: function() {
        var centroid = Z2 ? [
            X2 / Z2,
            Y2 / Z2
        ] : Z1 ? [
            X1 / Z1,
            Y1 / Z1
        ] : Z0 ? [
            X0 / Z0,
            Y0 / Z0
        ] : [
            NaN,
            NaN
        ];
        X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
        return centroid;
    }
};
function centroidPoint(x, y) {
    X0 += x;
    Y0 += y;
    ++Z0;
}
function centroidLineStart() {
    centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x, y) {
    centroidStream.point = centroidPointLine;
    centroidPoint(x0 = x, y0 = y);
}
function centroidPointLine(x, y) {
    var dx = x - x0, dy = y - y0, z = _mathJs.sqrt(dx * dx + dy * dy);
    X1 += z * (x0 + x) / 2;
    Y1 += z * (y0 + y) / 2;
    Z1 += z;
    centroidPoint(x0 = x, y0 = y);
}
function centroidLineEnd() {
    centroidStream.point = centroidPoint;
}
function centroidRingStart() {
    centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
    centroidPointRing(x00, y00);
}
function centroidPointFirstRing(x, y) {
    centroidStream.point = centroidPointRing;
    centroidPoint(x00 = x0 = x, y00 = y0 = y);
}
function centroidPointRing(x, y) {
    var dx = x - x0, dy = y - y0, z = _mathJs.sqrt(dx * dx + dy * dy);
    X1 += z * (x0 + x) / 2;
    Y1 += z * (y0 + y) / 2;
    Z1 += z;
    z = y0 * x - x0 * y;
    X2 += z * (x0 + x);
    Y2 += z * (y0 + y);
    Z2 += z * 3;
    centroidPoint(x0 = x, y0 = y);
}
exports.default = centroidStream;

},{"../math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g2MCo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mathJs = require("../math.js");
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
function PathContext(context) {
    this._context = context;
}
exports.default = PathContext;
PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
        return this._radius = _, this;
    },
    polygonStart: function() {
        this._line = 0;
    },
    polygonEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._point = 0;
    },
    lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
    },
    point: function(x, y) {
        switch(this._point){
            case 0:
                this._context.moveTo(x, y);
                this._point = 1;
                break;
            case 1:
                this._context.lineTo(x, y);
                break;
            default:
                this._context.moveTo(x + this._radius, y);
                this._context.arc(x, y, this._radius, 0, _mathJs.tau);
                break;
        }
    },
    result: _noopJsDefault.default
};

},{"../math.js":"7JyYl","../noop.js":"a5Top","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fzRy5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adderJs = require("../adder.js");
var _adderJsDefault = parcelHelpers.interopDefault(_adderJs);
var _mathJs = require("../math.js");
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var lengthSum = _adderJsDefault.default(), lengthRing, x00, y00, x0, y0;
var lengthStream = {
    point: _noopJsDefault.default,
    lineStart: function() {
        lengthStream.point = lengthPointFirst;
    },
    lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = _noopJsDefault.default;
    },
    polygonStart: function() {
        lengthRing = true;
    },
    polygonEnd: function() {
        lengthRing = null;
    },
    result: function() {
        var length = +lengthSum;
        lengthSum.reset();
        return length;
    }
};
function lengthPointFirst(x, y) {
    lengthStream.point = lengthPoint;
    x00 = x0 = x, y00 = y0 = y;
}
function lengthPoint(x, y) {
    x0 -= x, y0 -= y;
    lengthSum.add(_mathJs.sqrt(x0 * x0 + y0 * y0));
    x0 = x, y0 = y;
}
exports.default = lengthStream;

},{"../adder.js":"67wVm","../math.js":"7JyYl","../noop.js":"a5Top","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9KApP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function PathString() {
    this._string = [];
}
exports.default = PathString;
PathString.prototype = {
    _radius: 4.5,
    _circle: circle(4.5),
    pointRadius: function(_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
    },
    polygonStart: function() {
        this._line = 0;
    },
    polygonEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._point = 0;
    },
    lineEnd: function() {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
    },
    point: function(x, y) {
        switch(this._point){
            case 0:
                this._string.push("M", x, ",", y);
                this._point = 1;
                break;
            case 1:
                this._string.push("L", x, ",", y);
                break;
            default:
                if (this._circle == null) this._circle = circle(this._radius);
                this._string.push("M", x, ",", y, this._circle);
                break;
        }
    },
    result: function() {
        if (this._string.length) {
            var result = this._string.join("");
            this._string = [];
            return result;
        } else return null;
    }
};
function circle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Xlta":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _conicEqualAreaJs = require("./conicEqualArea.js");
var _conicEqualAreaJsDefault = parcelHelpers.interopDefault(_conicEqualAreaJs);
exports.default = function() {
    return _conicEqualAreaJsDefault.default().parallels([
        29.5,
        45.5
    ]).scale(1070).translate([
        480,
        250
    ]).rotate([
        96,
        0
    ]).center([
        -0.6,
        38.7
    ]);
};

},{"./conicEqualArea.js":"c9BXq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c9BXq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "conicEqualAreaRaw", ()=>conicEqualAreaRaw
);
var _mathJs = require("../math.js");
var _conicJs = require("./conic.js");
var _cylindricalEqualAreaJs = require("./cylindricalEqualArea.js");
function conicEqualAreaRaw(y0, y1) {
    var sy0 = _mathJs.sin(y0), n = (sy0 + _mathJs.sin(y1)) / 2;
    // Are the parallels symmetrical around the Equator?
    if (_mathJs.abs(n) < _mathJs.epsilon) return _cylindricalEqualAreaJs.cylindricalEqualAreaRaw(y0);
    var c = 1 + sy0 * (2 * n - sy0), r0 = _mathJs.sqrt(c) / n;
    function project(x, y) {
        var r = _mathJs.sqrt(c - 2 * n * _mathJs.sin(y)) / n;
        return [
            r * _mathJs.sin(x *= n),
            r0 - r * _mathJs.cos(x)
        ];
    }
    project.invert = function(x, y) {
        var r0y = r0 - y, l = _mathJs.atan2(x, _mathJs.abs(r0y)) * _mathJs.sign(r0y);
        if (r0y * n < 0) l -= _mathJs.pi * _mathJs.sign(x) * _mathJs.sign(r0y);
        return [
            l / n,
            _mathJs.asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))
        ];
    };
    return project;
}
exports.default = function() {
    return _conicJs.conicProjection(conicEqualAreaRaw).scale(155.424).center([
        0,
        33.6442
    ]);
};

},{"../math.js":"7JyYl","./conic.js":"hA53y","./cylindricalEqualArea.js":"2kWMW","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hA53y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "conicProjection", ()=>conicProjection
);
var _mathJs = require("../math.js");
var _indexJs = require("./index.js");
function conicProjection(projectAt) {
    var phi0 = 0, phi1 = _mathJs.pi / 3, m = _indexJs.projectionMutator(projectAt), p = m(phi0, phi1);
    p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * _mathJs.radians, phi1 = _[1] * _mathJs.radians) : [
            phi0 * _mathJs.degrees,
            phi1 * _mathJs.degrees
        ];
    };
    return p;
}

},{"../math.js":"7JyYl","./index.js":"i24sF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"i24sF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "projectionMutator", ()=>projectionMutator
);
var _antimeridianJs = require("../clip/antimeridian.js");
var _antimeridianJsDefault = parcelHelpers.interopDefault(_antimeridianJs);
var _circleJs = require("../clip/circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _rectangleJs = require("../clip/rectangle.js");
var _rectangleJsDefault = parcelHelpers.interopDefault(_rectangleJs);
var _composeJs = require("../compose.js");
var _composeJsDefault = parcelHelpers.interopDefault(_composeJs);
var _identityJs = require("../identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _mathJs = require("../math.js");
var _rotationJs = require("../rotation.js");
var _transformJs = require("../transform.js");
var _fitJs = require("./fit.js");
var _resampleJs = require("./resample.js");
var _resampleJsDefault = parcelHelpers.interopDefault(_resampleJs);
var transformRadians = _transformJs.transformer({
    point: function(x, y) {
        this.stream.point(x * _mathJs.radians, y * _mathJs.radians);
    }
});
function transformRotate(rotate) {
    return _transformJs.transformer({
        point: function(x, y) {
            var r = rotate(x, y);
            return this.stream.point(r[0], r[1]);
        }
    });
}
function scaleTranslate(k, dx, dy, sx, sy) {
    function transform(x, y) {
        x *= sx;
        y *= sy;
        return [
            dx + k * x,
            dy - k * y
        ];
    }
    transform.invert = function(x, y) {
        return [
            (x - dx) / k * sx,
            (dy - y) / k * sy
        ];
    };
    return transform;
}
function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
    var cosAlpha = _mathJs.cos(alpha), sinAlpha = _mathJs.sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
    function transform(x, y) {
        x *= sx;
        y *= sy;
        return [
            a * x - b * y + dx,
            dy - b * x - a * y
        ];
    }
    transform.invert = function(x, y) {
        return [
            sx * (ai * x - bi * y + ci),
            sy * (fi - bi * x - ai * y)
        ];
    };
    return transform;
}
function projection1(project) {
    return projectionMutator(function() {
        return project;
    })();
}
exports.default = projection1;
function projectionMutator(projectAt) {
    var project, k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = _antimeridianJsDefault.default, x0 = null, y0, x1, y1, postclip = _identityJsDefault.default, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
    function projection(point) {
        return projectRotateTransform(point[0] * _mathJs.radians, point[1] * _mathJs.radians);
    }
    function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [
            point[0] * _mathJs.degrees,
            point[1] * _mathJs.degrees
        ];
    }
    projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
    };
    projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
    };
    projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    };
    projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? _circleJsDefault.default(theta = _ * _mathJs.radians) : (theta = null, _antimeridianJsDefault.default), reset()) : theta * _mathJs.degrees;
    };
    projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identityJsDefault.default) : _rectangleJsDefault.default(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [
            [
                x0,
                y0
            ],
            [
                x1,
                y1
            ]
        ];
    };
    projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
    };
    projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [
            x,
            y
        ];
    };
    projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * _mathJs.radians, phi = _[1] % 360 * _mathJs.radians, recenter()) : [
            lambda * _mathJs.degrees,
            phi * _mathJs.degrees
        ];
    };
    projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * _mathJs.radians, deltaPhi = _[1] % 360 * _mathJs.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _mathJs.radians : 0, recenter()) : [
            deltaLambda * _mathJs.degrees,
            deltaPhi * _mathJs.degrees,
            deltaGamma * _mathJs.degrees
        ];
    };
    projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * _mathJs.radians, recenter()) : alpha * _mathJs.degrees;
    };
    projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
    };
    projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
    };
    projection.precision = function(_) {
        return arguments.length ? (projectResample = _resampleJsDefault.default(projectTransform, delta2 = _ * _), reset()) : _mathJs.sqrt(delta2);
    };
    projection.fitExtent = function(extent, object) {
        return _fitJs.fitExtent(projection, extent, object);
    };
    projection.fitSize = function(size, object) {
        return _fitJs.fitSize(projection, size, object);
    };
    projection.fitWidth = function(width, object) {
        return _fitJs.fitWidth(projection, width, object);
    };
    projection.fitHeight = function(height, object) {
        return _fitJs.fitHeight(projection, height, object);
    };
    function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = _rotationJs.rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = _composeJsDefault.default(project, transform);
        projectRotateTransform = _composeJsDefault.default(rotate, projectTransform);
        projectResample = _resampleJsDefault.default(projectTransform, delta2);
        return reset();
    }
    function reset() {
        cache = cacheStream = null;
        return projection;
    }
    return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
    };
}

},{"../clip/antimeridian.js":"5t4iH","../clip/circle.js":"iIbFI","../clip/rectangle.js":"2xswT","../compose.js":"hx08x","../identity.js":"kdbfP","../math.js":"7JyYl","../rotation.js":"54Lv8","../transform.js":"feffG","./fit.js":"4as5X","./resample.js":"6CVBg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"feffG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transformer", ()=>transformer
);
exports.default = function(methods) {
    return {
        stream: transformer(methods)
    };
};
function transformer(methods) {
    return function(stream) {
        var s = new TransformStream;
        for(var key in methods)s[key] = methods[key];
        s.stream = stream;
        return s;
    };
}
function TransformStream() {
}
TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x, y) {
        this.stream.point(x, y);
    },
    sphere: function() {
        this.stream.sphere();
    },
    lineStart: function() {
        this.stream.lineStart();
    },
    lineEnd: function() {
        this.stream.lineEnd();
    },
    polygonStart: function() {
        this.stream.polygonStart();
    },
    polygonEnd: function() {
        this.stream.polygonEnd();
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4as5X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fitExtent", ()=>fitExtent
);
parcelHelpers.export(exports, "fitSize", ()=>fitSize
);
parcelHelpers.export(exports, "fitWidth", ()=>fitWidth
);
parcelHelpers.export(exports, "fitHeight", ()=>fitHeight
);
var _streamJs = require("../stream.js");
var _streamJsDefault = parcelHelpers.interopDefault(_streamJs);
var _boundsJs = require("../path/bounds.js");
var _boundsJsDefault = parcelHelpers.interopDefault(_boundsJs);
function fit(projection, fitBounds, object) {
    var clip = projection.clipExtent && projection.clipExtent();
    projection.scale(150).translate([
        0,
        0
    ]);
    if (clip != null) projection.clipExtent(null);
    _streamJsDefault.default(object, projection.stream(_boundsJsDefault.default));
    fitBounds(_boundsJsDefault.default.result());
    if (clip != null) projection.clipExtent(clip);
    return projection;
}
function fitExtent(projection, extent, object) {
    return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([
            x,
            y
        ]);
    }, object);
}
function fitSize(projection, size, object) {
    return fitExtent(projection, [
        [
            0,
            0
        ],
        size
    ], object);
}
function fitWidth(projection, width, object) {
    return fit(projection, function(b) {
        var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];
        projection.scale(150 * k).translate([
            x,
            y
        ]);
    }, object);
}
function fitHeight(projection, height, object) {
    return fit(projection, function(b) {
        var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([
            x,
            y
        ]);
    }, object);
}

},{"../stream.js":"jck2Y","../path/bounds.js":"bA46O","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6CVBg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cartesianJs = require("../cartesian.js");
var _mathJs = require("../math.js");
var _transformJs = require("../transform.js");
var maxDepth = 16, cosMinDistance = _mathJs.cos(30 * _mathJs.radians); // cos(minimum angular distance)
exports.default = function(project, delta2) {
    return +delta2 ? resample(project, delta2) : resampleNone(project);
};
function resampleNone(project) {
    return _transformJs.transformer({
        point: function(x, y) {
            x = project(x, y);
            this.stream.point(x[0], x[1]);
        }
    });
}
function resample(project, delta2) {
    function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
            var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = _mathJs.sqrt(a * a + b * b + c * c), phi2 = _mathJs.asin(c /= m), lambda2 = _mathJs.abs(_mathJs.abs(c) - 1) < _mathJs.epsilon || _mathJs.abs(lambda0 - lambda1) < _mathJs.epsilon ? (lambda0 + lambda1) / 2 : _mathJs.atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > delta2 // perpendicular projected distance
             || _mathJs.abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
             || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
                stream.point(x2, y2);
                resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
            }
        }
    }
    return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, lambda0, x0, y0, a0, b0, c0; // previous point
        var resampleStream = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.polygonStart();
                resampleStream.lineStart = ringStart;
            },
            polygonEnd: function() {
                stream.polygonEnd();
                resampleStream.lineStart = lineStart;
            }
        };
        function point(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
        }
        function lineStart() {
            x0 = NaN;
            resampleStream.point = linePoint;
            stream.lineStart();
        }
        function linePoint(lambda, phi) {
            var c = _cartesianJs.cartesian([
                lambda,
                phi
            ]), p = project(lambda, phi);
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x0, y0);
        }
        function lineEnd() {
            resampleStream.point = point;
            stream.lineEnd();
        }
        function ringStart() {
            lineStart();
            resampleStream.point = ringPoint;
            resampleStream.lineEnd = ringEnd;
        }
        function ringPoint(lambda, phi) {
            linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
            resampleStream.point = linePoint;
        }
        function ringEnd() {
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
            resampleStream.lineEnd = lineEnd;
            lineEnd();
        }
        return resampleStream;
    };
}

},{"../cartesian.js":"evaJG","../math.js":"7JyYl","../transform.js":"feffG","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2kWMW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cylindricalEqualAreaRaw", ()=>cylindricalEqualAreaRaw
);
var _mathJs = require("../math.js");
function cylindricalEqualAreaRaw(phi0) {
    var cosPhi0 = _mathJs.cos(phi0);
    function forward(lambda, phi) {
        return [
            lambda * cosPhi0,
            _mathJs.sin(phi) / cosPhi0
        ];
    }
    forward.invert = function(x, y) {
        return [
            x / cosPhi0,
            _mathJs.asin(y * cosPhi0)
        ];
    };
    return forward;
}

},{"../math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"YtNMK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mathJs = require("../math.js");
var _albersJs = require("./albers.js");
var _albersJsDefault = parcelHelpers.interopDefault(_albersJs);
var _conicEqualAreaJs = require("./conicEqualArea.js");
var _conicEqualAreaJsDefault = parcelHelpers.interopDefault(_conicEqualAreaJs);
var _fitJs = require("./fit.js");
// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
    var n = streams.length;
    return {
        point: function(x, y) {
            var i = -1;
            while(++i < n)streams[i].point(x, y);
        },
        sphere: function() {
            var i = -1;
            while(++i < n)streams[i].sphere();
        },
        lineStart: function() {
            var i = -1;
            while(++i < n)streams[i].lineStart();
        },
        lineEnd: function() {
            var i = -1;
            while(++i < n)streams[i].lineEnd();
        },
        polygonStart: function() {
            var i = -1;
            while(++i < n)streams[i].polygonStart();
        },
        polygonEnd: function() {
            var i = -1;
            while(++i < n)streams[i].polygonEnd();
        }
    };
}
exports.default = function() {
    var cache, cacheStream, lower48 = _albersJsDefault.default(), lower48Point, alaska = _conicEqualAreaJsDefault.default().rotate([
        154,
        0
    ]).center([
        -2,
        58.5
    ]).parallels([
        55,
        65
    ]), alaskaPoint, hawaii = _conicEqualAreaJsDefault.default().rotate([
        157,
        0
    ]).center([
        -3,
        19.9
    ]).parallels([
        8,
        18
    ]), hawaiiPoint, point, pointStream = {
        point: function(x, y) {
            point = [
                x,
                y
            ];
        }
    };
    function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
    }
    albersUsa.invert = function(coordinates) {
        var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
        return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([
            lower48.stream(cacheStream = stream),
            alaska.stream(stream),
            hawaii.stream(stream)
        ]);
    };
    albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
    };
    albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];
        lower48Point = lower48.translate(_).clipExtent([
            [
                x - 0.455 * k,
                y - 0.238 * k
            ],
            [
                x + 0.455 * k,
                y + 0.238 * k
            ]
        ]).stream(pointStream);
        alaskaPoint = alaska.translate([
            x - 0.307 * k,
            y + 0.201 * k
        ]).clipExtent([
            [
                x - 0.425 * k + _mathJs.epsilon,
                y + 0.12 * k + _mathJs.epsilon
            ],
            [
                x - 0.214 * k - _mathJs.epsilon,
                y + 0.234 * k - _mathJs.epsilon
            ]
        ]).stream(pointStream);
        hawaiiPoint = hawaii.translate([
            x - 0.205 * k,
            y + 0.212 * k
        ]).clipExtent([
            [
                x - 0.214 * k + _mathJs.epsilon,
                y + 0.166 * k + _mathJs.epsilon
            ],
            [
                x - 0.115 * k - _mathJs.epsilon,
                y + 0.234 * k - _mathJs.epsilon
            ]
        ]).stream(pointStream);
        return reset();
    };
    albersUsa.fitExtent = function(extent, object) {
        return _fitJs.fitExtent(albersUsa, extent, object);
    };
    albersUsa.fitSize = function(size, object) {
        return _fitJs.fitSize(albersUsa, size, object);
    };
    albersUsa.fitWidth = function(width, object) {
        return _fitJs.fitWidth(albersUsa, width, object);
    };
    albersUsa.fitHeight = function(height, object) {
        return _fitJs.fitHeight(albersUsa, height, object);
    };
    function reset() {
        cache = cacheStream = null;
        return albersUsa;
    }
    return albersUsa.scale(1070);
};

},{"../math.js":"7JyYl","./albers.js":"3Xlta","./conicEqualArea.js":"c9BXq","./fit.js":"4as5X","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7HnSn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "azimuthalEqualAreaRaw", ()=>azimuthalEqualAreaRaw
);
var _mathJs = require("../math.js");
var _azimuthalJs = require("./azimuthal.js");
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var azimuthalEqualAreaRaw = _azimuthalJs.azimuthalRaw(function(cxcy) {
    return _mathJs.sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = _azimuthalJs.azimuthalInvert(function(z) {
    return 2 * _mathJs.asin(z / 2);
});
exports.default = function() {
    return _indexJsDefault.default(azimuthalEqualAreaRaw).scale(124.75).clipAngle(179.999);
};

},{"../math.js":"7JyYl","./azimuthal.js":"cX4Jq","./index.js":"i24sF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cX4Jq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "azimuthalRaw", ()=>azimuthalRaw
);
parcelHelpers.export(exports, "azimuthalInvert", ()=>azimuthalInvert
);
var _mathJs = require("../math.js");
function azimuthalRaw(scale) {
    return function(x, y) {
        var cx = _mathJs.cos(x), cy = _mathJs.cos(y), k = scale(cx * cy);
        return [
            k * cy * _mathJs.sin(x),
            k * _mathJs.sin(y)
        ];
    };
}
function azimuthalInvert(angle) {
    return function(x, y) {
        var z = _mathJs.sqrt(x * x + y * y), c = angle(z), sc = _mathJs.sin(c), cc = _mathJs.cos(c);
        return [
            _mathJs.atan2(x * sc, z * cc),
            _mathJs.asin(z && y * sc / z)
        ];
    };
}

},{"../math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ggmAs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "azimuthalEquidistantRaw", ()=>azimuthalEquidistantRaw
);
var _mathJs = require("../math.js");
var _azimuthalJs = require("./azimuthal.js");
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var azimuthalEquidistantRaw = _azimuthalJs.azimuthalRaw(function(c) {
    return (c = _mathJs.acos(c)) && c / _mathJs.sin(c);
});
azimuthalEquidistantRaw.invert = _azimuthalJs.azimuthalInvert(function(z) {
    return z;
});
exports.default = function() {
    return _indexJsDefault.default(azimuthalEquidistantRaw).scale(79.4188).clipAngle(179.999);
};

},{"../math.js":"7JyYl","./azimuthal.js":"cX4Jq","./index.js":"i24sF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"qkL9e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "conicConformalRaw", ()=>conicConformalRaw
);
var _mathJs = require("../math.js");
var _conicJs = require("./conic.js");
var _mercatorJs = require("./mercator.js");
function tany(y) {
    return _mathJs.tan((_mathJs.halfPi + y) / 2);
}
function conicConformalRaw(y0, y1) {
    var cy0 = _mathJs.cos(y0), n = y0 === y1 ? _mathJs.sin(y0) : _mathJs.log(cy0 / _mathJs.cos(y1)) / _mathJs.log(tany(y1) / tany(y0)), f = cy0 * _mathJs.pow(tany(y0), n) / n;
    if (!n) return _mercatorJs.mercatorRaw;
    function project(x, y) {
        if (f > 0) {
            if (y < -_mathJs.halfPi + _mathJs.epsilon) y = -_mathJs.halfPi + _mathJs.epsilon;
        } else if (y > _mathJs.halfPi - _mathJs.epsilon) y = _mathJs.halfPi - _mathJs.epsilon;
        var r = f / _mathJs.pow(tany(y), n);
        return [
            r * _mathJs.sin(n * x),
            f - r * _mathJs.cos(n * x)
        ];
    }
    project.invert = function(x, y) {
        var fy = f - y, r = _mathJs.sign(n) * _mathJs.sqrt(x * x + fy * fy), l = _mathJs.atan2(x, _mathJs.abs(fy)) * _mathJs.sign(fy);
        if (fy * n < 0) l -= _mathJs.pi * _mathJs.sign(x) * _mathJs.sign(fy);
        return [
            l / n,
            2 * _mathJs.atan(_mathJs.pow(f / r, 1 / n)) - _mathJs.halfPi
        ];
    };
    return project;
}
exports.default = function() {
    return _conicJs.conicProjection(conicConformalRaw).scale(109.5).parallels([
        30,
        30
    ]);
};

},{"../math.js":"7JyYl","./conic.js":"hA53y","./mercator.js":"fE71g","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fE71g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mercatorRaw", ()=>mercatorRaw
);
parcelHelpers.export(exports, "mercatorProjection", ()=>mercatorProjection
);
var _mathJs = require("../math.js");
var _rotationJs = require("../rotation.js");
var _rotationJsDefault = parcelHelpers.interopDefault(_rotationJs);
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function mercatorRaw(lambda, phi) {
    return [
        lambda,
        _mathJs.log(_mathJs.tan((_mathJs.halfPi + phi) / 2))
    ];
}
mercatorRaw.invert = function(x, y) {
    return [
        x,
        2 * _mathJs.atan(_mathJs.exp(y)) - _mathJs.halfPi
    ];
};
exports.default = function() {
    return mercatorProjection(mercatorRaw).scale(961 / _mathJs.tau);
};
function mercatorProjection(project) {
    var m = _indexJsDefault.default(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x0 = null, y0, x1, y1; // clip extent
    m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
    };
    m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
    };
    m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
    };
    m.clipExtent = function(_) {
        return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [
            [
                x0,
                y0
            ],
            [
                x1,
                y1
            ]
        ];
    };
    function reclip() {
        var k = _mathJs.pi * scale(), t = m(_rotationJsDefault.default(m.rotate()).invert([
            0,
            0
        ]));
        return clipExtent(x0 == null ? [
            [
                t[0] - k,
                t[1] - k
            ],
            [
                t[0] + k,
                t[1] + k
            ]
        ] : project === mercatorRaw ? [
            [
                Math.max(t[0] - k, x0),
                y0
            ],
            [
                Math.min(t[0] + k, x1),
                y1
            ]
        ] : [
            [
                x0,
                Math.max(t[1] - k, y0)
            ],
            [
                x1,
                Math.min(t[1] + k, y1)
            ]
        ]);
    }
    return reclip();
}

},{"../math.js":"7JyYl","../rotation.js":"54Lv8","./index.js":"i24sF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"i4E3R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "conicEquidistantRaw", ()=>conicEquidistantRaw
);
var _mathJs = require("../math.js");
var _conicJs = require("./conic.js");
var _equirectangularJs = require("./equirectangular.js");
function conicEquidistantRaw(y0, y1) {
    var cy0 = _mathJs.cos(y0), n = y0 === y1 ? _mathJs.sin(y0) : (cy0 - _mathJs.cos(y1)) / (y1 - y0), g = cy0 / n + y0;
    if (_mathJs.abs(n) < _mathJs.epsilon) return _equirectangularJs.equirectangularRaw;
    function project(x, y) {
        var gy = g - y, nx = n * x;
        return [
            gy * _mathJs.sin(nx),
            g - gy * _mathJs.cos(nx)
        ];
    }
    project.invert = function(x, y) {
        var gy = g - y, l = _mathJs.atan2(x, _mathJs.abs(gy)) * _mathJs.sign(gy);
        if (gy * n < 0) l -= _mathJs.pi * _mathJs.sign(x) * _mathJs.sign(gy);
        return [
            l / n,
            g - _mathJs.sign(n) * _mathJs.sqrt(x * x + gy * gy)
        ];
    };
    return project;
}
exports.default = function() {
    return _conicJs.conicProjection(conicEquidistantRaw).scale(131.154).center([
        0,
        13.9389
    ]);
};

},{"../math.js":"7JyYl","./conic.js":"hA53y","./equirectangular.js":"6r5uk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6r5uk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "equirectangularRaw", ()=>equirectangularRaw
);
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function equirectangularRaw(lambda, phi) {
    return [
        lambda,
        phi
    ];
}
equirectangularRaw.invert = equirectangularRaw;
exports.default = function() {
    return _indexJsDefault.default(equirectangularRaw).scale(152.63);
};

},{"./index.js":"i24sF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2iIrI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "equalEarthRaw", ()=>equalEarthRaw
);
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _mathJs = require("../math.js");
var A1 = 1.340264, A2 = -0.081106, A3 = 0.000893, A4 = 0.003796, M = _mathJs.sqrt(3) / 2, iterations = 12;
function equalEarthRaw(lambda, phi) {
    var l = _mathJs.asin(M * _mathJs.sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
    return [
        lambda * _mathJs.cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
    ];
}
equalEarthRaw.invert = function(x, y) {
    var l = y, l2 = l * l, l6 = l2 * l2 * l2;
    for(var i = 0, delta, fy, fpy; i < iterations; ++i){
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (_mathJs.abs(delta) < _mathJs.epsilon2) break;
    }
    return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / _mathJs.cos(l),
        _mathJs.asin(_mathJs.sin(l) / M)
    ];
};
exports.default = function() {
    return _indexJsDefault.default(equalEarthRaw).scale(177.158);
};

},{"./index.js":"i24sF","../math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gz9Xc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gnomonicRaw", ()=>gnomonicRaw
);
var _mathJs = require("../math.js");
var _azimuthalJs = require("./azimuthal.js");
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function gnomonicRaw(x, y) {
    var cy = _mathJs.cos(y), k = _mathJs.cos(x) * cy;
    return [
        cy * _mathJs.sin(x) / k,
        _mathJs.sin(y) / k
    ];
}
gnomonicRaw.invert = _azimuthalJs.azimuthalInvert(_mathJs.atan);
exports.default = function() {
    return _indexJsDefault.default(gnomonicRaw).scale(144.049).clipAngle(60);
};

},{"../math.js":"7JyYl","./azimuthal.js":"cX4Jq","./index.js":"i24sF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ipPmW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rectangleJs = require("../clip/rectangle.js");
var _rectangleJsDefault = parcelHelpers.interopDefault(_rectangleJs);
var _identityJs = require("../identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _transformJs = require("../transform.js");
var _fitJs = require("./fit.js");
var _mathJs = require("../math.js");
exports.default = function() {
    var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x0 = null, y0, x1, y1, kx = 1, ky = 1, transform = _transformJs.transformer({
        point: function(x, y) {
            var p = projection([
                x,
                y
            ]);
            this.stream.point(p[0], p[1]);
        }
    }), postclip = _identityJsDefault.default, cache, cacheStream;
    function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
    }
    function projection(p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
            var t = y * ca - x * sa;
            x = x * ca + y * sa;
            y = t;
        }
        return [
            x + tx,
            y + ty
        ];
    }
    projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
            var t = y * ca + x * sa;
            x = x * ca - y * sa;
            y = t;
        }
        return [
            x / kx,
            y / ky
        ];
    };
    projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
    };
    projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    };
    projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identityJsDefault.default) : _rectangleJsDefault.default(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [
            [
                x0,
                y0
            ],
            [
                x1,
                y1
            ]
        ];
    };
    projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
    };
    projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [
            tx,
            ty
        ];
    };
    projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * _mathJs.radians, sa = _mathJs.sin(alpha), ca = _mathJs.cos(alpha), reset()) : alpha * _mathJs.degrees;
    };
    projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
    };
    projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
    };
    projection.fitExtent = function(extent, object) {
        return _fitJs.fitExtent(projection, extent, object);
    };
    projection.fitSize = function(size, object) {
        return _fitJs.fitSize(projection, size, object);
    };
    projection.fitWidth = function(width, object) {
        return _fitJs.fitWidth(projection, width, object);
    };
    projection.fitHeight = function(height, object) {
        return _fitJs.fitHeight(projection, height, object);
    };
    return projection;
};

},{"../clip/rectangle.js":"2xswT","../identity.js":"kdbfP","../transform.js":"feffG","./fit.js":"4as5X","../math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gQDpu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "naturalEarth1Raw", ()=>naturalEarth1Raw
);
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _mathJs = require("../math.js");
function naturalEarth1Raw(lambda, phi) {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
    ];
}
naturalEarth1Raw.invert = function(x, y) {
    var phi = y, i = 25, delta;
    do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) / (1.007226 + phi2 * (0.045255 + phi4 * (-0.311325 + 0.259866 * phi2 - 0.005916 * 11 * phi4)));
    }while (_mathJs.abs(delta) > _mathJs.epsilon && --i > 0)
    return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
    ];
};
exports.default = function() {
    return _indexJsDefault.default(naturalEarth1Raw).scale(175.295);
};

},{"./index.js":"i24sF","../math.js":"7JyYl","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Wbli":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "orthographicRaw", ()=>orthographicRaw
);
var _mathJs = require("../math.js");
var _azimuthalJs = require("./azimuthal.js");
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function orthographicRaw(x, y) {
    return [
        _mathJs.cos(y) * _mathJs.sin(x),
        _mathJs.sin(y)
    ];
}
orthographicRaw.invert = _azimuthalJs.azimuthalInvert(_mathJs.asin);
exports.default = function() {
    return _indexJsDefault.default(orthographicRaw).scale(249.5).clipAngle(90 + _mathJs.epsilon);
};

},{"../math.js":"7JyYl","./azimuthal.js":"cX4Jq","./index.js":"i24sF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hIzPd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stereographicRaw", ()=>stereographicRaw
);
var _mathJs = require("../math.js");
var _azimuthalJs = require("./azimuthal.js");
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function stereographicRaw(x, y) {
    var cy = _mathJs.cos(y), k = 1 + _mathJs.cos(x) * cy;
    return [
        cy * _mathJs.sin(x) / k,
        _mathJs.sin(y) / k
    ];
}
stereographicRaw.invert = _azimuthalJs.azimuthalInvert(function(z) {
    return 2 * _mathJs.atan(z);
});
exports.default = function() {
    return _indexJsDefault.default(stereographicRaw).scale(250).clipAngle(142);
};

},{"../math.js":"7JyYl","./azimuthal.js":"cX4Jq","./index.js":"i24sF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4SRkZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transverseMercatorRaw", ()=>transverseMercatorRaw
);
var _mathJs = require("../math.js");
var _mercatorJs = require("./mercator.js");
function transverseMercatorRaw(lambda, phi) {
    return [
        _mathJs.log(_mathJs.tan((_mathJs.halfPi + phi) / 2)),
        -lambda
    ];
}
transverseMercatorRaw.invert = function(x, y) {
    return [
        -y,
        2 * _mathJs.atan(_mathJs.exp(x)) - _mathJs.halfPi
    ];
};
exports.default = function() {
    var m = _mercatorJs.mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
    m.center = function(_) {
        return arguments.length ? center([
            -_[1],
            _[0]
        ]) : (_ = center(), [
            _[1],
            -_[0]
        ]);
    };
    m.rotate = function(_) {
        return arguments.length ? rotate([
            _[0],
            _[1],
            _.length > 2 ? _[2] + 90 : 90
        ]) : (_ = rotate(), [
            _[0],
            _[1],
            _[2] - 90
        ]);
    };
    return rotate([
        0,
        0,
        90
    ]).scale(159.155);
};

},{"../math.js":"7JyYl","./mercator.js":"fE71g","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1CTpH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cluster", ()=>_clusterJsDefault.default
);
parcelHelpers.export(exports, "hierarchy", ()=>_indexJsDefault.default
);
parcelHelpers.export(exports, "pack", ()=>_indexJsDefault1.default
);
parcelHelpers.export(exports, "packSiblings", ()=>_siblingsJsDefault.default
);
parcelHelpers.export(exports, "packEnclose", ()=>_encloseJsDefault.default
);
parcelHelpers.export(exports, "partition", ()=>_partitionJsDefault.default
);
parcelHelpers.export(exports, "stratify", ()=>_stratifyJsDefault.default
);
parcelHelpers.export(exports, "tree", ()=>_treeJsDefault.default
);
parcelHelpers.export(exports, "treemap", ()=>_indexJsDefault2.default
);
parcelHelpers.export(exports, "treemapBinary", ()=>_binaryJsDefault.default
);
parcelHelpers.export(exports, "treemapDice", ()=>_diceJsDefault.default
);
parcelHelpers.export(exports, "treemapSlice", ()=>_sliceJsDefault.default
);
parcelHelpers.export(exports, "treemapSliceDice", ()=>_sliceDiceJsDefault.default
);
parcelHelpers.export(exports, "treemapSquarify", ()=>_squarifyJsDefault.default
);
parcelHelpers.export(exports, "treemapResquarify", ()=>_resquarifyJsDefault.default
);
var _clusterJs = require("./cluster.js");
var _clusterJsDefault = parcelHelpers.interopDefault(_clusterJs);
var _indexJs = require("./hierarchy/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./pack/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _siblingsJs = require("./pack/siblings.js");
var _siblingsJsDefault = parcelHelpers.interopDefault(_siblingsJs);
var _encloseJs = require("./pack/enclose.js");
var _encloseJsDefault = parcelHelpers.interopDefault(_encloseJs);
var _partitionJs = require("./partition.js");
var _partitionJsDefault = parcelHelpers.interopDefault(_partitionJs);
var _stratifyJs = require("./stratify.js");
var _stratifyJsDefault = parcelHelpers.interopDefault(_stratifyJs);
var _treeJs = require("./tree.js");
var _treeJsDefault = parcelHelpers.interopDefault(_treeJs);
var _indexJs2 = require("./treemap/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _binaryJs = require("./treemap/binary.js");
var _binaryJsDefault = parcelHelpers.interopDefault(_binaryJs);
var _diceJs = require("./treemap/dice.js");
var _diceJsDefault = parcelHelpers.interopDefault(_diceJs);
var _sliceJs = require("./treemap/slice.js");
var _sliceJsDefault = parcelHelpers.interopDefault(_sliceJs);
var _sliceDiceJs = require("./treemap/sliceDice.js");
var _sliceDiceJsDefault = parcelHelpers.interopDefault(_sliceDiceJs);
var _squarifyJs = require("./treemap/squarify.js");
var _squarifyJsDefault = parcelHelpers.interopDefault(_squarifyJs);
var _resquarifyJs = require("./treemap/resquarify.js");
var _resquarifyJsDefault = parcelHelpers.interopDefault(_resquarifyJs);

},{"./cluster.js":"eekJC","./hierarchy/index.js":"bFZL8","./pack/index.js":"aoBKH","./pack/siblings.js":"gh27H","./pack/enclose.js":"j0SeI","./partition.js":"410UQ","./stratify.js":"6yjWx","./tree.js":"4yd2C","./treemap/index.js":"aZ8ZK","./treemap/binary.js":"fDGjN","./treemap/dice.js":"97Wyc","./treemap/slice.js":"ewDPE","./treemap/sliceDice.js":"2icK7","./treemap/squarify.js":"ctwRB","./treemap/resquarify.js":"3Fdan","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eekJC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function defaultSeparation(a, b) {
    return a.parent === b.parent ? 1 : 2;
}
function meanX(children) {
    return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x, c) {
    return x + c.x;
}
function maxY(children) {
    return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y, c) {
    return Math.max(y, c.y);
}
function leafLeft(node) {
    var children;
    while(children = node.children)node = children[0];
    return node;
}
function leafRight(node) {
    var children;
    while(children = node.children)node = children[children.length - 1];
    return node;
}
exports.default = function() {
    var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
    function cluster(root) {
        var previousNode, x = 0;
        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
            var children = node.children;
            if (children) {
                node.x = meanX(children);
                node.y = maxY(children);
            } else {
                node.x = previousNode ? x += separation(node, previousNode) : 0;
                node.y = 0;
                previousNode = node;
            }
        });
        var left = leafLeft(root), right = leafRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
            node.x = (node.x - root.x) * dx;
            node.y = (root.y - node.y) * dy;
        } : function(node) {
            node.x = (node.x - x0) / (x1 - x0) * dx;
            node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
    }
    cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
    };
    cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [
            dx,
            dy
        ];
    };
    cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [
            dx,
            dy
        ] : null;
    };
    return cluster;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bFZL8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "computeHeight", ()=>computeHeight
);
parcelHelpers.export(exports, "Node", ()=>Node
);
var _countJs = require("./count.js");
var _countJsDefault = parcelHelpers.interopDefault(_countJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _eachBeforeJs = require("./eachBefore.js");
var _eachBeforeJsDefault = parcelHelpers.interopDefault(_eachBeforeJs);
var _eachAfterJs = require("./eachAfter.js");
var _eachAfterJsDefault = parcelHelpers.interopDefault(_eachAfterJs);
var _sumJs = require("./sum.js");
var _sumJsDefault = parcelHelpers.interopDefault(_sumJs);
var _sortJs = require("./sort.js");
var _sortJsDefault = parcelHelpers.interopDefault(_sortJs);
var _pathJs = require("./path.js");
var _pathJsDefault = parcelHelpers.interopDefault(_pathJs);
var _ancestorsJs = require("./ancestors.js");
var _ancestorsJsDefault = parcelHelpers.interopDefault(_ancestorsJs);
var _descendantsJs = require("./descendants.js");
var _descendantsJsDefault = parcelHelpers.interopDefault(_descendantsJs);
var _leavesJs = require("./leaves.js");
var _leavesJsDefault = parcelHelpers.interopDefault(_leavesJs);
var _linksJs = require("./links.js");
var _linksJsDefault = parcelHelpers.interopDefault(_linksJs);
function hierarchy(data, children) {
    var root = new Node(data), valued = +data.value && (root.value = data.value), node, nodes = [
        root
    ], child, childs, i, n;
    if (children == null) children = defaultChildren;
    while(node = nodes.pop()){
        if (valued) node.value = +node.data.value;
        if ((childs = children(node.data)) && (n = childs.length)) {
            node.children = new Array(n);
            for(i = n - 1; i >= 0; --i){
                nodes.push(child = node.children[i] = new Node(childs[i]));
                child.parent = node;
                child.depth = node.depth + 1;
            }
        }
    }
    return root.eachBefore(computeHeight);
}
exports.default = hierarchy;
function node_copy() {
    return hierarchy(this).eachBefore(copyData);
}
function defaultChildren(d) {
    return d.children;
}
function copyData(node) {
    node.data = node.data.data;
}
function computeHeight(node) {
    var height = 0;
    do node.height = height;
    while ((node = node.parent) && node.height < ++height)
}
function Node(data) {
    this.data = data;
    this.depth = this.height = 0;
    this.parent = null;
}
Node.prototype = hierarchy.prototype = {
    constructor: Node,
    count: _countJsDefault.default,
    each: _eachJsDefault.default,
    eachAfter: _eachAfterJsDefault.default,
    eachBefore: _eachBeforeJsDefault.default,
    sum: _sumJsDefault.default,
    sort: _sortJsDefault.default,
    path: _pathJsDefault.default,
    ancestors: _ancestorsJsDefault.default,
    descendants: _descendantsJsDefault.default,
    leaves: _leavesJsDefault.default,
    links: _linksJsDefault.default,
    copy: node_copy
};

},{"./count.js":"1z2L2","./each.js":"8AqqL","./eachBefore.js":"1Qi5i","./eachAfter.js":"3w3dx","./sum.js":"92iy8","./sort.js":"68Psq","./path.js":"bqpPI","./ancestors.js":"hyZGa","./descendants.js":"k1Ghn","./leaves.js":"cVQcM","./links.js":"i4kFO","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1z2L2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function count(node) {
    var sum = 0, children = node.children, i = children && children.length;
    if (!i) sum = 1;
    else while(--i >= 0)sum += children[i].value;
    node.value = sum;
}
exports.default = function() {
    return this.eachAfter(count);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8AqqL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(callback) {
    var node = this, current, next = [
        node
    ], children, i, n;
    do {
        current = next.reverse(), next = [];
        while(node = current.pop()){
            callback(node), children = node.children;
            if (children) for(i = 0, n = children.length; i < n; ++i)next.push(children[i]);
        }
    }while (next.length)
    return this;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1Qi5i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(callback) {
    var node = this, nodes = [
        node
    ], children, i;
    while(node = nodes.pop()){
        callback(node), children = node.children;
        if (children) for(i = children.length - 1; i >= 0; --i)nodes.push(children[i]);
    }
    return this;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3w3dx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(callback) {
    var node = this, nodes = [
        node
    ], next = [], children, i, n;
    while(node = nodes.pop()){
        next.push(node), children = node.children;
        if (children) for(i = 0, n = children.length; i < n; ++i)nodes.push(children[i]);
    }
    while(node = next.pop())callback(node);
    return this;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"92iy8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(value) {
    return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0, children = node.children, i = children && children.length;
        while(--i >= 0)sum += children[i].value;
        node.value = sum;
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"68Psq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(compare) {
    return this.eachBefore(function(node) {
        if (node.children) node.children.sort(compare);
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bqpPI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(end) {
    var start = this, ancestor = leastCommonAncestor(start, end), nodes = [
        start
    ];
    while(start !== ancestor){
        start = start.parent;
        nodes.push(start);
    }
    var k = nodes.length;
    while(end !== ancestor){
        nodes.splice(k, 0, end);
        end = end.parent;
    }
    return nodes;
};
function leastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
    a = aNodes.pop();
    b = bNodes.pop();
    while(a === b){
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
    }
    return c;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hyZGa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    var node = this, nodes = [
        node
    ];
    while(node = node.parent)nodes.push(node);
    return nodes;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k1Ghn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    var nodes = [];
    this.each(function(node) {
        nodes.push(node);
    });
    return nodes;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cVQcM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    var leaves = [];
    this.eachBefore(function(node) {
        if (!node.children) leaves.push(node);
    });
    return leaves;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"i4kFO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    var root = this, links = [];
    root.each(function(node) {
        if (node !== root) links.push({
            source: node.parent,
            target: node
        });
    });
    return links;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aoBKH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _siblingsJs = require("./siblings.js");
var _accessorsJs = require("../accessors.js");
var _constantJs = require("../constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
function defaultRadius(d) {
    return Math.sqrt(d.value);
}
exports.default = function() {
    var radius = null, dx = 1, dy = 1, padding = _constantJs.constantZero;
    function pack(root) {
        root.x = dx / 2, root.y = dy / 2;
        if (radius) root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
        else root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(_constantJs.constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        return root;
    }
    pack.radius = function(x) {
        return arguments.length ? (radius = _accessorsJs.optional(x), pack) : radius;
    };
    pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [
            dx,
            dy
        ];
    };
    pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : _constantJsDefault.default(+x), pack) : padding;
    };
    return pack;
};
function radiusLeaf(radius) {
    return function(node) {
        if (!node.children) node.r = Math.max(0, +radius(node) || 0);
    };
}
function packChildren(padding, k) {
    return function(node) {
        if (children = node.children) {
            var children, i, n = children.length, r = padding(node) * k || 0, e;
            if (r) for(i = 0; i < n; ++i)children[i].r += r;
            e = _siblingsJs.packEnclose(children);
            if (r) for(i = 0; i < n; ++i)children[i].r -= r;
            node.r = e + r;
        }
    };
}
function translateChild(k) {
    return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
            node.x = parent.x + k * node.x;
            node.y = parent.y + k * node.y;
        }
    };
}

},{"./siblings.js":"gh27H","../accessors.js":"22Lor","../constant.js":"it5Dd","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gh27H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packEnclose", ()=>packEnclose
);
var _encloseJs = require("./enclose.js");
var _encloseJsDefault = parcelHelpers.interopDefault(_encloseJs);
function place(b, a, c) {
    var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b2, d2 = dx * dx + dy * dy;
    if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
            x = (d2 + b2 - a2) / (2 * d2);
            y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
            c.x = b.x - x * dx - y * dy;
            c.y = b.y - x * dy + y * dx;
        } else {
            x = (d2 + a2 - b2) / (2 * d2);
            y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
            c.x = a.x + x * dx - y * dy;
            c.y = a.y + x * dy + y * dx;
        }
    } else {
        c.x = a.x + c.r;
        c.y = a.y;
    }
}
function intersects(a, b) {
    var dr = a.r + b.r - 0.000001, dx = b.x - a.x, dy = b.y - a.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
    var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;
    return dx * dx + dy * dy;
}
function Node(circle) {
    this._ = circle;
    this.next = null;
    this.previous = null;
}
function packEnclose(circles) {
    if (!(n = circles.length)) return 0;
    var a, b, c, n, aa, ca, i, j, k, sj, sk;
    // Place the first circle.
    a = circles[0], a.x = 0, a.y = 0;
    if (!(n > 1)) return a.r;
    // Place the second circle.
    b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
    if (!(n > 2)) return a.r + b.r;
    // Place the third circle.
    place(b, a, c = circles[2]);
    // Initialize the front-chain using the first three circles a, b and c.
    a = new Node(a), b = new Node(b), c = new Node(c);
    a.next = c.previous = b;
    b.next = a.previous = c;
    c.next = b.previous = a;
    // Attempt to place each remaining circle…
    pack: for(i = 3; i < n; ++i){
        place(a._, b._, c = circles[i]), c = new Node(c);
        // Find the closest intersecting circle on the front-chain, if any.
        // “Closeness” is determined by linear distance along the front-chain.
        // “Ahead” or “behind” is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do if (sj <= sk) {
            if (intersects(j._, c._)) {
                b = j, a.next = b, b.previous = a, --i;
                continue pack;
            }
            sj += j._.r, j = j.next;
        } else {
            if (intersects(k._, c._)) {
                a = k, a.next = b, b.previous = a, --i;
                continue pack;
            }
            sk += k._.r, k = k.previous;
        }
        while (j !== k.next)
        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;
        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while((c = c.next) !== b)if ((ca = score(c)) < aa) a = c, aa = ca;
        b = a.next;
    }
    // Compute the enclosing circle of the front chain.
    a = [
        b._
    ], c = b;
    while((c = c.next) !== b)a.push(c._);
    c = _encloseJsDefault.default(a);
    // Translate the circles to put the enclosing circle around the origin.
    for(i = 0; i < n; ++i)a = circles[i], a.x -= c.x, a.y -= c.y;
    return c.r;
}
exports.default = function(circles) {
    packEnclose(circles);
    return circles;
};

},{"./enclose.js":"j0SeI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"j0SeI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayJs = require("../array.js");
exports.default = function(circles) {
    var i = 0, n = (circles = _arrayJs.shuffle(_arrayJs.slice.call(circles))).length, B = [], p, e;
    while(i < n){
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
    }
    return e;
};
function extendBasis(B, p) {
    var i, j;
    if (enclosesWeakAll(p, B)) return [
        p
    ];
    // If we get here then B must have at least one element.
    for(i = 0; i < B.length; ++i){
        if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) return [
            B[i],
            p
        ];
    }
    // If we get here then B must have at least two elements.
    for(i = 0; i < B.length - 1; ++i)for(j = i + 1; j < B.length; ++j){
        if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) return [
            B[i],
            B[j],
            p
        ];
    }
    // If we get here then something is very wrong.
    throw new Error;
}
function enclosesNot(a, b) {
    var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
    return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a, b) {
    var dr = a.r - b.r + 0.000001, dx = b.x - a.x, dy = b.y - a.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a, B) {
    for(var i = 0; i < B.length; ++i){
        if (!enclosesWeak(a, B[i])) return false;
    }
    return true;
}
function encloseBasis(B) {
    switch(B.length){
        case 1:
            return encloseBasis1(B[0]);
        case 2:
            return encloseBasis2(B[0], B[1]);
        case 3:
            return encloseBasis3(B[0], B[1], B[2]);
    }
}
function encloseBasis1(a) {
    return {
        x: a.x,
        y: a.y,
        r: a.r
    };
}
function encloseBasis2(a, b) {
    var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
    return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
    };
}
function encloseBasis3(a, b, c) {
    var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
    return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
    };
}

},{"../array.js":"fxWpc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fxWpc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "slice", ()=>slice
);
parcelHelpers.export(exports, "shuffle", ()=>shuffle
);
var slice = Array.prototype.slice;
function shuffle(array) {
    var m = array.length, t, i;
    while(m){
        i = Math.random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
    }
    return array;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"22Lor":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "optional", ()=>optional
);
parcelHelpers.export(exports, "required", ()=>required
);
function optional(f) {
    return f == null ? null : required(f);
}
function required(f) {
    if (typeof f !== "function") throw new Error;
    return f;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"it5Dd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "constantZero", ()=>constantZero
);
function constantZero() {
    return 0;
}
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"410UQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _roundJs = require("./treemap/round.js");
var _roundJsDefault = parcelHelpers.interopDefault(_roundJs);
var _diceJs = require("./treemap/dice.js");
var _diceJsDefault = parcelHelpers.interopDefault(_diceJs);
exports.default = function() {
    var dx = 1, dy1 = 1, padding = 0, round = false;
    function partition(root) {
        var n = root.height + 1;
        root.x0 = root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy1 / n;
        root.eachBefore(positionNode(dy1, n));
        if (round) root.eachBefore(_roundJsDefault.default);
        return root;
    }
    function positionNode(dy, n) {
        return function(node) {
            if (node.children) _diceJsDefault.default(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
            var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding, y1 = node.y1 - padding;
            if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
            if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
            node.x0 = x0;
            node.y0 = y0;
            node.x1 = x1;
            node.y1 = y1;
        };
    }
    partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
    };
    partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy1 = +x[1], partition) : [
            dx,
            dy1
        ];
    };
    partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
    };
    return partition;
};

},{"./treemap/round.js":"6GfK5","./treemap/dice.js":"97Wyc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6GfK5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"97Wyc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(parent, x0, y0, x1, y1) {
    var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
    while(++i < n){
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6yjWx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _accessorsJs = require("./accessors.js");
var _indexJs = require("./hierarchy/index.js");
var keyPrefix = "$", preroot = {
    depth: -1
}, ambiguous = {
};
function defaultId(d) {
    return d.id;
}
function defaultParentId(d) {
    return d.parentId;
}
exports.default = function() {
    var id = defaultId, parentId = defaultParentId;
    function stratify(data) {
        var d, i, n = data.length, root, parent, node1, nodes = new Array(n), nodeId, nodeKey, nodeByKey = {
        };
        for(i = 0; i < n; ++i){
            d = data[i], node1 = nodes[i] = new _indexJs.Node(d);
            if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
                nodeKey = keyPrefix + (node1.id = nodeId);
                nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node1;
            }
        }
        for(i = 0; i < n; ++i){
            node1 = nodes[i], nodeId = parentId(data[i], i, data);
            if (nodeId == null || !(nodeId += "")) {
                if (root) throw new Error("multiple roots");
                root = node1;
            } else {
                parent = nodeByKey[keyPrefix + nodeId];
                if (!parent) throw new Error("missing: " + nodeId);
                if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
                if (parent.children) parent.children.push(node1);
                else parent.children = [
                    node1
                ];
                node1.parent = parent;
            }
        }
        if (!root) throw new Error("no root");
        root.parent = preroot;
        root.eachBefore(function(node) {
            node.depth = node.parent.depth + 1;
            --n;
        }).eachBefore(_indexJs.computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");
        return root;
    }
    stratify.id = function(x) {
        return arguments.length ? (id = _accessorsJs.required(x), stratify) : id;
    };
    stratify.parentId = function(x) {
        return arguments.length ? (parentId = _accessorsJs.required(x), stratify) : parentId;
    };
    return stratify;
};

},{"./accessors.js":"22Lor","./hierarchy/index.js":"bFZL8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4yd2C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./hierarchy/index.js");
function defaultSeparation(a, b) {
    return a.parent === b.parent ? 1 : 2;
}
// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }
// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
    var children = v.children;
    return children ? children[0] : v.t;
}
// This function works analogously to nextLeft.
function nextRight(v) {
    var children = v.children;
    return children ? children[children.length - 1] : v.t;
}
// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
}
// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while(--i >= 0){
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
    }
}
// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
    this._ = node;
    this.parent = null;
    this.children = null;
    this.A = null; // default ancestor
    this.a = this; // ancestor
    this.z = 0; // prelim
    this.m = 0; // mod
    this.c = 0; // change
    this.s = 0; // shift
    this.t = null; // thread
    this.i = i; // number
}
TreeNode.prototype = Object.create(_indexJs.Node.prototype);
function treeRoot(root) {
    var tree = new TreeNode(root, 0), node, nodes = [
        tree
    ], child, children, i, n;
    while(node = nodes.pop())if (children = node._.children) {
        node.children = new Array(n = children.length);
        for(i = n - 1; i >= 0; --i){
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
        }
    }
    (tree.parent = new TreeNode(null, 0)).children = [
        tree
    ];
    return tree;
}
exports.default = function() {
    var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
    function tree(root) {
        var t = treeRoot(root);
        // Compute the layout using Buchheim et al.’s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);
        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);
        else {
            var left = root, right = root, bottom = root;
            root.eachBefore(function(node) {
                if (node.x < left.x) left = node;
                if (node.x > right.x) right = node;
                if (node.depth > bottom.depth) bottom = node;
            });
            var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);
            root.eachBefore(function(node) {
                node.x = (node.x + tx) * kx;
                node.y = node.depth * ky;
            });
        }
        return root;
    }
    // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
    // applied recursively to the children of v, as well as the function
    // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
    // node v is placed to the midpoint of its outermost children.
    function firstWalk(v) {
        var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
        if (children) {
            executeShifts(v);
            var midpoint = (children[0].z + children[children.length - 1].z) / 2;
            if (w) {
                v.z = w.z + separation(v._, w._);
                v.m = v.z - midpoint;
            } else v.z = midpoint;
        } else if (w) v.z = w.z + separation(v._, w._);
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    // Computes all real x-coordinates by summing up the modifiers recursively.
    function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
    }
    // The core of the algorithm. Here, a new subtree is combined with the
    // previous subtrees. Threads are used to traverse the inside and outside
    // contours of the left and right subtree up to the highest common level. The
    // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
    // superscript o means outside and i means inside, the subscript - means left
    // subtree and + means right subtree. For summing up the modifiers along the
    // contour, we use respective variables si+, si-, so-, and so+. Whenever two
    // nodes of the inside contours conflict, we compute the left one of the
    // greatest uncommon ancestors using the function ANCESTOR and call MOVE
    // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
    // Finally, we add a new thread (if necessary).
    function apportion(v, w, ancestor) {
        if (w) {
            var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
            while(vim = nextRight(vim), vip = nextLeft(vip), vim && vip){
                vom = nextLeft(vom);
                vop = nextRight(vop);
                vop.a = v;
                shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                if (shift > 0) {
                    moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
                    sip += shift;
                    sop += shift;
                }
                sim += vim.m;
                sip += vip.m;
                som += vom.m;
                sop += vop.m;
            }
            if (vim && !nextRight(vop)) {
                vop.t = vim;
                vop.m += sim - sop;
            }
            if (vip && !nextLeft(vom)) {
                vom.t = vip;
                vom.m += sip - som;
                ancestor = v;
            }
        }
        return ancestor;
    }
    function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
    }
    tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
    };
    tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [
            dx,
            dy
        ];
    };
    tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [
            dx,
            dy
        ] : null;
    };
    return tree;
};

},{"./hierarchy/index.js":"bFZL8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aZ8ZK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _roundJs = require("./round.js");
var _roundJsDefault = parcelHelpers.interopDefault(_roundJs);
var _squarifyJs = require("./squarify.js");
var _squarifyJsDefault = parcelHelpers.interopDefault(_squarifyJs);
var _accessorsJs = require("../accessors.js");
var _constantJs = require("../constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
exports.default = function() {
    var tile = _squarifyJsDefault.default, round = false, dx = 1, dy = 1, paddingStack = [
        0
    ], paddingInner = _constantJs.constantZero, paddingTop = _constantJs.constantZero, paddingRight = _constantJs.constantZero, paddingBottom = _constantJs.constantZero, paddingLeft = _constantJs.constantZero;
    function treemap(root) {
        root.x0 = root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [
            0
        ];
        if (round) root.eachBefore(_roundJsDefault.default);
        return root;
    }
    function positionNode(node) {
        var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
            p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
            x0 += paddingLeft(node) - p;
            y0 += paddingTop(node) - p;
            x1 -= paddingRight(node) - p;
            y1 -= paddingBottom(node) - p;
            if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
            if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
            tile(node, x0, y0, x1, y1);
        }
    }
    treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
    };
    treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [
            dx,
            dy
        ];
    };
    treemap.tile = function(x) {
        return arguments.length ? (tile = _accessorsJs.required(x), treemap) : tile;
    };
    treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
    };
    treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : _constantJsDefault.default(+x), treemap) : paddingInner;
    };
    treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
    };
    treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : _constantJsDefault.default(+x), treemap) : paddingTop;
    };
    treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : _constantJsDefault.default(+x), treemap) : paddingRight;
    };
    treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : _constantJsDefault.default(+x), treemap) : paddingBottom;
    };
    treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : _constantJsDefault.default(+x), treemap) : paddingLeft;
    };
    return treemap;
};

},{"./round.js":"6GfK5","./squarify.js":"ctwRB","../accessors.js":"22Lor","../constant.js":"it5Dd","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ctwRB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "phi", ()=>phi
);
parcelHelpers.export(exports, "squarifyRatio", ()=>squarifyRatio
);
var _diceJs = require("./dice.js");
var _diceJsDefault = parcelHelpers.interopDefault(_diceJs);
var _sliceJs = require("./slice.js");
var _sliceJsDefault = parcelHelpers.interopDefault(_sliceJs);
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
    var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
    while(i0 < n){
        dx = x1 - x0, dy = y1 - y0;
        // Find the next non-empty node.
        do sumValue = nodes[i1++].value;
        while (!sumValue && i1 < n)
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);
        // Keep adding nodes while the aspect ratio maintains or improves.
        for(; i1 < n; ++i1){
            sumValue += nodeValue = nodes[i1].value;
            if (nodeValue < minValue) minValue = nodeValue;
            if (nodeValue > maxValue) maxValue = nodeValue;
            beta = sumValue * sumValue * alpha;
            newRatio = Math.max(maxValue / beta, beta / minValue);
            if (newRatio > minRatio) {
                sumValue -= nodeValue;
                break;
            }
            minRatio = newRatio;
        }
        // Position and record the row orientation.
        rows.push(row = {
            value: sumValue,
            dice: dx < dy,
            children: nodes.slice(i0, i1)
        });
        if (row.dice) _diceJsDefault.default(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else _sliceJsDefault.default(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
    }
    return rows;
}
exports.default = (function custom(ratio) {
    function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
    }
    squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
    };
    return squarify;
})(phi);

},{"./dice.js":"97Wyc","./slice.js":"ewDPE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ewDPE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(parent, x0, y0, x1, y1) {
    var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
    while(++i < n){
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fDGjN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(parent, x01, y01, x11, y11) {
    var nodes = parent.children, i1, n = nodes.length, sum, sums = new Array(n + 1);
    for(sums[0] = sum = i1 = 0; i1 < n; ++i1)sums[i1 + 1] = sum += nodes[i1].value;
    partition(0, n, parent.value, x01, y01, x11, y11);
    function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
            var node = nodes[i];
            node.x0 = x0, node.y0 = y0;
            node.x1 = x1, node.y1 = y1;
            return;
        }
        var valueOffset = sums[i], valueTarget = value / 2 + valueOffset, k = i + 1, hi = j - 1;
        while(k < hi){
            var mid = k + hi >>> 1;
            if (sums[mid] < valueTarget) k = mid + 1;
            else hi = mid;
        }
        if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) --k;
        var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;
        if (x1 - x0 > y1 - y0) {
            var xk = (x0 * valueRight + x1 * valueLeft) / value;
            partition(i, k, valueLeft, x0, y0, xk, y1);
            partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
            var yk = (y0 * valueRight + y1 * valueLeft) / value;
            partition(i, k, valueLeft, x0, y0, x1, yk);
            partition(k, j, valueRight, x0, yk, x1, y1);
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2icK7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _diceJs = require("./dice.js");
var _diceJsDefault = parcelHelpers.interopDefault(_diceJs);
var _sliceJs = require("./slice.js");
var _sliceJsDefault = parcelHelpers.interopDefault(_sliceJs);
exports.default = function(parent, x0, y0, x1, y1) {
    (parent.depth & 1 ? _sliceJsDefault.default : _diceJsDefault.default)(parent, x0, y0, x1, y1);
};

},{"./dice.js":"97Wyc","./slice.js":"ewDPE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3Fdan":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _diceJs = require("./dice.js");
var _diceJsDefault = parcelHelpers.interopDefault(_diceJs);
var _sliceJs = require("./slice.js");
var _sliceJsDefault = parcelHelpers.interopDefault(_sliceJs);
var _squarifyJs = require("./squarify.js");
exports.default = (function custom(ratio) {
    function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && rows.ratio === ratio) {
            var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value;
            while(++j < m){
                row = rows[j], nodes = row.children;
                for(i = row.value = 0, n = nodes.length; i < n; ++i)row.value += nodes[i].value;
                if (row.dice) _diceJsDefault.default(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
                else _sliceJsDefault.default(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
                value -= row.value;
            }
        } else {
            parent._squarify = rows = _squarifyJs.squarifyRatio(ratio, parent, x0, y0, x1, y1);
            rows.ratio = ratio;
        }
    }
    resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
    };
    return resquarify;
})(_squarifyJs.phi);

},{"./dice.js":"97Wyc","./slice.js":"ewDPE","./squarify.js":"ctwRB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6ide9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "polygonArea", ()=>_areaJsDefault.default
);
parcelHelpers.export(exports, "polygonCentroid", ()=>_centroidJsDefault.default
);
parcelHelpers.export(exports, "polygonHull", ()=>_hullJsDefault.default
);
parcelHelpers.export(exports, "polygonContains", ()=>_containsJsDefault.default
);
parcelHelpers.export(exports, "polygonLength", ()=>_lengthJsDefault.default
);
var _areaJs = require("./area.js");
var _areaJsDefault = parcelHelpers.interopDefault(_areaJs);
var _centroidJs = require("./centroid.js");
var _centroidJsDefault = parcelHelpers.interopDefault(_centroidJs);
var _hullJs = require("./hull.js");
var _hullJsDefault = parcelHelpers.interopDefault(_hullJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _lengthJs = require("./length.js");
var _lengthJsDefault = parcelHelpers.interopDefault(_lengthJs);

},{"./area.js":"edQIO","./centroid.js":"3mzYk","./hull.js":"d1T2A","./contains.js":"fdyBE","./length.js":"4Ux5Q","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"edQIO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(polygon) {
    var i = -1, n = polygon.length, a, b = polygon[n - 1], area = 0;
    while(++i < n){
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
    }
    return area / 2;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3mzYk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(polygon) {
    var i = -1, n = polygon.length, x = 0, y = 0, a, b = polygon[n - 1], c, k = 0;
    while(++i < n){
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
    }
    return k *= 3, [
        x / k,
        y / k
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"d1T2A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _crossJs = require("./cross.js");
var _crossJsDefault = parcelHelpers.interopDefault(_crossJs);
function lexicographicOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
}
// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
    var n = points.length, indexes = [
        0,
        1
    ], size = 2;
    for(var i = 2; i < n; ++i){
        while(size > 1 && _crossJsDefault.default(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0)--size;
        indexes[size++] = i;
    }
    return indexes.slice(0, size); // remove popped points
}
exports.default = function(points) {
    if ((n = points.length) < 3) return null;
    var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
    for(i = 0; i < n; ++i)sortedPoints[i] = [
        +points[i][0],
        +points[i][1],
        i
    ];
    sortedPoints.sort(lexicographicOrder);
    for(i = 0; i < n; ++i)flippedPoints[i] = [
        sortedPoints[i][0],
        -sortedPoints[i][1]
    ];
    var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
    // Construct the hull polygon, removing possible duplicate endpoints.
    var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull = [];
    // Add upper hull in right-to-l order.
    // Then add lower hull in left-to-right order.
    for(i = upperIndexes.length - 1; i >= 0; --i)hull.push(points[sortedPoints[upperIndexes[i]][2]]);
    for(i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)hull.push(points[sortedPoints[lowerIndexes[i]][2]]);
    return hull;
};

},{"./cross.js":"1tCF3","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1tCF3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fdyBE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(polygon, point) {
    var n = polygon.length, p = polygon[n - 1], x = point[0], y = point[1], x0 = p[0], y0 = p[1], x1, y1, inside = false;
    for(var i = 0; i < n; ++i){
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) inside = !inside;
        x0 = x1, y0 = y1;
    }
    return inside;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4Ux5Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(polygon) {
    var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
    while(++i < n){
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.sqrt(xa * xa + ya * ya);
    }
    return perimeter;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dyiSs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "randomUniform", ()=>_uniformDefault.default
);
parcelHelpers.export(exports, "randomNormal", ()=>_normalDefault.default
);
parcelHelpers.export(exports, "randomLogNormal", ()=>_logNormalDefault.default
);
parcelHelpers.export(exports, "randomBates", ()=>_batesDefault.default
);
parcelHelpers.export(exports, "randomIrwinHall", ()=>_irwinHallDefault.default
);
parcelHelpers.export(exports, "randomExponential", ()=>_exponentialDefault.default
);
var _uniform = require("./uniform");
var _uniformDefault = parcelHelpers.interopDefault(_uniform);
var _normal = require("./normal");
var _normalDefault = parcelHelpers.interopDefault(_normal);
var _logNormal = require("./logNormal");
var _logNormalDefault = parcelHelpers.interopDefault(_logNormal);
var _bates = require("./bates");
var _batesDefault = parcelHelpers.interopDefault(_bates);
var _irwinHall = require("./irwinHall");
var _irwinHallDefault = parcelHelpers.interopDefault(_irwinHall);
var _exponential = require("./exponential");
var _exponentialDefault = parcelHelpers.interopDefault(_exponential);

},{"./uniform":"6wS9J","./normal":"iSmGE","./logNormal":"iezy5","./bates":"eUReP","./irwinHall":"1l2yW","./exponential":"2H1Tc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6wS9J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defaultSource = require("./defaultSource");
var _defaultSourceDefault = parcelHelpers.interopDefault(_defaultSource);
exports.default = (function sourceRandomUniform(source) {
    function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
            return source() * max + min;
        };
    }
    randomUniform.source = sourceRandomUniform;
    return randomUniform;
})(_defaultSourceDefault.default);

},{"./defaultSource":"b2Wwg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"b2Wwg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
    return Math.random();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iSmGE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defaultSource = require("./defaultSource");
var _defaultSourceDefault = parcelHelpers.interopDefault(_defaultSource);
exports.default = (function sourceRandomNormal(source) {
    function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
            var y;
            // If available, use the second previously-generated uniform random.
            if (x != null) y = x, x = null;
            else do {
                x = source() * 2 - 1;
                y = source() * 2 - 1;
                r = x * x + y * y;
            }while (!r || r > 1)
            return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
    }
    randomNormal.source = sourceRandomNormal;
    return randomNormal;
})(_defaultSourceDefault.default);

},{"./defaultSource":"b2Wwg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iezy5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defaultSource = require("./defaultSource");
var _defaultSourceDefault = parcelHelpers.interopDefault(_defaultSource);
var _normal = require("./normal");
var _normalDefault = parcelHelpers.interopDefault(_normal);
exports.default = (function sourceRandomLogNormal(source) {
    function randomLogNormal() {
        var randomNormal = _normalDefault.default.source(source).apply(this, arguments);
        return function() {
            return Math.exp(randomNormal());
        };
    }
    randomLogNormal.source = sourceRandomLogNormal;
    return randomLogNormal;
})(_defaultSourceDefault.default);

},{"./defaultSource":"b2Wwg","./normal":"iSmGE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eUReP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defaultSource = require("./defaultSource");
var _defaultSourceDefault = parcelHelpers.interopDefault(_defaultSource);
var _irwinHall = require("./irwinHall");
var _irwinHallDefault = parcelHelpers.interopDefault(_irwinHall);
exports.default = (function sourceRandomBates(source) {
    function randomBates(n) {
        var randomIrwinHall = _irwinHallDefault.default.source(source)(n);
        return function() {
            return randomIrwinHall() / n;
        };
    }
    randomBates.source = sourceRandomBates;
    return randomBates;
})(_defaultSourceDefault.default);

},{"./defaultSource":"b2Wwg","./irwinHall":"1l2yW","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1l2yW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defaultSource = require("./defaultSource");
var _defaultSourceDefault = parcelHelpers.interopDefault(_defaultSource);
exports.default = (function sourceRandomIrwinHall(source) {
    function randomIrwinHall(n) {
        return function() {
            for(var sum = 0, i = 0; i < n; ++i)sum += source();
            return sum;
        };
    }
    randomIrwinHall.source = sourceRandomIrwinHall;
    return randomIrwinHall;
})(_defaultSourceDefault.default);

},{"./defaultSource":"b2Wwg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2H1Tc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defaultSource = require("./defaultSource");
var _defaultSourceDefault = parcelHelpers.interopDefault(_defaultSource);
exports.default = (function sourceRandomExponential(source) {
    function randomExponential(lambda) {
        return function() {
            return -Math.log(1 - source()) / lambda;
        };
    }
    randomExponential.source = sourceRandomExponential;
    return randomExponential;
})(_defaultSourceDefault.default);

},{"./defaultSource":"b2Wwg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hrwOn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scaleBand", ()=>_bandDefault.default
);
parcelHelpers.export(exports, "scalePoint", ()=>_band.point
);
parcelHelpers.export(exports, "scaleIdentity", ()=>_identityDefault.default
);
parcelHelpers.export(exports, "scaleLinear", ()=>_linearDefault.default
);
parcelHelpers.export(exports, "scaleLog", ()=>_logDefault.default
);
parcelHelpers.export(exports, "scaleSymlog", ()=>_symlogDefault.default
);
parcelHelpers.export(exports, "scaleOrdinal", ()=>_ordinalDefault.default
);
parcelHelpers.export(exports, "scaleImplicit", ()=>_ordinal.implicit
);
parcelHelpers.export(exports, "scalePow", ()=>_powDefault.default
);
parcelHelpers.export(exports, "scaleSqrt", ()=>_pow.sqrt
);
parcelHelpers.export(exports, "scaleQuantile", ()=>_quantileDefault.default
);
parcelHelpers.export(exports, "scaleQuantize", ()=>_quantizeDefault.default
);
parcelHelpers.export(exports, "scaleThreshold", ()=>_thresholdDefault.default
);
parcelHelpers.export(exports, "scaleTime", ()=>_timeDefault.default
);
parcelHelpers.export(exports, "scaleUtc", ()=>_utcTimeDefault.default
);
parcelHelpers.export(exports, "scaleSequential", ()=>_sequentialDefault.default
);
parcelHelpers.export(exports, "scaleSequentialLog", ()=>_sequential.sequentialLog
);
parcelHelpers.export(exports, "scaleSequentialPow", ()=>_sequential.sequentialPow
);
parcelHelpers.export(exports, "scaleSequentialSqrt", ()=>_sequential.sequentialSqrt
);
parcelHelpers.export(exports, "scaleSequentialSymlog", ()=>_sequential.sequentialSymlog
);
parcelHelpers.export(exports, "scaleSequentialQuantile", ()=>_sequentialQuantileDefault.default
);
parcelHelpers.export(exports, "scaleDiverging", ()=>_divergingDefault.default
);
parcelHelpers.export(exports, "scaleDivergingLog", ()=>_diverging.divergingLog
);
parcelHelpers.export(exports, "scaleDivergingPow", ()=>_diverging.divergingPow
);
parcelHelpers.export(exports, "scaleDivergingSqrt", ()=>_diverging.divergingSqrt
);
parcelHelpers.export(exports, "scaleDivergingSymlog", ()=>_diverging.divergingSymlog
);
parcelHelpers.export(exports, "tickFormat", ()=>_tickFormatDefault.default
);
var _band = require("./band");
var _bandDefault = parcelHelpers.interopDefault(_band);
var _identity = require("./identity");
var _identityDefault = parcelHelpers.interopDefault(_identity);
var _linear = require("./linear");
var _linearDefault = parcelHelpers.interopDefault(_linear);
var _log = require("./log");
var _logDefault = parcelHelpers.interopDefault(_log);
var _symlog = require("./symlog");
var _symlogDefault = parcelHelpers.interopDefault(_symlog);
var _ordinal = require("./ordinal");
var _ordinalDefault = parcelHelpers.interopDefault(_ordinal);
var _pow = require("./pow");
var _powDefault = parcelHelpers.interopDefault(_pow);
var _quantile = require("./quantile");
var _quantileDefault = parcelHelpers.interopDefault(_quantile);
var _quantize = require("./quantize");
var _quantizeDefault = parcelHelpers.interopDefault(_quantize);
var _threshold = require("./threshold");
var _thresholdDefault = parcelHelpers.interopDefault(_threshold);
var _time = require("./time");
var _timeDefault = parcelHelpers.interopDefault(_time);
var _utcTime = require("./utcTime");
var _utcTimeDefault = parcelHelpers.interopDefault(_utcTime);
var _sequential = require("./sequential");
var _sequentialDefault = parcelHelpers.interopDefault(_sequential);
var _sequentialQuantile = require("./sequentialQuantile");
var _sequentialQuantileDefault = parcelHelpers.interopDefault(_sequentialQuantile);
var _diverging = require("./diverging");
var _divergingDefault = parcelHelpers.interopDefault(_diverging);
var _tickFormat = require("./tickFormat");
var _tickFormatDefault = parcelHelpers.interopDefault(_tickFormat);

},{"./band":"jrhJj","./identity":"7A0m5","./linear":"iCJmQ","./log":"8gycm","./symlog":"etHgK","./ordinal":"16SNv","./pow":"kopvN","./quantile":"iT8CK","./quantize":"ec2AM","./threshold":"8jaMK","./time":"7jFE4","./utcTime":"jZmye","./sequential":"76Oio","./sequentialQuantile":"dMZ3i","./diverging":"3lkJJ","./tickFormat":"1dqFI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jrhJj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "point", ()=>point
);
var _d3Array = require("d3-array");
var _init = require("./init");
var _ordinal = require("./ordinal");
var _ordinalDefault = parcelHelpers.interopDefault(_ordinal);
function band() {
    var scale = _ordinalDefault.default().unknown(undefined), domain = scale.domain, ordinalRange = scale.range, range = [
        0,
        1
    ], step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
        var n = domain().length, reverse = range[1] < range[0], start = range[reverse - 0], stop = range[1 - reverse];
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = _d3Array.range(n).map(function(i) {
            return start + step * i;
        });
        return ordinalRange(reverse ? values.reverse() : values);
    }
    scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.range = function(_) {
        return arguments.length ? (range = [
            +_[0],
            +_[1]
        ], rescale()) : range.slice();
    };
    scale.rangeRound = function(_) {
        return range = [
            +_[0],
            +_[1]
        ], round = true, rescale();
    };
    scale.bandwidth = function() {
        return bandwidth;
    };
    scale.step = function() {
        return step;
    };
    scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
    };
    scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };
    scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };
    scale.copy = function() {
        return band(domain(), range).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return _init.initRange.apply(rescale(), arguments);
}
exports.default = band;
function pointish(scale) {
    var copy = scale.copy;
    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;
    scale.copy = function() {
        return pointish(copy());
    };
    return scale;
}
function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
}

},{"d3-array":"dclxS","./init":"76hF6","./ordinal":"16SNv","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"76hF6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initRange", ()=>initRange
);
parcelHelpers.export(exports, "initInterpolator", ()=>initInterpolator
);
function initRange(domain, range) {
    switch(arguments.length){
        case 0:
            break;
        case 1:
            this.range(domain);
            break;
        default:
            this.range(range).domain(domain);
            break;
    }
    return this;
}
function initInterpolator(domain, interpolator) {
    switch(arguments.length){
        case 0:
            break;
        case 1:
            this.interpolator(domain);
            break;
        default:
            this.interpolator(interpolator).domain(domain);
            break;
    }
    return this;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"16SNv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "implicit", ()=>implicit
);
var _d3Collection = require("d3-collection");
var _array = require("./array");
var _init = require("./init");
var implicit = {
    name: "implicit"
};
function ordinal() {
    var index = _d3Collection.map(), domain = [], range = [], unknown = implicit;
    function scale(d) {
        var key = d + "", i = index.get(key);
        if (!i) {
            if (unknown !== implicit) return unknown;
            index.set(key, i = domain.push(d));
        }
        return range[(i - 1) % range.length];
    }
    scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = _d3Collection.map();
        var i = -1, n = _.length, d, key;
        while(++i < n)if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
        return scale;
    };
    scale.range = function(_) {
        return arguments.length ? (range = _array.slice.call(_), scale) : range.slice();
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
    };
    _init.initRange.apply(scale, arguments);
    return scale;
}
exports.default = ordinal;

},{"d3-collection":"4zn9z","./array":"8IrMV","./init":"76hF6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8IrMV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "map", ()=>map
);
parcelHelpers.export(exports, "slice", ()=>slice
);
var array = Array.prototype;
var map = array.map;
var slice = array.slice;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7A0m5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _array = require("./array");
var _linear = require("./linear");
var _number = require("./number");
var _numberDefault = parcelHelpers.interopDefault(_number);
function identity(domain) {
    var unknown;
    function scale(x) {
        return isNaN(x = +x) ? unknown : x;
    }
    scale.invert = scale;
    scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = _array.map.call(_, _numberDefault.default), scale) : domain.slice();
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
        return identity(domain).unknown(unknown);
    };
    domain = arguments.length ? _array.map.call(domain, _numberDefault.default) : [
        0,
        1
    ];
    return _linear.linearish(scale);
}
exports.default = identity;

},{"./array":"8IrMV","./linear":"iCJmQ","./number":"1cJLd","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iCJmQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "linearish", ()=>linearish
);
var _d3Array = require("d3-array");
var _continuous = require("./continuous");
var _continuousDefault = parcelHelpers.interopDefault(_continuous);
var _init = require("./init");
var _tickFormat = require("./tickFormat");
var _tickFormatDefault = parcelHelpers.interopDefault(_tickFormat);
function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
        var d = domain();
        return _d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
        var d = domain();
        return _tickFormatDefault.default(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
        if (count == null) count = 10;
        var d = domain(), i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], step;
        if (stop < start) {
            step = start, start = stop, stop = step;
            step = i0, i0 = i1, i1 = step;
        }
        step = _d3Array.tickIncrement(start, stop, count);
        if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
            step = _d3Array.tickIncrement(start, stop, count);
        } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
            step = _d3Array.tickIncrement(start, stop, count);
        }
        if (step > 0) {
            d[i0] = Math.floor(start / step) * step;
            d[i1] = Math.ceil(stop / step) * step;
            domain(d);
        } else if (step < 0) {
            d[i0] = Math.ceil(start * step) / step;
            d[i1] = Math.floor(stop * step) / step;
            domain(d);
        }
        return scale;
    };
    return scale;
}
function linear() {
    var scale = _continuousDefault.default(_continuous.identity, _continuous.identity);
    scale.copy = function() {
        return _continuous.copy(scale, linear());
    };
    _init.initRange.apply(scale, arguments);
    return linearish(scale);
}
exports.default = linear;

},{"d3-array":"dclxS","./continuous":"btLMJ","./init":"76hF6","./tickFormat":"1dqFI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"btLMJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity
);
parcelHelpers.export(exports, "copy", ()=>copy
);
parcelHelpers.export(exports, "transformer", ()=>transformer
);
var _d3Array = require("d3-array");
var _d3Interpolate = require("d3-interpolate");
var _array = require("./array");
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var _number = require("./number");
var _numberDefault = parcelHelpers.interopDefault(_number);
var unit = [
    0,
    1
];
function identity(x) {
    return x;
}
function normalize(a, b) {
    return (b -= a = +a) ? function(x) {
        return (x - a) / b;
    } : _constantDefault.default(isNaN(b) ? NaN : 0.5);
}
function clamper(domain) {
    var a = domain[0], b = domain[domain.length - 1], t;
    if (a > b) t = a, a = b, b = t;
    return function(x) {
        return Math.max(a, Math.min(b, x));
    };
}
// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x) {
        return r0(d0(x));
    };
}
function polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    // Reverse descending domains.
    if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
    }
    while(++i < j){
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
    }
    return function(x) {
        var i = _d3Array.bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
    };
}
function copy(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
    var domain = unit, range = unit, interpolate = _d3Interpolate.interpolate, transform, untransform, unknown, clamp = identity, piecewise, output, input;
    function rescale() {
        piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
        output = input = null;
        return scale;
    }
    function scale(x) {
        return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
    }
    scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), _d3Interpolate.interpolateNumber)))(y)));
    };
    scale.domain = function(_) {
        return arguments.length ? (domain = _array.map.call(_, _numberDefault.default), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
    };
    scale.range = function(_) {
        return arguments.length ? (range = _array.slice.call(_), rescale()) : range.slice();
    };
    scale.rangeRound = function(_) {
        return range = _array.slice.call(_), interpolate = _d3Interpolate.interpolateRound, rescale();
    };
    scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
    };
    scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t, u) {
        transform = t, untransform = u;
        return rescale();
    };
}
function continuous(transform, untransform) {
    return transformer()(transform, untransform);
}
exports.default = continuous;

},{"d3-array":"dclxS","d3-interpolate":"e7XwA","./array":"8IrMV","./constant":"a5Wmk","./number":"1cJLd","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"a5Wmk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1cJLd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return +x;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1dqFI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Array = require("d3-array");
var _d3Format = require("d3-format");
exports.default = function(start, stop, count, specifier) {
    var step = _d3Array.tickStep(start, stop, count), precision;
    specifier = _d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
    switch(specifier.type){
        case "s":
            var value = Math.max(Math.abs(start), Math.abs(stop));
            if (specifier.precision == null && !isNaN(precision = _d3Format.precisionPrefix(step, value))) specifier.precision = precision;
            return _d3Format.formatPrefix(specifier, value);
        case "":
        case "e":
        case "g":
        case "p":
        case "r":
            if (specifier.precision == null && !isNaN(precision = _d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
            break;
        case "f":
        case "%":
            if (specifier.precision == null && !isNaN(precision = _d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
            break;
    }
    return _d3Format.format(specifier);
};

},{"d3-array":"dclxS","d3-format":"hzInr","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8gycm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loggish", ()=>loggish
);
var _d3Array = require("d3-array");
var _d3Format = require("d3-format");
var _nice = require("./nice");
var _niceDefault = parcelHelpers.interopDefault(_nice);
var _continuous = require("./continuous");
var _init = require("./init");
function transformLog(x) {
    return Math.log(x);
}
function transformExp(x) {
    return Math.exp(x);
}
function transformLogn(x) {
    return -Math.log(-x);
}
function transformExpn(x) {
    return -Math.exp(-x);
}
function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}
function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : function(x) {
        return Math.pow(base, x);
    };
}
function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function(x) {
        return Math.log(x) / base;
    });
}
function reflect(f) {
    return function(x) {
        return -f(-x);
    };
}
function loggish(transform) {
    var scale = transform(transformLog, transformExp), domain = scale.domain, base = 10, logs, pows;
    function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
            logs = reflect(logs), pows = reflect(pows);
            transform(transformLogn, transformExpn);
        } else transform(transformLog, transformExp);
        return scale;
    }
    scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
    };
    scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.ticks = function(count) {
        var d = domain(), u = d[0], v = d[d.length - 1], r;
        if (r = v < u) i = u, u = v, v = i;
        var i = logs(u), j = logs(v), p, k, t, n = count == null ? 10 : +count, z = [];
        if (!(base % 1) && j - i < n) {
            i = Math.round(i) - 1, j = Math.round(j) + 1;
            if (u > 0) for(; i < j; ++i)for(k = 1, p = pows(i); k < base; ++k){
                t = p * k;
                if (t < u) continue;
                if (t > v) break;
                z.push(t);
            }
            else for(; i < j; ++i)for(k = base - 1, p = pows(i); k >= 1; --k){
                t = p * k;
                if (t < u) continue;
                if (t > v) break;
                z.push(t);
            }
        } else z = _d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
        return r ? z.reverse() : z;
    };
    scale.tickFormat = function(count, specifier) {
        if (specifier == null) specifier = base === 10 ? ".0e" : ",";
        if (typeof specifier !== "function") specifier = _d3Format.format(specifier);
        if (count === Infinity) return specifier;
        if (count == null) count = 10;
        var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return function(d) {
            var i = d / pows(Math.round(logs(d)));
            if (i * base < base - 0.5) i *= base;
            return i <= k ? specifier(d) : "";
        };
    };
    scale.nice = function() {
        return domain(_niceDefault.default(domain(), {
            floor: function(x) {
                return pows(Math.floor(logs(x)));
            },
            ceil: function(x) {
                return pows(Math.ceil(logs(x)));
            }
        }));
    };
    return scale;
}
function log() {
    var scale = loggish(_continuous.transformer()).domain([
        1,
        10
    ]);
    scale.copy = function() {
        return _continuous.copy(scale, log()).base(scale.base());
    };
    _init.initRange.apply(scale, arguments);
    return scale;
}
exports.default = log;

},{"d3-array":"dclxS","d3-format":"hzInr","./nice":"jIY6Z","./continuous":"btLMJ","./init":"76hF6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jIY6Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(domain, interval) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
    if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"etHgK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "symlogish", ()=>symlogish
);
var _linear = require("./linear");
var _continuous = require("./continuous");
var _init = require("./init");
function transformSymlog(c) {
    return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
    };
}
function transformSymexp(c) {
    return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
    };
}
function symlogish(transform) {
    var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));
    scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
    };
    return _linear.linearish(scale);
}
function symlog() {
    var scale = symlogish(_continuous.transformer());
    scale.copy = function() {
        return _continuous.copy(scale, symlog()).constant(scale.constant());
    };
    return _init.initRange.apply(scale, arguments);
}
exports.default = symlog;

},{"./linear":"iCJmQ","./continuous":"btLMJ","./init":"76hF6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kopvN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "powish", ()=>powish
);
parcelHelpers.export(exports, "sqrt", ()=>sqrt
);
var _linear = require("./linear");
var _continuous = require("./continuous");
var _init = require("./init");
function transformPow(exponent) {
    return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
    };
}
function transformSqrt(x) {
    return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}
function transformSquare(x) {
    return x < 0 ? -x * x : x * x;
}
function powish(transform) {
    var scale = transform(_continuous.identity, _continuous.identity), exponent = 1;
    function rescale() {
        return exponent === 1 ? transform(_continuous.identity, _continuous.identity) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
    }
    scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
    };
    return _linear.linearish(scale);
}
function pow() {
    var scale = powish(_continuous.transformer());
    scale.copy = function() {
        return _continuous.copy(scale, pow()).exponent(scale.exponent());
    };
    _init.initRange.apply(scale, arguments);
    return scale;
}
exports.default = pow;
function sqrt() {
    return pow.apply(null, arguments).exponent(0.5);
}

},{"./linear":"iCJmQ","./continuous":"btLMJ","./init":"76hF6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iT8CK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Array = require("d3-array");
var _array = require("./array");
var _init = require("./init");
function quantile() {
    var domain = [], range = [], thresholds = [], unknown;
    function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while(++i < n)thresholds[i - 1] = _d3Array.quantile(domain, i / n);
        return scale;
    }
    function scale(x) {
        return isNaN(x = +x) ? unknown : range[_d3Array.bisect(thresholds, x)];
    }
    scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [
            NaN,
            NaN
        ] : [
            i > 0 ? thresholds[i - 1] : domain[0],
            i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
    };
    scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for(var i = 0, n = _.length, d; i < n; ++i)if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(_d3Array.ascending);
        return rescale();
    };
    scale.range = function(_) {
        return arguments.length ? (range = _array.slice.call(_), rescale()) : range.slice();
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.quantiles = function() {
        return thresholds.slice();
    };
    scale.copy = function() {
        return quantile().domain(domain).range(range).unknown(unknown);
    };
    return _init.initRange.apply(scale, arguments);
}
exports.default = quantile;

},{"d3-array":"dclxS","./array":"8IrMV","./init":"76hF6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ec2AM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Array = require("d3-array");
var _array = require("./array");
var _linear = require("./linear");
var _init = require("./init");
function quantize() {
    var x0 = 0, x1 = 1, n = 1, domain = [
        0.5
    ], range = [
        0,
        1
    ], unknown;
    function scale(x) {
        return x <= x ? range[_d3Array.bisect(domain, x, 0, n)] : unknown;
    }
    function rescale() {
        var i = -1;
        domain = new Array(n);
        while(++i < n)domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
    }
    scale.domain = function(_) {
        return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [
            x0,
            x1
        ];
    };
    scale.range = function(_) {
        return arguments.length ? (n = (range = _array.slice.call(_)).length - 1, rescale()) : range.slice();
    };
    scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [
            NaN,
            NaN
        ] : i < 1 ? [
            x0,
            domain[0]
        ] : i >= n ? [
            domain[n - 1],
            x1
        ] : [
            domain[i - 1],
            domain[i]
        ];
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
    };
    scale.thresholds = function() {
        return domain.slice();
    };
    scale.copy = function() {
        return quantize().domain([
            x0,
            x1
        ]).range(range).unknown(unknown);
    };
    return _init.initRange.apply(_linear.linearish(scale), arguments);
}
exports.default = quantize;

},{"d3-array":"dclxS","./array":"8IrMV","./linear":"iCJmQ","./init":"76hF6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8jaMK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Array = require("d3-array");
var _array = require("./array");
var _init = require("./init");
function threshold() {
    var domain = [
        0.5
    ], range = [
        0,
        1
    ], unknown, n = 1;
    function scale(x) {
        return x <= x ? range[_d3Array.bisect(domain, x, 0, n)] : unknown;
    }
    scale.domain = function(_) {
        return arguments.length ? (domain = _array.slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
    };
    scale.range = function(_) {
        return arguments.length ? (range = _array.slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
    };
    scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [
            domain[i - 1],
            domain[i]
        ];
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
        return threshold().domain(domain).range(range).unknown(unknown);
    };
    return _init.initRange.apply(scale, arguments);
}
exports.default = threshold;

},{"d3-array":"dclxS","./array":"8IrMV","./init":"76hF6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7jFE4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calendar", ()=>calendar
);
var _d3Array = require("d3-array");
var _d3Time = require("d3-time");
var _d3TimeFormat = require("d3-time-format");
var _array = require("./array");
var _continuous = require("./continuous");
var _continuousDefault = parcelHelpers.interopDefault(_continuous);
var _init = require("./init");
var _nice = require("./nice");
var _niceDefault = parcelHelpers.interopDefault(_nice);
var durationSecond = 1000, durationMinute = durationSecond * 60, durationHour = durationMinute * 60, durationDay = durationHour * 24, durationWeek = durationDay * 7, durationMonth = durationDay * 30, durationYear = durationDay * 365;
function date1(t) {
    return new Date(t);
}
function number(t) {
    return t instanceof Date ? +t : +new Date(+t);
}
function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
    var scale = _continuousDefault.default(_continuous.identity, _continuous.identity), invert = scale.invert, domain = scale.domain;
    var formatMillisecond = format(".%L"), formatSecond = format(":%S"), formatMinute = format("%I:%M"), formatHour = format("%I %p"), formatDay = format("%a %d"), formatWeek = format("%b %d"), formatMonth = format("%B"), formatYear = format("%Y");
    var tickIntervals = [
        [
            second,
            1,
            durationSecond
        ],
        [
            second,
            5,
            5 * durationSecond
        ],
        [
            second,
            15,
            15 * durationSecond
        ],
        [
            second,
            30,
            30 * durationSecond
        ],
        [
            minute,
            1,
            durationMinute
        ],
        [
            minute,
            5,
            5 * durationMinute
        ],
        [
            minute,
            15,
            15 * durationMinute
        ],
        [
            minute,
            30,
            30 * durationMinute
        ],
        [
            hour,
            1,
            durationHour
        ],
        [
            hour,
            3,
            3 * durationHour
        ],
        [
            hour,
            6,
            6 * durationHour
        ],
        [
            hour,
            12,
            12 * durationHour
        ],
        [
            day,
            1,
            durationDay
        ],
        [
            day,
            2,
            2 * durationDay
        ],
        [
            week,
            1,
            durationWeek
        ],
        [
            month,
            1,
            durationMonth
        ],
        [
            month,
            3,
            3 * durationMonth
        ],
        [
            year,
            1,
            durationYear
        ]
    ];
    function tickFormat(date) {
        return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
    }
    function tickInterval(interval, start, stop, step) {
        if (interval == null) interval = 10;
        // If a desired tick count is specified, pick a reasonable tick interval
        // based on the extent of the domain and a rough estimate of tick size.
        // Otherwise, assume interval is already a time interval and use it.
        if (typeof interval === "number") {
            var target = Math.abs(stop - start) / interval, i1 = _d3Array.bisector(function(i) {
                return i[2];
            }).right(tickIntervals, target);
            if (i1 === tickIntervals.length) {
                step = _d3Array.tickStep(start / durationYear, stop / durationYear, interval);
                interval = year;
            } else if (i1) {
                i1 = tickIntervals[target / tickIntervals[i1 - 1][2] < tickIntervals[i1][2] / target ? i1 - 1 : i1];
                step = i1[1];
                interval = i1[0];
            } else {
                step = Math.max(_d3Array.tickStep(start, stop, interval), 1);
                interval = millisecond;
            }
        }
        return step == null ? interval : interval.every(step);
    }
    scale.invert = function(y) {
        return new Date(invert(y));
    };
    scale.domain = function(_) {
        return arguments.length ? domain(_array.map.call(_, number)) : domain().map(date1);
    };
    scale.ticks = function(interval, step) {
        var d = domain(), t0 = d[0], t1 = d[d.length - 1], r = t1 < t0, t;
        if (r) t = t0, t0 = t1, t1 = t;
        t = tickInterval(interval, t0, t1, step);
        t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
        return r ? t.reverse() : t;
    };
    scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
    };
    scale.nice = function(interval, step) {
        var d = domain();
        return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(_niceDefault.default(d, interval)) : scale;
    };
    scale.copy = function() {
        return _continuous.copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
    };
    return scale;
}
exports.default = function() {
    return _init.initRange.apply(calendar(_d3Time.timeYear, _d3Time.timeMonth, _d3Time.timeWeek, _d3Time.timeDay, _d3Time.timeHour, _d3Time.timeMinute, _d3Time.timeSecond, _d3Time.timeMillisecond, _d3TimeFormat.timeFormat).domain([
        new Date(2000, 0, 1),
        new Date(2000, 0, 2)
    ]), arguments);
};

},{"d3-array":"dclxS","d3-time":"lTNsW","d3-time-format":"ioDBG","./array":"8IrMV","./continuous":"btLMJ","./init":"76hF6","./nice":"jIY6Z","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lTNsW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeInterval", ()=>_intervalJsDefault.default
);
parcelHelpers.export(exports, "timeMillisecond", ()=>_millisecondJsDefault.default
);
parcelHelpers.export(exports, "timeMilliseconds", ()=>_millisecondJs.milliseconds
);
parcelHelpers.export(exports, "utcMillisecond", ()=>_millisecondJsDefault.default
);
parcelHelpers.export(exports, "utcMilliseconds", ()=>_millisecondJs.milliseconds
);
parcelHelpers.export(exports, "timeSecond", ()=>_secondJsDefault.default
);
parcelHelpers.export(exports, "timeSeconds", ()=>_secondJs.seconds
);
parcelHelpers.export(exports, "utcSecond", ()=>_secondJsDefault.default
);
parcelHelpers.export(exports, "utcSeconds", ()=>_secondJs.seconds
);
parcelHelpers.export(exports, "timeMinute", ()=>_minuteJsDefault.default
);
parcelHelpers.export(exports, "timeMinutes", ()=>_minuteJs.minutes
);
parcelHelpers.export(exports, "timeHour", ()=>_hourJsDefault.default
);
parcelHelpers.export(exports, "timeHours", ()=>_hourJs.hours
);
parcelHelpers.export(exports, "timeDay", ()=>_dayJsDefault.default
);
parcelHelpers.export(exports, "timeDays", ()=>_dayJs.days
);
parcelHelpers.export(exports, "timeWeek", ()=>_weekJs.sunday
);
parcelHelpers.export(exports, "timeWeeks", ()=>_weekJs.sundays
);
parcelHelpers.export(exports, "timeSunday", ()=>_weekJs.sunday
);
parcelHelpers.export(exports, "timeSundays", ()=>_weekJs.sundays
);
parcelHelpers.export(exports, "timeMonday", ()=>_weekJs.monday
);
parcelHelpers.export(exports, "timeMondays", ()=>_weekJs.mondays
);
parcelHelpers.export(exports, "timeTuesday", ()=>_weekJs.tuesday
);
parcelHelpers.export(exports, "timeTuesdays", ()=>_weekJs.tuesdays
);
parcelHelpers.export(exports, "timeWednesday", ()=>_weekJs.wednesday
);
parcelHelpers.export(exports, "timeWednesdays", ()=>_weekJs.wednesdays
);
parcelHelpers.export(exports, "timeThursday", ()=>_weekJs.thursday
);
parcelHelpers.export(exports, "timeThursdays", ()=>_weekJs.thursdays
);
parcelHelpers.export(exports, "timeFriday", ()=>_weekJs.friday
);
parcelHelpers.export(exports, "timeFridays", ()=>_weekJs.fridays
);
parcelHelpers.export(exports, "timeSaturday", ()=>_weekJs.saturday
);
parcelHelpers.export(exports, "timeSaturdays", ()=>_weekJs.saturdays
);
parcelHelpers.export(exports, "timeMonth", ()=>_monthJsDefault.default
);
parcelHelpers.export(exports, "timeMonths", ()=>_monthJs.months
);
parcelHelpers.export(exports, "timeYear", ()=>_yearJsDefault.default
);
parcelHelpers.export(exports, "timeYears", ()=>_yearJs.years
);
parcelHelpers.export(exports, "utcMinute", ()=>_utcMinuteJsDefault.default
);
parcelHelpers.export(exports, "utcMinutes", ()=>_utcMinuteJs.utcMinutes
);
parcelHelpers.export(exports, "utcHour", ()=>_utcHourJsDefault.default
);
parcelHelpers.export(exports, "utcHours", ()=>_utcHourJs.utcHours
);
parcelHelpers.export(exports, "utcDay", ()=>_utcDayJsDefault.default
);
parcelHelpers.export(exports, "utcDays", ()=>_utcDayJs.utcDays
);
parcelHelpers.export(exports, "utcWeek", ()=>_utcWeekJs.utcSunday
);
parcelHelpers.export(exports, "utcWeeks", ()=>_utcWeekJs.utcSundays
);
parcelHelpers.export(exports, "utcSunday", ()=>_utcWeekJs.utcSunday
);
parcelHelpers.export(exports, "utcSundays", ()=>_utcWeekJs.utcSundays
);
parcelHelpers.export(exports, "utcMonday", ()=>_utcWeekJs.utcMonday
);
parcelHelpers.export(exports, "utcMondays", ()=>_utcWeekJs.utcMondays
);
parcelHelpers.export(exports, "utcTuesday", ()=>_utcWeekJs.utcTuesday
);
parcelHelpers.export(exports, "utcTuesdays", ()=>_utcWeekJs.utcTuesdays
);
parcelHelpers.export(exports, "utcWednesday", ()=>_utcWeekJs.utcWednesday
);
parcelHelpers.export(exports, "utcWednesdays", ()=>_utcWeekJs.utcWednesdays
);
parcelHelpers.export(exports, "utcThursday", ()=>_utcWeekJs.utcThursday
);
parcelHelpers.export(exports, "utcThursdays", ()=>_utcWeekJs.utcThursdays
);
parcelHelpers.export(exports, "utcFriday", ()=>_utcWeekJs.utcFriday
);
parcelHelpers.export(exports, "utcFridays", ()=>_utcWeekJs.utcFridays
);
parcelHelpers.export(exports, "utcSaturday", ()=>_utcWeekJs.utcSaturday
);
parcelHelpers.export(exports, "utcSaturdays", ()=>_utcWeekJs.utcSaturdays
);
parcelHelpers.export(exports, "utcMonth", ()=>_utcMonthJsDefault.default
);
parcelHelpers.export(exports, "utcMonths", ()=>_utcMonthJs.utcMonths
);
parcelHelpers.export(exports, "utcYear", ()=>_utcYearJsDefault.default
);
parcelHelpers.export(exports, "utcYears", ()=>_utcYearJs.utcYears
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _millisecondJs = require("./millisecond.js");
var _millisecondJsDefault = parcelHelpers.interopDefault(_millisecondJs);
var _secondJs = require("./second.js");
var _secondJsDefault = parcelHelpers.interopDefault(_secondJs);
var _minuteJs = require("./minute.js");
var _minuteJsDefault = parcelHelpers.interopDefault(_minuteJs);
var _hourJs = require("./hour.js");
var _hourJsDefault = parcelHelpers.interopDefault(_hourJs);
var _dayJs = require("./day.js");
var _dayJsDefault = parcelHelpers.interopDefault(_dayJs);
var _weekJs = require("./week.js");
var _monthJs = require("./month.js");
var _monthJsDefault = parcelHelpers.interopDefault(_monthJs);
var _yearJs = require("./year.js");
var _yearJsDefault = parcelHelpers.interopDefault(_yearJs);
var _utcMinuteJs = require("./utcMinute.js");
var _utcMinuteJsDefault = parcelHelpers.interopDefault(_utcMinuteJs);
var _utcHourJs = require("./utcHour.js");
var _utcHourJsDefault = parcelHelpers.interopDefault(_utcHourJs);
var _utcDayJs = require("./utcDay.js");
var _utcDayJsDefault = parcelHelpers.interopDefault(_utcDayJs);
var _utcWeekJs = require("./utcWeek.js");
var _utcMonthJs = require("./utcMonth.js");
var _utcMonthJsDefault = parcelHelpers.interopDefault(_utcMonthJs);
var _utcYearJs = require("./utcYear.js");
var _utcYearJsDefault = parcelHelpers.interopDefault(_utcYearJs);

},{"./interval.js":"1URbY","./millisecond.js":"66wfU","./second.js":"5eoNm","./minute.js":"aOzRP","./hour.js":"9ciXB","./day.js":"4ezR6","./week.js":"3sfLK","./month.js":"JdgMj","./year.js":"46skd","./utcMinute.js":"bCnA8","./utcHour.js":"aBqtx","./utcDay.js":"aeQbv","./utcWeek.js":"995oO","./utcMonth.js":"8QbLN","./utcYear.js":"92RpU","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1URbY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var t0 = new Date, t1 = new Date;
function newInterval(floori, offseti, count, field) {
    function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
    }
    interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
    };
    interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };
    interval.round = function(date) {
        var d0 = interval(date), d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
    };
    interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };
    interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop)
        return range;
    };
    interval.filter = function(test) {
        return newInterval(function(date) {
            if (date >= date) while(floori(date), !test(date))date.setTime(date - 1);
        }, function(date, step) {
            if (date >= date) {
                if (step < 0) while(++step <= 0){
                    while(offseti(date, -1), !test(date)); // eslint-disable-line no-empty
                }
                else while(--step >= 0){
                    while(offseti(date, 1), !test(date)); // eslint-disable-line no-empty
                }
            }
        });
    };
    if (count) {
        interval.count = function(start, end) {
            t0.setTime(+start), t1.setTime(+end);
            floori(t0), floori(t1);
            return Math.floor(count(t0, t1));
        };
        interval.every = function(step) {
            step = Math.floor(step);
            return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
                return field(d) % step === 0;
            } : function(d) {
                return interval.count(0, d) % step === 0;
            });
        };
    }
    return interval;
}
exports.default = newInterval;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"66wfU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "milliseconds", ()=>milliseconds
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var millisecond = _intervalJsDefault.default(function() {
// noop
}, function(date, step) {
    date.setTime(+date + step);
}, function(start, end) {
    return end - start;
});
// An optimized implementation for this simple case.
millisecond.every = function(k) {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0)) return null;
    if (!(k > 1)) return millisecond;
    return _intervalJsDefault.default(function(date) {
        date.setTime(Math.floor(date / k) * k);
    }, function(date, step) {
        date.setTime(+date + step * k);
    }, function(start, end) {
        return (end - start) / k;
    });
};
exports.default = millisecond;
var milliseconds = millisecond.range;

},{"./interval.js":"1URbY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5eoNm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "seconds", ()=>seconds
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _durationJs = require("./duration.js");
var second = _intervalJsDefault.default(function(date) {
    date.setTime(date - date.getMilliseconds());
}, function(date, step) {
    date.setTime(+date + step * _durationJs.durationSecond);
}, function(start, end) {
    return (end - start) / _durationJs.durationSecond;
}, function(date) {
    return date.getUTCSeconds();
});
exports.default = second;
var seconds = second.range;

},{"./interval.js":"1URbY","./duration.js":"66j9W","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"66j9W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "durationSecond", ()=>durationSecond
);
parcelHelpers.export(exports, "durationMinute", ()=>durationMinute
);
parcelHelpers.export(exports, "durationHour", ()=>durationHour
);
parcelHelpers.export(exports, "durationDay", ()=>durationDay
);
parcelHelpers.export(exports, "durationWeek", ()=>durationWeek
);
var durationSecond = 1000;
var durationMinute = 60000;
var durationHour = 3600000;
var durationDay = 86400000;
var durationWeek = 604800000;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aOzRP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "minutes", ()=>minutes
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _durationJs = require("./duration.js");
var minute = _intervalJsDefault.default(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * _durationJs.durationSecond);
}, function(date, step) {
    date.setTime(+date + step * _durationJs.durationMinute);
}, function(start, end) {
    return (end - start) / _durationJs.durationMinute;
}, function(date) {
    return date.getMinutes();
});
exports.default = minute;
var minutes = minute.range;

},{"./interval.js":"1URbY","./duration.js":"66j9W","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9ciXB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hours", ()=>hours
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _durationJs = require("./duration.js");
var hour = _intervalJsDefault.default(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * _durationJs.durationSecond - date.getMinutes() * _durationJs.durationMinute);
}, function(date, step) {
    date.setTime(+date + step * _durationJs.durationHour);
}, function(start, end) {
    return (end - start) / _durationJs.durationHour;
}, function(date) {
    return date.getHours();
});
exports.default = hour;
var hours = hour.range;

},{"./interval.js":"1URbY","./duration.js":"66j9W","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4ezR6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "days", ()=>days
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _durationJs = require("./duration.js");
var day = _intervalJsDefault.default(function(date) {
    date.setHours(0, 0, 0, 0);
}, function(date, step) {
    date.setDate(date.getDate() + step);
}, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _durationJs.durationMinute) / _durationJs.durationDay;
}, function(date) {
    return date.getDate() - 1;
});
exports.default = day;
var days = day.range;

},{"./interval.js":"1URbY","./duration.js":"66j9W","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3sfLK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sunday", ()=>sunday
);
parcelHelpers.export(exports, "monday", ()=>monday
);
parcelHelpers.export(exports, "tuesday", ()=>tuesday
);
parcelHelpers.export(exports, "wednesday", ()=>wednesday
);
parcelHelpers.export(exports, "thursday", ()=>thursday
);
parcelHelpers.export(exports, "friday", ()=>friday
);
parcelHelpers.export(exports, "saturday", ()=>saturday
);
parcelHelpers.export(exports, "sundays", ()=>sundays
);
parcelHelpers.export(exports, "mondays", ()=>mondays
);
parcelHelpers.export(exports, "tuesdays", ()=>tuesdays
);
parcelHelpers.export(exports, "wednesdays", ()=>wednesdays
);
parcelHelpers.export(exports, "thursdays", ()=>thursdays
);
parcelHelpers.export(exports, "fridays", ()=>fridays
);
parcelHelpers.export(exports, "saturdays", ()=>saturdays
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _durationJs = require("./duration.js");
function weekday(i) {
    return _intervalJsDefault.default(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
    }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _durationJs.durationMinute) / _durationJs.durationWeek;
    });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

},{"./interval.js":"1URbY","./duration.js":"66j9W","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"JdgMj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "months", ()=>months
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var month = _intervalJsDefault.default(function(date) {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
}, function(date, step) {
    date.setMonth(date.getMonth() + step);
}, function(start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
    return date.getMonth();
});
exports.default = month;
var months = month.range;

},{"./interval.js":"1URbY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"46skd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "years", ()=>years
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var year = _intervalJsDefault.default(function(date) {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
}, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
    return end.getFullYear() - start.getFullYear();
}, function(date) {
    return date.getFullYear();
});
// An optimized implementation for this simple case.
year.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : _intervalJsDefault.default(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
    }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
    });
};
exports.default = year;
var years = year.range;

},{"./interval.js":"1URbY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bCnA8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "utcMinutes", ()=>utcMinutes
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _durationJs = require("./duration.js");
var utcMinute = _intervalJsDefault.default(function(date) {
    date.setUTCSeconds(0, 0);
}, function(date, step) {
    date.setTime(+date + step * _durationJs.durationMinute);
}, function(start, end) {
    return (end - start) / _durationJs.durationMinute;
}, function(date) {
    return date.getUTCMinutes();
});
exports.default = utcMinute;
var utcMinutes = utcMinute.range;

},{"./interval.js":"1URbY","./duration.js":"66j9W","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aBqtx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "utcHours", ()=>utcHours
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _durationJs = require("./duration.js");
var utcHour = _intervalJsDefault.default(function(date) {
    date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
    date.setTime(+date + step * _durationJs.durationHour);
}, function(start, end) {
    return (end - start) / _durationJs.durationHour;
}, function(date) {
    return date.getUTCHours();
});
exports.default = utcHour;
var utcHours = utcHour.range;

},{"./interval.js":"1URbY","./duration.js":"66j9W","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aeQbv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "utcDays", ()=>utcDays
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _durationJs = require("./duration.js");
var utcDay = _intervalJsDefault.default(function(date) {
    date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
    return (end - start) / _durationJs.durationDay;
}, function(date) {
    return date.getUTCDate() - 1;
});
exports.default = utcDay;
var utcDays = utcDay.range;

},{"./interval.js":"1URbY","./duration.js":"66j9W","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"995oO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "utcSunday", ()=>utcSunday
);
parcelHelpers.export(exports, "utcMonday", ()=>utcMonday
);
parcelHelpers.export(exports, "utcTuesday", ()=>utcTuesday
);
parcelHelpers.export(exports, "utcWednesday", ()=>utcWednesday
);
parcelHelpers.export(exports, "utcThursday", ()=>utcThursday
);
parcelHelpers.export(exports, "utcFriday", ()=>utcFriday
);
parcelHelpers.export(exports, "utcSaturday", ()=>utcSaturday
);
parcelHelpers.export(exports, "utcSundays", ()=>utcSundays
);
parcelHelpers.export(exports, "utcMondays", ()=>utcMondays
);
parcelHelpers.export(exports, "utcTuesdays", ()=>utcTuesdays
);
parcelHelpers.export(exports, "utcWednesdays", ()=>utcWednesdays
);
parcelHelpers.export(exports, "utcThursdays", ()=>utcThursdays
);
parcelHelpers.export(exports, "utcFridays", ()=>utcFridays
);
parcelHelpers.export(exports, "utcSaturdays", ()=>utcSaturdays
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var _durationJs = require("./duration.js");
function utcWeekday(i) {
    return _intervalJsDefault.default(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
        return (end - start) / _durationJs.durationWeek;
    });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

},{"./interval.js":"1URbY","./duration.js":"66j9W","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8QbLN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "utcMonths", ()=>utcMonths
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var utcMonth = _intervalJsDefault.default(function(date) {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
    return date.getUTCMonth();
});
exports.default = utcMonth;
var utcMonths = utcMonth.range;

},{"./interval.js":"1URbY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"92RpU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "utcYears", ()=>utcYears
);
var _intervalJs = require("./interval.js");
var _intervalJsDefault = parcelHelpers.interopDefault(_intervalJs);
var utcYear = _intervalJsDefault.default(function(date) {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
    return date.getUTCFullYear();
});
// An optimized implementation for this simple case.
utcYear.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : _intervalJsDefault.default(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
    });
};
exports.default = utcYear;
var utcYears = utcYear.range;

},{"./interval.js":"1URbY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ioDBG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeFormatDefaultLocale", ()=>_defaultLocaleJsDefault.default
);
parcelHelpers.export(exports, "timeFormat", ()=>_defaultLocaleJs.timeFormat
);
parcelHelpers.export(exports, "timeParse", ()=>_defaultLocaleJs.timeParse
);
parcelHelpers.export(exports, "utcFormat", ()=>_defaultLocaleJs.utcFormat
);
parcelHelpers.export(exports, "utcParse", ()=>_defaultLocaleJs.utcParse
);
parcelHelpers.export(exports, "timeFormatLocale", ()=>_localeJsDefault.default
);
parcelHelpers.export(exports, "isoFormat", ()=>_isoFormatJsDefault.default
);
parcelHelpers.export(exports, "isoParse", ()=>_isoParseJsDefault.default
);
var _defaultLocaleJs = require("./defaultLocale.js");
var _defaultLocaleJsDefault = parcelHelpers.interopDefault(_defaultLocaleJs);
var _localeJs = require("./locale.js");
var _localeJsDefault = parcelHelpers.interopDefault(_localeJs);
var _isoFormatJs = require("./isoFormat.js");
var _isoFormatJsDefault = parcelHelpers.interopDefault(_isoFormatJs);
var _isoParseJs = require("./isoParse.js");
var _isoParseJsDefault = parcelHelpers.interopDefault(_isoParseJs);

},{"./defaultLocale.js":"jvGVG","./locale.js":"iO59a","./isoFormat.js":"eUcDj","./isoParse.js":"9agvx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jvGVG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeFormat", ()=>timeFormat
);
parcelHelpers.export(exports, "timeParse", ()=>timeParse
);
parcelHelpers.export(exports, "utcFormat", ()=>utcFormat
);
parcelHelpers.export(exports, "utcParse", ()=>utcParse
);
var _localeJs = require("./locale.js");
var _localeJsDefault = parcelHelpers.interopDefault(_localeJs);
var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: [
        "AM",
        "PM"
    ],
    days: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
    ],
    shortDays: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
    ],
    months: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ],
    shortMonths: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ]
});
function defaultLocale(definition) {
    locale = _localeJsDefault.default(definition);
    timeFormat = locale.format;
    timeParse = locale.parse;
    utcFormat = locale.utcFormat;
    utcParse = locale.utcParse;
    return locale;
}
exports.default = defaultLocale;

},{"./locale.js":"iO59a","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iO59a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Time = require("d3-time");
function localDate(d) {
    if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y, m, d) {
    return {
        y: y,
        m: m,
        d: d,
        H: 0,
        M: 0,
        S: 0,
        L: 0
    };
}
function formatLocale(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_weekdays = locale.days, locale_shortWeekdays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
    var formats1 = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
    };
    var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
    };
    var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
    };
    // These recursive directive definitions must be deferred.
    formats1.x = newFormat(locale_date, formats1);
    formats1.X = newFormat(locale_time, formats1);
    formats1.c = newFormat(locale_dateTime, formats1);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats) {
        return function(date) {
            var string = [], i = -1, j = 0, n = specifier.length, c, pad, format;
            if (!(date instanceof Date)) date = new Date(+date);
            while(++i < n)if (specifier.charCodeAt(i) === 37) {
                string.push(specifier.slice(j, i));
                if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
                else pad = c === "e" ? " " : "0";
                if (format = formats[c]) c = format(date, pad);
                string.push(c);
                j = i + 1;
            }
            string.push(specifier.slice(j, i));
            return string.join("");
        };
    }
    function newParse(specifier, Z) {
        return function(string) {
            var d = newDate(1900, undefined, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
            if (i != string.length) return null;
            // If a UNIX timestamp is specified, return it.
            if ("Q" in d) return new Date(d.Q);
            if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));
            // If this is utcParse, never use the local timezone.
            if (Z && !("Z" in d)) d.Z = 0;
            // The am-pm flag is 0 for AM, and 1 for PM.
            if ("p" in d) d.H = d.H % 12 + d.p * 12;
            // If the month was not specified, inherit from the quarter.
            if (d.m === undefined) d.m = "q" in d ? d.q : 0;
            // Convert day-of-week and week-of-year to day-of-year.
            if ("V" in d) {
                if (d.V < 1 || d.V > 53) return null;
                if (!("w" in d)) d.w = 1;
                if ("Z" in d) {
                    week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
                    week = day > 4 || day === 0 ? _d3Time.utcMonday.ceil(week) : _d3Time.utcMonday(week);
                    week = _d3Time.utcDay.offset(week, (d.V - 1) * 7);
                    d.y = week.getUTCFullYear();
                    d.m = week.getUTCMonth();
                    d.d = week.getUTCDate() + (d.w + 6) % 7;
                } else {
                    week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
                    week = day > 4 || day === 0 ? _d3Time.timeMonday.ceil(week) : _d3Time.timeMonday(week);
                    week = _d3Time.timeDay.offset(week, (d.V - 1) * 7);
                    d.y = week.getFullYear();
                    d.m = week.getMonth();
                    d.d = week.getDate() + (d.w + 6) % 7;
                }
            } else if ("W" in d || "U" in d) {
                if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
                day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
                d.m = 0;
                d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
            }
            // If a time zone is specified, all fields are interpreted as UTC and then
            // offset according to the specified time zone.
            if ("Z" in d) {
                d.H += d.Z / 100 | 0;
                d.M += d.Z % 100;
                return utcDate(d);
            }
            // Otherwise, all fields are in local time.
            return localDate(d);
        };
    }
    function parseSpecifier(d, specifier, string, j) {
        var i = 0, n = specifier.length, m = string.length, c, parse;
        while(i < n){
            if (j >= m) return -1;
            c = specifier.charCodeAt(i++);
            if (c === 37) {
                c = specifier.charAt(i++);
                parse = parses[c in pads ? specifier.charAt(i++) : c];
                if (!parse || (j = parse(d, string, j)) < 0) return -1;
            } else if (c != string.charCodeAt(j++)) return -1;
        }
        return j;
    }
    function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
    }
    function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
    }
    function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
    }
    function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
    }
    function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
    }
    function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
    }
    function formatMonth(d) {
        return locale_months[d.getMonth()];
    }
    function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
    }
    function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
    }
    function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
    }
    function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
    }
    function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
    }
    function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
    }
    function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
    }
    function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
    }
    return {
        format: function(specifier) {
            var f = newFormat(specifier += "", formats1);
            f.toString = function() {
                return specifier;
            };
            return f;
        },
        parse: function(specifier) {
            var p = newParse(specifier += "", false);
            p.toString = function() {
                return specifier;
            };
            return p;
        },
        utcFormat: function(specifier) {
            var f = newFormat(specifier += "", utcFormats);
            f.toString = function() {
                return specifier;
            };
            return f;
        },
        utcParse: function(specifier) {
            var p = newParse(specifier += "", true);
            p.toString = function() {
                return specifier;
            };
            return p;
        }
    };
}
exports.default = formatLocale;
var pads = {
    "-": "",
    "_": " ",
    "0": "0"
}, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad1(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s) {
    return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
    var map = {
    }, i = -1, n = names.length;
    while(++i < n)map[names[i].toLowerCase()] = i;
    return map;
}
function parseWeekdayNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
    return pad1(d.getDate(), p, 2);
}
function formatHour24(d, p) {
    return pad1(d.getHours(), p, 2);
}
function formatHour12(d, p) {
    return pad1(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
    return pad1(1 + _d3Time.timeDay.count(_d3Time.timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
    return pad1(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
    return pad1(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
    return pad1(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
    return pad1(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
    return pad1(_d3Time.timeSunday.count(_d3Time.timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
    var day = d.getDay();
    return day >= 4 || day === 0 ? _d3Time.timeThursday(d) : _d3Time.timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
    d = dISO(d);
    return pad1(_d3Time.timeThursday.count(_d3Time.timeYear(d), d) + (_d3Time.timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
    return d.getDay();
}
function formatWeekNumberMonday(d, p) {
    return pad1(_d3Time.timeMonday.count(_d3Time.timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
    return pad1(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
    d = dISO(d);
    return pad1(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
    return pad1(d.getFullYear() % 10000, p, 4);
}
function formatFullYearISO(d, p) {
    var day = d.getDay();
    d = day >= 4 || day === 0 ? _d3Time.timeThursday(d) : _d3Time.timeThursday.ceil(d);
    return pad1(d.getFullYear() % 10000, p, 4);
}
function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+")) + pad1(z / 60 | 0, "0", 2) + pad1(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
    return pad1(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
    return pad1(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
    return pad1(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
    return pad1(1 + _d3Time.utcDay.count(_d3Time.utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
    return pad1(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
    return pad1(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
    return pad1(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
    return pad1(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
    return pad1(_d3Time.utcSunday.count(_d3Time.utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
    var day = d.getUTCDay();
    return day >= 4 || day === 0 ? _d3Time.utcThursday(d) : _d3Time.utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
    d = UTCdISO(d);
    return pad1(_d3Time.utcThursday.count(_d3Time.utcYear(d), d) + (_d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
    return pad1(_d3Time.utcMonday.count(_d3Time.utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
    return pad1(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
    d = UTCdISO(d);
    return pad1(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
    return pad1(d.getUTCFullYear() % 10000, p, 4);
}
function formatUTCFullYearISO(d, p) {
    var day = d.getUTCDay();
    d = day >= 4 || day === 0 ? _d3Time.utcThursday(d) : _d3Time.utcThursday.ceil(d);
    return pad1(d.getUTCFullYear() % 10000, p, 4);
}
function formatUTCZone() {
    return "+0000";
}
function formatLiteralPercent() {
    return "%";
}
function formatUnixTimestamp(d) {
    return +d;
}
function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1000);
}

},{"d3-time":"lTNsW","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eUcDj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isoSpecifier", ()=>isoSpecifier
);
var _defaultLocaleJs = require("./defaultLocale.js");
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date) {
    return date.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : _defaultLocaleJs.utcFormat(isoSpecifier);
exports.default = formatIso;

},{"./defaultLocale.js":"jvGVG","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9agvx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isoFormatJs = require("./isoFormat.js");
var _defaultLocaleJs = require("./defaultLocale.js");
function parseIsoNative(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
}
var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : _defaultLocaleJs.utcParse(_isoFormatJs.isoSpecifier);
exports.default = parseIso;

},{"./isoFormat.js":"eUcDj","./defaultLocale.js":"jvGVG","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jZmye":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _time = require("./time");
var _d3TimeFormat = require("d3-time-format");
var _d3Time = require("d3-time");
var _init = require("./init");
exports.default = function() {
    return _init.initRange.apply(_time.calendar(_d3Time.utcYear, _d3Time.utcMonth, _d3Time.utcWeek, _d3Time.utcDay, _d3Time.utcHour, _d3Time.utcMinute, _d3Time.utcSecond, _d3Time.utcMillisecond, _d3TimeFormat.utcFormat).domain([
        Date.UTC(2000, 0, 1),
        Date.UTC(2000, 0, 2)
    ]), arguments);
};

},{"./time":"7jFE4","d3-time-format":"ioDBG","d3-time":"lTNsW","./init":"76hF6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"76Oio":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copy", ()=>copy
);
parcelHelpers.export(exports, "sequentialLog", ()=>sequentialLog
);
parcelHelpers.export(exports, "sequentialSymlog", ()=>sequentialSymlog
);
parcelHelpers.export(exports, "sequentialPow", ()=>sequentialPow
);
parcelHelpers.export(exports, "sequentialSqrt", ()=>sequentialSqrt
);
var _continuous = require("./continuous");
var _init = require("./init");
var _linear = require("./linear");
var _log = require("./log");
var _symlog = require("./symlog");
var _pow = require("./pow");
function transformer() {
    var x0 = 0, x1 = 1, t0, t1, k10, transform, interpolator = _continuous.identity, clamp = false, unknown;
    function scale(x) {
        return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
    }
    scale.domain = function(_) {
        return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [
            x0,
            x1
        ];
    };
    scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
    };
    scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
    };
}
function copy(source, target) {
    return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
    var scale = _linear.linearish(transformer()(_continuous.identity));
    scale.copy = function() {
        return copy(scale, sequential());
    };
    return _init.initInterpolator.apply(scale, arguments);
}
exports.default = sequential;
function sequentialLog() {
    var scale = _log.loggish(transformer()).domain([
        1,
        10
    ]);
    scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
    };
    return _init.initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
    var scale = _symlog.symlogish(transformer());
    scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
    };
    return _init.initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
    var scale = _pow.powish(transformer());
    scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
    };
    return _init.initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
    return sequentialPow.apply(null, arguments).exponent(0.5);
}

},{"./continuous":"btLMJ","./init":"76hF6","./linear":"iCJmQ","./log":"8gycm","./symlog":"etHgK","./pow":"kopvN","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dMZ3i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Array = require("d3-array");
var _continuous = require("./continuous");
var _init = require("./init");
function sequentialQuantile() {
    var domain = [], interpolator = _continuous.identity;
    function scale(x) {
        if (!isNaN(x = +x)) return interpolator((_d3Array.bisect(domain, x) - 1) / (domain.length - 1));
    }
    scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for(var i = 0, n = _.length, d; i < n; ++i)if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(_d3Array.ascending);
        return scale;
    };
    scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
    };
    scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
    };
    return _init.initInterpolator.apply(scale, arguments);
}
exports.default = sequentialQuantile;

},{"d3-array":"dclxS","./continuous":"btLMJ","./init":"76hF6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3lkJJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "divergingLog", ()=>divergingLog
);
parcelHelpers.export(exports, "divergingSymlog", ()=>divergingSymlog
);
parcelHelpers.export(exports, "divergingPow", ()=>divergingPow
);
parcelHelpers.export(exports, "divergingSqrt", ()=>divergingSqrt
);
var _continuous = require("./continuous");
var _init = require("./init");
var _linear = require("./linear");
var _log = require("./log");
var _sequential = require("./sequential");
var _symlog = require("./symlog");
var _pow = require("./pow");
function transformer() {
    var x0 = 0, x1 = 0.5, x2 = 1, t0, t1, t2, k10, k21, interpolator = _continuous.identity, transform, clamp = false, unknown;
    function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
    }
    scale.domain = function(_) {
        return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [
            x0,
            x1,
            x2
        ];
    };
    scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
    };
    scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
        return scale;
    };
}
function diverging() {
    var scale = _linear.linearish(transformer()(_continuous.identity));
    scale.copy = function() {
        return _sequential.copy(scale, diverging());
    };
    return _init.initInterpolator.apply(scale, arguments);
}
exports.default = diverging;
function divergingLog() {
    var scale = _log.loggish(transformer()).domain([
        0.1,
        1,
        10
    ]);
    scale.copy = function() {
        return _sequential.copy(scale, divergingLog()).base(scale.base());
    };
    return _init.initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
    var scale = _symlog.symlogish(transformer());
    scale.copy = function() {
        return _sequential.copy(scale, divergingSymlog()).constant(scale.constant());
    };
    return _init.initInterpolator.apply(scale, arguments);
}
function divergingPow() {
    var scale = _pow.powish(transformer());
    scale.copy = function() {
        return _sequential.copy(scale, divergingPow()).exponent(scale.exponent());
    };
    return _init.initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
    return divergingPow.apply(null, arguments).exponent(0.5);
}

},{"./continuous":"btLMJ","./init":"76hF6","./linear":"iCJmQ","./log":"8gycm","./sequential":"76Oio","./symlog":"etHgK","./pow":"kopvN","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aFDOR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "schemeCategory10", ()=>_category10JsDefault.default
);
parcelHelpers.export(exports, "schemeAccent", ()=>_accentJsDefault.default
);
parcelHelpers.export(exports, "schemeDark2", ()=>_dark2JsDefault.default
);
parcelHelpers.export(exports, "schemePaired", ()=>_pairedJsDefault.default
);
parcelHelpers.export(exports, "schemePastel1", ()=>_pastel1JsDefault.default
);
parcelHelpers.export(exports, "schemePastel2", ()=>_pastel2JsDefault.default
);
parcelHelpers.export(exports, "schemeSet1", ()=>_set1JsDefault.default
);
parcelHelpers.export(exports, "schemeSet2", ()=>_set2JsDefault.default
);
parcelHelpers.export(exports, "schemeSet3", ()=>_set3JsDefault.default
);
parcelHelpers.export(exports, "schemeTableau10", ()=>_tableau10JsDefault.default
);
parcelHelpers.export(exports, "interpolateBrBG", ()=>_brBGJsDefault.default
);
parcelHelpers.export(exports, "schemeBrBG", ()=>_brBGJs.scheme
);
parcelHelpers.export(exports, "interpolatePRGn", ()=>_prgnJsDefault.default
);
parcelHelpers.export(exports, "schemePRGn", ()=>_prgnJs.scheme
);
parcelHelpers.export(exports, "interpolatePiYG", ()=>_piYGJsDefault.default
);
parcelHelpers.export(exports, "schemePiYG", ()=>_piYGJs.scheme
);
parcelHelpers.export(exports, "interpolatePuOr", ()=>_puOrJsDefault.default
);
parcelHelpers.export(exports, "schemePuOr", ()=>_puOrJs.scheme
);
parcelHelpers.export(exports, "interpolateRdBu", ()=>_rdBuJsDefault.default
);
parcelHelpers.export(exports, "schemeRdBu", ()=>_rdBuJs.scheme
);
parcelHelpers.export(exports, "interpolateRdGy", ()=>_rdGyJsDefault.default
);
parcelHelpers.export(exports, "schemeRdGy", ()=>_rdGyJs.scheme
);
parcelHelpers.export(exports, "interpolateRdYlBu", ()=>_rdYlBuJsDefault.default
);
parcelHelpers.export(exports, "schemeRdYlBu", ()=>_rdYlBuJs.scheme
);
parcelHelpers.export(exports, "interpolateRdYlGn", ()=>_rdYlGnJsDefault.default
);
parcelHelpers.export(exports, "schemeRdYlGn", ()=>_rdYlGnJs.scheme
);
parcelHelpers.export(exports, "interpolateSpectral", ()=>_spectralJsDefault.default
);
parcelHelpers.export(exports, "schemeSpectral", ()=>_spectralJs.scheme
);
parcelHelpers.export(exports, "interpolateBuGn", ()=>_buGnJsDefault.default
);
parcelHelpers.export(exports, "schemeBuGn", ()=>_buGnJs.scheme
);
parcelHelpers.export(exports, "interpolateBuPu", ()=>_buPuJsDefault.default
);
parcelHelpers.export(exports, "schemeBuPu", ()=>_buPuJs.scheme
);
parcelHelpers.export(exports, "interpolateGnBu", ()=>_gnBuJsDefault.default
);
parcelHelpers.export(exports, "schemeGnBu", ()=>_gnBuJs.scheme
);
parcelHelpers.export(exports, "interpolateOrRd", ()=>_orRdJsDefault.default
);
parcelHelpers.export(exports, "schemeOrRd", ()=>_orRdJs.scheme
);
parcelHelpers.export(exports, "interpolatePuBuGn", ()=>_puBuGnJsDefault.default
);
parcelHelpers.export(exports, "schemePuBuGn", ()=>_puBuGnJs.scheme
);
parcelHelpers.export(exports, "interpolatePuBu", ()=>_puBuJsDefault.default
);
parcelHelpers.export(exports, "schemePuBu", ()=>_puBuJs.scheme
);
parcelHelpers.export(exports, "interpolatePuRd", ()=>_puRdJsDefault.default
);
parcelHelpers.export(exports, "schemePuRd", ()=>_puRdJs.scheme
);
parcelHelpers.export(exports, "interpolateRdPu", ()=>_rdPuJsDefault.default
);
parcelHelpers.export(exports, "schemeRdPu", ()=>_rdPuJs.scheme
);
parcelHelpers.export(exports, "interpolateYlGnBu", ()=>_ylGnBuJsDefault.default
);
parcelHelpers.export(exports, "schemeYlGnBu", ()=>_ylGnBuJs.scheme
);
parcelHelpers.export(exports, "interpolateYlGn", ()=>_ylGnJsDefault.default
);
parcelHelpers.export(exports, "schemeYlGn", ()=>_ylGnJs.scheme
);
parcelHelpers.export(exports, "interpolateYlOrBr", ()=>_ylOrBrJsDefault.default
);
parcelHelpers.export(exports, "schemeYlOrBr", ()=>_ylOrBrJs.scheme
);
parcelHelpers.export(exports, "interpolateYlOrRd", ()=>_ylOrRdJsDefault.default
);
parcelHelpers.export(exports, "schemeYlOrRd", ()=>_ylOrRdJs.scheme
);
parcelHelpers.export(exports, "interpolateBlues", ()=>_bluesJsDefault.default
);
parcelHelpers.export(exports, "schemeBlues", ()=>_bluesJs.scheme
);
parcelHelpers.export(exports, "interpolateGreens", ()=>_greensJsDefault.default
);
parcelHelpers.export(exports, "schemeGreens", ()=>_greensJs.scheme
);
parcelHelpers.export(exports, "interpolateGreys", ()=>_greysJsDefault.default
);
parcelHelpers.export(exports, "schemeGreys", ()=>_greysJs.scheme
);
parcelHelpers.export(exports, "interpolatePurples", ()=>_purplesJsDefault.default
);
parcelHelpers.export(exports, "schemePurples", ()=>_purplesJs.scheme
);
parcelHelpers.export(exports, "interpolateReds", ()=>_redsJsDefault.default
);
parcelHelpers.export(exports, "schemeReds", ()=>_redsJs.scheme
);
parcelHelpers.export(exports, "interpolateOranges", ()=>_orangesJsDefault.default
);
parcelHelpers.export(exports, "schemeOranges", ()=>_orangesJs.scheme
);
parcelHelpers.export(exports, "interpolateCividis", ()=>_cividisJsDefault.default
);
parcelHelpers.export(exports, "interpolateCubehelixDefault", ()=>_cubehelixJsDefault.default
);
parcelHelpers.export(exports, "interpolateRainbow", ()=>_rainbowJsDefault.default
);
parcelHelpers.export(exports, "interpolateWarm", ()=>_rainbowJs.warm
);
parcelHelpers.export(exports, "interpolateCool", ()=>_rainbowJs.cool
);
parcelHelpers.export(exports, "interpolateSinebow", ()=>_sinebowJsDefault.default
);
parcelHelpers.export(exports, "interpolateTurbo", ()=>_turboJsDefault.default
);
parcelHelpers.export(exports, "interpolateViridis", ()=>_viridisJsDefault.default
);
parcelHelpers.export(exports, "interpolateMagma", ()=>_viridisJs.magma
);
parcelHelpers.export(exports, "interpolateInferno", ()=>_viridisJs.inferno
);
parcelHelpers.export(exports, "interpolatePlasma", ()=>_viridisJs.plasma
);
var _category10Js = require("./categorical/category10.js");
var _category10JsDefault = parcelHelpers.interopDefault(_category10Js);
var _accentJs = require("./categorical/Accent.js");
var _accentJsDefault = parcelHelpers.interopDefault(_accentJs);
var _dark2Js = require("./categorical/Dark2.js");
var _dark2JsDefault = parcelHelpers.interopDefault(_dark2Js);
var _pairedJs = require("./categorical/Paired.js");
var _pairedJsDefault = parcelHelpers.interopDefault(_pairedJs);
var _pastel1Js = require("./categorical/Pastel1.js");
var _pastel1JsDefault = parcelHelpers.interopDefault(_pastel1Js);
var _pastel2Js = require("./categorical/Pastel2.js");
var _pastel2JsDefault = parcelHelpers.interopDefault(_pastel2Js);
var _set1Js = require("./categorical/Set1.js");
var _set1JsDefault = parcelHelpers.interopDefault(_set1Js);
var _set2Js = require("./categorical/Set2.js");
var _set2JsDefault = parcelHelpers.interopDefault(_set2Js);
var _set3Js = require("./categorical/Set3.js");
var _set3JsDefault = parcelHelpers.interopDefault(_set3Js);
var _tableau10Js = require("./categorical/Tableau10.js");
var _tableau10JsDefault = parcelHelpers.interopDefault(_tableau10Js);
var _brBGJs = require("./diverging/BrBG.js");
var _brBGJsDefault = parcelHelpers.interopDefault(_brBGJs);
var _prgnJs = require("./diverging/PRGn.js");
var _prgnJsDefault = parcelHelpers.interopDefault(_prgnJs);
var _piYGJs = require("./diverging/PiYG.js");
var _piYGJsDefault = parcelHelpers.interopDefault(_piYGJs);
var _puOrJs = require("./diverging/PuOr.js");
var _puOrJsDefault = parcelHelpers.interopDefault(_puOrJs);
var _rdBuJs = require("./diverging/RdBu.js");
var _rdBuJsDefault = parcelHelpers.interopDefault(_rdBuJs);
var _rdGyJs = require("./diverging/RdGy.js");
var _rdGyJsDefault = parcelHelpers.interopDefault(_rdGyJs);
var _rdYlBuJs = require("./diverging/RdYlBu.js");
var _rdYlBuJsDefault = parcelHelpers.interopDefault(_rdYlBuJs);
var _rdYlGnJs = require("./diverging/RdYlGn.js");
var _rdYlGnJsDefault = parcelHelpers.interopDefault(_rdYlGnJs);
var _spectralJs = require("./diverging/Spectral.js");
var _spectralJsDefault = parcelHelpers.interopDefault(_spectralJs);
var _buGnJs = require("./sequential-multi/BuGn.js");
var _buGnJsDefault = parcelHelpers.interopDefault(_buGnJs);
var _buPuJs = require("./sequential-multi/BuPu.js");
var _buPuJsDefault = parcelHelpers.interopDefault(_buPuJs);
var _gnBuJs = require("./sequential-multi/GnBu.js");
var _gnBuJsDefault = parcelHelpers.interopDefault(_gnBuJs);
var _orRdJs = require("./sequential-multi/OrRd.js");
var _orRdJsDefault = parcelHelpers.interopDefault(_orRdJs);
var _puBuGnJs = require("./sequential-multi/PuBuGn.js");
var _puBuGnJsDefault = parcelHelpers.interopDefault(_puBuGnJs);
var _puBuJs = require("./sequential-multi/PuBu.js");
var _puBuJsDefault = parcelHelpers.interopDefault(_puBuJs);
var _puRdJs = require("./sequential-multi/PuRd.js");
var _puRdJsDefault = parcelHelpers.interopDefault(_puRdJs);
var _rdPuJs = require("./sequential-multi/RdPu.js");
var _rdPuJsDefault = parcelHelpers.interopDefault(_rdPuJs);
var _ylGnBuJs = require("./sequential-multi/YlGnBu.js");
var _ylGnBuJsDefault = parcelHelpers.interopDefault(_ylGnBuJs);
var _ylGnJs = require("./sequential-multi/YlGn.js");
var _ylGnJsDefault = parcelHelpers.interopDefault(_ylGnJs);
var _ylOrBrJs = require("./sequential-multi/YlOrBr.js");
var _ylOrBrJsDefault = parcelHelpers.interopDefault(_ylOrBrJs);
var _ylOrRdJs = require("./sequential-multi/YlOrRd.js");
var _ylOrRdJsDefault = parcelHelpers.interopDefault(_ylOrRdJs);
var _bluesJs = require("./sequential-single/Blues.js");
var _bluesJsDefault = parcelHelpers.interopDefault(_bluesJs);
var _greensJs = require("./sequential-single/Greens.js");
var _greensJsDefault = parcelHelpers.interopDefault(_greensJs);
var _greysJs = require("./sequential-single/Greys.js");
var _greysJsDefault = parcelHelpers.interopDefault(_greysJs);
var _purplesJs = require("./sequential-single/Purples.js");
var _purplesJsDefault = parcelHelpers.interopDefault(_purplesJs);
var _redsJs = require("./sequential-single/Reds.js");
var _redsJsDefault = parcelHelpers.interopDefault(_redsJs);
var _orangesJs = require("./sequential-single/Oranges.js");
var _orangesJsDefault = parcelHelpers.interopDefault(_orangesJs);
var _cividisJs = require("./sequential-multi/cividis.js");
var _cividisJsDefault = parcelHelpers.interopDefault(_cividisJs);
var _cubehelixJs = require("./sequential-multi/cubehelix.js");
var _cubehelixJsDefault = parcelHelpers.interopDefault(_cubehelixJs);
var _rainbowJs = require("./sequential-multi/rainbow.js");
var _rainbowJsDefault = parcelHelpers.interopDefault(_rainbowJs);
var _sinebowJs = require("./sequential-multi/sinebow.js");
var _sinebowJsDefault = parcelHelpers.interopDefault(_sinebowJs);
var _turboJs = require("./sequential-multi/turbo.js");
var _turboJsDefault = parcelHelpers.interopDefault(_turboJs);
var _viridisJs = require("./sequential-multi/viridis.js");
var _viridisJsDefault = parcelHelpers.interopDefault(_viridisJs);

},{"./categorical/category10.js":"e2EfC","./categorical/Accent.js":"5q31y","./categorical/Dark2.js":"1H7j0","./categorical/Paired.js":"kt1Ru","./categorical/Pastel1.js":"etPvl","./categorical/Pastel2.js":"hpwvc","./categorical/Set1.js":"aP5Pw","./categorical/Set2.js":"8Nx5T","./categorical/Set3.js":"bxJSO","./categorical/Tableau10.js":"3cnQY","./diverging/BrBG.js":"3WTyC","./diverging/PRGn.js":"1hJlu","./diverging/PiYG.js":"giXBD","./diverging/PuOr.js":"lsRsZ","./diverging/RdBu.js":"9DbpL","./diverging/RdGy.js":"4hj5O","./diverging/RdYlBu.js":"dAVvE","./diverging/RdYlGn.js":"3IYze","./diverging/Spectral.js":"k8Kuh","./sequential-multi/BuGn.js":"cJfjI","./sequential-multi/BuPu.js":"1k17l","./sequential-multi/GnBu.js":"2HodW","./sequential-multi/OrRd.js":"csnWr","./sequential-multi/PuBuGn.js":"e9QKS","./sequential-multi/PuBu.js":"jHWtN","./sequential-multi/PuRd.js":"lbw9C","./sequential-multi/RdPu.js":"44Np6","./sequential-multi/YlGnBu.js":"2VCb3","./sequential-multi/YlGn.js":"u4n0U","./sequential-multi/YlOrBr.js":"4P7Ro","./sequential-multi/YlOrRd.js":"beAzd","./sequential-single/Blues.js":"cIts4","./sequential-single/Greens.js":"d7hUf","./sequential-single/Greys.js":"dJtfS","./sequential-single/Purples.js":"4BUF9","./sequential-single/Reds.js":"kKJoz","./sequential-single/Oranges.js":"6j8Qa","./sequential-multi/cividis.js":"67kb3","./sequential-multi/cubehelix.js":"TokCc","./sequential-multi/rainbow.js":"5bf1U","./sequential-multi/sinebow.js":"3sBQy","./sequential-multi/turbo.js":"kf8Lp","./sequential-multi/viridis.js":"BrDRR","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e2EfC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7m9wq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(specifier) {
    var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
    while(i < n)colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
    return colors;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5q31y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1H7j0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kt1Ru":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"etPvl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hpwvc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aP5Pw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8Nx5T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bxJSO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3cnQY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
exports.default = _colorsJsDefault.default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3WTyC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("d8b365f5f5f55ab4ac", "a6611adfc27d80cdc1018571", "a6611adfc27df5f5f580cdc1018571", "8c510ad8b365f6e8c3c7eae55ab4ac01665e", "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e", "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e", "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e", "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30", "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3lG5M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Interpolate = require("d3-interpolate");
exports.default = function(scheme) {
    return _d3Interpolate.interpolateRgbBasis(scheme[scheme.length - 1]);
};

},{"d3-interpolate":"e7XwA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1hJlu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("af8dc3f7f7f77fbf7b", "7b3294c2a5cfa6dba0008837", "7b3294c2a5cff7f7f7a6dba0008837", "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837", "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837", "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837", "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837", "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b", "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"giXBD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("e9a3c9f7f7f7a1d76a", "d01c8bf1b6dab8e1864dac26", "d01c8bf1b6daf7f7f7b8e1864dac26", "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221", "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221", "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221", "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221", "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419", "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lsRsZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("998ec3f7f7f7f1a340", "5e3c99b2abd2fdb863e66101", "5e3c99b2abd2f7f7f7fdb863e66101", "542788998ec3d8daebfee0b6f1a340b35806", "542788998ec3d8daebf7f7f7fee0b6f1a340b35806", "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806", "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806", "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08", "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9DbpL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("ef8a62f7f7f767a9cf", "ca0020f4a58292c5de0571b0", "ca0020f4a582f7f7f792c5de0571b0", "b2182bef8a62fddbc7d1e5f067a9cf2166ac", "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac", "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac", "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac", "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061", "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4hj5O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("ef8a62ffffff999999", "ca0020f4a582bababa404040", "ca0020f4a582ffffffbababa404040", "b2182bef8a62fddbc7e0e0e09999994d4d4d", "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d", "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d", "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d", "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a", "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dAVvE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("fc8d59ffffbf91bfdb", "d7191cfdae61abd9e92c7bb6", "d7191cfdae61ffffbfabd9e92c7bb6", "d73027fc8d59fee090e0f3f891bfdb4575b4", "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4", "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4", "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4", "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695", "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3IYze":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("fc8d59ffffbf91cf60", "d7191cfdae61a6d96a1a9641", "d7191cfdae61ffffbfa6d96a1a9641", "d73027fc8d59fee08bd9ef8b91cf601a9850", "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850", "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850", "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850", "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837", "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k8Kuh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("fc8d59ffffbf99d594", "d7191cfdae61abdda42b83ba", "d7191cfdae61ffffbfabdda42b83ba", "d53e4ffc8d59fee08be6f59899d5943288bd", "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd", "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd", "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd", "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2", "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cJfjI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("e5f5f999d8c92ca25f", "edf8fbb2e2e266c2a4238b45", "edf8fbb2e2e266c2a42ca25f006d2c", "edf8fbccece699d8c966c2a42ca25f006d2c", "edf8fbccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1k17l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("e0ecf49ebcda8856a7", "edf8fbb3cde38c96c688419d", "edf8fbb3cde38c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2HodW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("e0f3dba8ddb543a2ca", "f0f9e8bae4bc7bccc42b8cbe", "f0f9e8bae4bc7bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"csnWr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("fee8c8fdbb84e34a33", "fef0d9fdcc8afc8d59d7301f", "fef0d9fdcc8afc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"e9QKS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("ece2f0a6bddb1c9099", "f6eff7bdc9e167a9cf02818a", "f6eff7bdc9e167a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jHWtN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("ece7f2a6bddb2b8cbe", "f1eef6bdc9e174a9cf0570b0", "f1eef6bdc9e174a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lbw9C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("e7e1efc994c7dd1c77", "f1eef6d7b5d8df65b0ce1256", "f1eef6d7b5d8df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"44Np6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("fde0ddfa9fb5c51b8a", "feebe2fbb4b9f768a1ae017e", "feebe2fbb4b9f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2VCb3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("edf8b17fcdbb2c7fb8", "ffffcca1dab441b6c4225ea8", "ffffcca1dab441b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"u4n0U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("f7fcb9addd8e31a354", "ffffccc2e69978c679238443", "ffffccc2e69978c67931a354006837", "ffffccd9f0a3addd8e78c67931a354006837", "ffffccd9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4P7Ro":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("fff7bcfec44fd95f0e", "ffffd4fed98efe9929cc4c02", "ffffd4fed98efe9929d95f0e993404", "ffffd4fee391fec44ffe9929d95f0e993404", "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"beAzd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("ffeda0feb24cf03b20", "ffffb2fecc5cfd8d3ce31a1c", "ffffb2fecc5cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cIts4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("deebf79ecae13182bd", "eff3ffbdd7e76baed62171b5", "eff3ffbdd7e76baed63182bd08519c", "eff3ffc6dbef9ecae16baed63182bd08519c", "eff3ffc6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"d7hUf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("e5f5e0a1d99b31a354", "edf8e9bae4b374c476238b45", "edf8e9bae4b374c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dJtfS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("f0f0f0bdbdbd636363", "f7f7f7cccccc969696525252", "f7f7f7cccccc969696636363252525", "f7f7f7d9d9d9bdbdbd969696636363252525", "f7f7f7d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4BUF9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("efedf5bcbddc756bb1", "f2f0f7cbc9e29e9ac86a51a3", "f2f0f7cbc9e29e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kKJoz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("fee0d2fc9272de2d26", "fee5d9fcae91fb6a4acb181d", "fee5d9fcae91fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6j8Qa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheme", ()=>scheme
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
var _rampJs = require("../ramp.js");
var _rampJsDefault = parcelHelpers.interopDefault(_rampJs);
var scheme = new Array(3).concat("fee6cefdae6be6550d", "feeddefdbe85fd8d3cd94701", "feeddefdbe85fd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(_colorsJsDefault.default);
exports.default = _rampJsDefault.default(scheme);

},{"../colors.js":"7m9wq","../ramp.js":"3lG5M","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"67kb3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"TokCc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Color = require("d3-color");
var _d3Interpolate = require("d3-interpolate");
exports.default = _d3Interpolate.interpolateCubehelixLong(_d3Color.cubehelix(300, 0.5, 0), _d3Color.cubehelix(-240, 0.5, 1));

},{"d3-color":"ap3Jg","d3-interpolate":"e7XwA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5bf1U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "warm", ()=>warm
);
parcelHelpers.export(exports, "cool", ()=>cool
);
var _d3Color = require("d3-color");
var _d3Interpolate = require("d3-interpolate");
var warm = _d3Interpolate.interpolateCubehelixLong(_d3Color.cubehelix(-100, 0.75, 0.35), _d3Color.cubehelix(80, 1.5, 0.8));
var cool = _d3Interpolate.interpolateCubehelixLong(_d3Color.cubehelix(260, 0.75, 0.35), _d3Color.cubehelix(80, 1.5, 0.8));
var c = _d3Color.cubehelix();
exports.default = function(t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    c.h = 360 * t - 100;
    c.s = 1.5 - 1.5 * ts;
    c.l = 0.8 - 0.9 * ts;
    return c + "";
};

},{"d3-color":"ap3Jg","d3-interpolate":"e7XwA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3sBQy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Color = require("d3-color");
var c = _d3Color.rgb(), pi_1_3 = Math.PI / 3, pi_2_3 = Math.PI * 2 / 3;
exports.default = function(t) {
    var x;
    t = (0.5 - t) * Math.PI;
    c.r = 255 * (x = Math.sin(t)) * x;
    c.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
    c.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
    return c + "";
};

},{"d3-color":"ap3Jg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kf8Lp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"BrDRR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "magma", ()=>magma
);
parcelHelpers.export(exports, "inferno", ()=>inferno
);
parcelHelpers.export(exports, "plasma", ()=>plasma
);
var _colorsJs = require("../colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
function ramp(range) {
    var n = range.length;
    return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
}
exports.default = ramp(_colorsJsDefault.default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(_colorsJsDefault.default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(_colorsJsDefault.default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(_colorsJsDefault.default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

},{"../colors.js":"7m9wq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dTLqu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arc", ()=>_arcJsDefault.default
);
parcelHelpers.export(exports, "area", ()=>_areaJsDefault.default
);
parcelHelpers.export(exports, "line", ()=>_lineJsDefault.default
);
parcelHelpers.export(exports, "pie", ()=>_pieJsDefault.default
);
parcelHelpers.export(exports, "areaRadial", ()=>_areaRadialJsDefault.default
) // Note: radialArea is deprecated!
;
parcelHelpers.export(exports, "radialArea", ()=>_areaRadialJsDefault.default
);
parcelHelpers.export(exports, "lineRadial", ()=>_lineRadialJsDefault.default
) // Note: radialLine is deprecated!
;
parcelHelpers.export(exports, "radialLine", ()=>_lineRadialJsDefault.default
);
parcelHelpers.export(exports, "pointRadial", ()=>_pointRadialJsDefault.default
);
parcelHelpers.export(exports, "linkHorizontal", ()=>_indexJs.linkHorizontal
);
parcelHelpers.export(exports, "linkVertical", ()=>_indexJs.linkVertical
);
parcelHelpers.export(exports, "linkRadial", ()=>_indexJs.linkRadial
);
parcelHelpers.export(exports, "symbol", ()=>_symbolJsDefault.default
);
parcelHelpers.export(exports, "symbols", ()=>_symbolJs.symbols
);
parcelHelpers.export(exports, "symbolCircle", ()=>_circleJsDefault.default
);
parcelHelpers.export(exports, "symbolCross", ()=>_crossJsDefault.default
);
parcelHelpers.export(exports, "symbolDiamond", ()=>_diamondJsDefault.default
);
parcelHelpers.export(exports, "symbolSquare", ()=>_squareJsDefault.default
);
parcelHelpers.export(exports, "symbolStar", ()=>_starJsDefault.default
);
parcelHelpers.export(exports, "symbolTriangle", ()=>_triangleJsDefault.default
);
parcelHelpers.export(exports, "symbolWye", ()=>_wyeJsDefault.default
);
parcelHelpers.export(exports, "curveBasisClosed", ()=>_basisClosedJsDefault.default
);
parcelHelpers.export(exports, "curveBasisOpen", ()=>_basisOpenJsDefault.default
);
parcelHelpers.export(exports, "curveBasis", ()=>_basisJsDefault.default
);
parcelHelpers.export(exports, "curveBundle", ()=>_bundleJsDefault.default
);
parcelHelpers.export(exports, "curveCardinalClosed", ()=>_cardinalClosedJsDefault.default
);
parcelHelpers.export(exports, "curveCardinalOpen", ()=>_cardinalOpenJsDefault.default
);
parcelHelpers.export(exports, "curveCardinal", ()=>_cardinalJsDefault.default
);
parcelHelpers.export(exports, "curveCatmullRomClosed", ()=>_catmullRomClosedJsDefault.default
);
parcelHelpers.export(exports, "curveCatmullRomOpen", ()=>_catmullRomOpenJsDefault.default
);
parcelHelpers.export(exports, "curveCatmullRom", ()=>_catmullRomJsDefault.default
);
parcelHelpers.export(exports, "curveLinearClosed", ()=>_linearClosedJsDefault.default
);
parcelHelpers.export(exports, "curveLinear", ()=>_linearJsDefault.default
);
parcelHelpers.export(exports, "curveMonotoneX", ()=>_monotoneJs.monotoneX
);
parcelHelpers.export(exports, "curveMonotoneY", ()=>_monotoneJs.monotoneY
);
parcelHelpers.export(exports, "curveNatural", ()=>_naturalJsDefault.default
);
parcelHelpers.export(exports, "curveStep", ()=>_stepJsDefault.default
);
parcelHelpers.export(exports, "curveStepAfter", ()=>_stepJs.stepAfter
);
parcelHelpers.export(exports, "curveStepBefore", ()=>_stepJs.stepBefore
);
parcelHelpers.export(exports, "stack", ()=>_stackJsDefault.default
);
parcelHelpers.export(exports, "stackOffsetExpand", ()=>_expandJsDefault.default
);
parcelHelpers.export(exports, "stackOffsetDiverging", ()=>_divergingJsDefault.default
);
parcelHelpers.export(exports, "stackOffsetNone", ()=>_noneJsDefault.default
);
parcelHelpers.export(exports, "stackOffsetSilhouette", ()=>_silhouetteJsDefault.default
);
parcelHelpers.export(exports, "stackOffsetWiggle", ()=>_wiggleJsDefault.default
);
parcelHelpers.export(exports, "stackOrderAppearance", ()=>_appearanceJsDefault.default
);
parcelHelpers.export(exports, "stackOrderAscending", ()=>_ascendingJsDefault.default
);
parcelHelpers.export(exports, "stackOrderDescending", ()=>_descendingJsDefault.default
);
parcelHelpers.export(exports, "stackOrderInsideOut", ()=>_insideOutJsDefault.default
);
parcelHelpers.export(exports, "stackOrderNone", ()=>_noneJsDefault1.default
);
parcelHelpers.export(exports, "stackOrderReverse", ()=>_reverseJsDefault.default
);
var _arcJs = require("./arc.js");
var _arcJsDefault = parcelHelpers.interopDefault(_arcJs);
var _areaJs = require("./area.js");
var _areaJsDefault = parcelHelpers.interopDefault(_areaJs);
var _lineJs = require("./line.js");
var _lineJsDefault = parcelHelpers.interopDefault(_lineJs);
var _pieJs = require("./pie.js");
var _pieJsDefault = parcelHelpers.interopDefault(_pieJs);
var _areaRadialJs = require("./areaRadial.js");
var _areaRadialJsDefault = parcelHelpers.interopDefault(_areaRadialJs);
var _lineRadialJs = require("./lineRadial.js");
var _lineRadialJsDefault = parcelHelpers.interopDefault(_lineRadialJs);
var _pointRadialJs = require("./pointRadial.js");
var _pointRadialJsDefault = parcelHelpers.interopDefault(_pointRadialJs);
var _indexJs = require("./link/index.js");
var _symbolJs = require("./symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _circleJs = require("./symbol/circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _crossJs = require("./symbol/cross.js");
var _crossJsDefault = parcelHelpers.interopDefault(_crossJs);
var _diamondJs = require("./symbol/diamond.js");
var _diamondJsDefault = parcelHelpers.interopDefault(_diamondJs);
var _squareJs = require("./symbol/square.js");
var _squareJsDefault = parcelHelpers.interopDefault(_squareJs);
var _starJs = require("./symbol/star.js");
var _starJsDefault = parcelHelpers.interopDefault(_starJs);
var _triangleJs = require("./symbol/triangle.js");
var _triangleJsDefault = parcelHelpers.interopDefault(_triangleJs);
var _wyeJs = require("./symbol/wye.js");
var _wyeJsDefault = parcelHelpers.interopDefault(_wyeJs);
var _basisClosedJs = require("./curve/basisClosed.js");
var _basisClosedJsDefault = parcelHelpers.interopDefault(_basisClosedJs);
var _basisOpenJs = require("./curve/basisOpen.js");
var _basisOpenJsDefault = parcelHelpers.interopDefault(_basisOpenJs);
var _basisJs = require("./curve/basis.js");
var _basisJsDefault = parcelHelpers.interopDefault(_basisJs);
var _bundleJs = require("./curve/bundle.js");
var _bundleJsDefault = parcelHelpers.interopDefault(_bundleJs);
var _cardinalClosedJs = require("./curve/cardinalClosed.js");
var _cardinalClosedJsDefault = parcelHelpers.interopDefault(_cardinalClosedJs);
var _cardinalOpenJs = require("./curve/cardinalOpen.js");
var _cardinalOpenJsDefault = parcelHelpers.interopDefault(_cardinalOpenJs);
var _cardinalJs = require("./curve/cardinal.js");
var _cardinalJsDefault = parcelHelpers.interopDefault(_cardinalJs);
var _catmullRomClosedJs = require("./curve/catmullRomClosed.js");
var _catmullRomClosedJsDefault = parcelHelpers.interopDefault(_catmullRomClosedJs);
var _catmullRomOpenJs = require("./curve/catmullRomOpen.js");
var _catmullRomOpenJsDefault = parcelHelpers.interopDefault(_catmullRomOpenJs);
var _catmullRomJs = require("./curve/catmullRom.js");
var _catmullRomJsDefault = parcelHelpers.interopDefault(_catmullRomJs);
var _linearClosedJs = require("./curve/linearClosed.js");
var _linearClosedJsDefault = parcelHelpers.interopDefault(_linearClosedJs);
var _linearJs = require("./curve/linear.js");
var _linearJsDefault = parcelHelpers.interopDefault(_linearJs);
var _monotoneJs = require("./curve/monotone.js");
var _naturalJs = require("./curve/natural.js");
var _naturalJsDefault = parcelHelpers.interopDefault(_naturalJs);
var _stepJs = require("./curve/step.js");
var _stepJsDefault = parcelHelpers.interopDefault(_stepJs);
var _stackJs = require("./stack.js");
var _stackJsDefault = parcelHelpers.interopDefault(_stackJs);
var _expandJs = require("./offset/expand.js");
var _expandJsDefault = parcelHelpers.interopDefault(_expandJs);
var _divergingJs = require("./offset/diverging.js");
var _divergingJsDefault = parcelHelpers.interopDefault(_divergingJs);
var _noneJs = require("./offset/none.js");
var _noneJsDefault = parcelHelpers.interopDefault(_noneJs);
var _silhouetteJs = require("./offset/silhouette.js");
var _silhouetteJsDefault = parcelHelpers.interopDefault(_silhouetteJs);
var _wiggleJs = require("./offset/wiggle.js");
var _wiggleJsDefault = parcelHelpers.interopDefault(_wiggleJs);
var _appearanceJs = require("./order/appearance.js");
var _appearanceJsDefault = parcelHelpers.interopDefault(_appearanceJs);
var _ascendingJs = require("./order/ascending.js");
var _ascendingJsDefault = parcelHelpers.interopDefault(_ascendingJs);
var _descendingJs = require("./order/descending.js");
var _descendingJsDefault = parcelHelpers.interopDefault(_descendingJs);
var _insideOutJs = require("./order/insideOut.js");
var _insideOutJsDefault = parcelHelpers.interopDefault(_insideOutJs);
var _noneJs1 = require("./order/none.js");
var _noneJsDefault1 = parcelHelpers.interopDefault(_noneJs1);
var _reverseJs = require("./order/reverse.js");
var _reverseJsDefault = parcelHelpers.interopDefault(_reverseJs);

},{"./arc.js":"exU1H","./area.js":"gvvw5","./line.js":"bELRt","./pie.js":"cygYf","./areaRadial.js":"dJ9RA","./lineRadial.js":"9gVbr","./pointRadial.js":"l0dNC","./link/index.js":"cdFcN","./symbol.js":"5fI0H","./symbol/circle.js":"kJX1p","./symbol/cross.js":"csQ4j","./symbol/diamond.js":"cDzr1","./symbol/square.js":"gwOZl","./symbol/star.js":"cCUQj","./symbol/triangle.js":"lC5to","./symbol/wye.js":"gmetX","./curve/basisClosed.js":"3v0R7","./curve/basisOpen.js":"hhNWq","./curve/basis.js":"haiwm","./curve/bundle.js":"ejKn0","./curve/cardinalClosed.js":"2Lnb5","./curve/cardinalOpen.js":"imrN3","./curve/cardinal.js":"lY1cC","./curve/catmullRomClosed.js":"j5Vzy","./curve/catmullRomOpen.js":"fw3h3","./curve/catmullRom.js":"alELy","./curve/linearClosed.js":"6OXjp","./curve/linear.js":"dgYF5","./curve/monotone.js":"ej0HE","./curve/natural.js":"kU29F","./curve/step.js":"2h2VG","./stack.js":"8FoPn","./offset/expand.js":"kheNr","./offset/diverging.js":"ahsJE","./offset/none.js":"kmdsk","./offset/silhouette.js":"isPKf","./offset/wiggle.js":"eeem3","./order/appearance.js":"cq85r","./order/ascending.js":"02faF","./order/descending.js":"9HajE","./order/insideOut.js":"kFg22","./order/none.js":"7PXGK","./order/reverse.js":"6qcQw","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"exU1H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Path = require("d3-path");
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _mathJs = require("./math.js");
function arcInnerRadius(d) {
    return d.innerRadius;
}
function arcOuterRadius(d) {
    return d.outerRadius;
}
function arcStartAngle(d) {
    return d.startAngle;
}
function arcEndAngle(d) {
    return d.endAngle;
}
function arcPadAngle(d) {
    return d && d.padAngle; // Note: optional!
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
    if (t * t < _mathJs.epsilon) return;
    t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
    return [
        x0 + t * x10,
        y0 + t * y10
    ];
}
// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
    var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / _mathJs.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * _mathJs.sqrt(_mathJs.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
    // Pick the closer of the two intersection points.
    // TODO Is there a faster way to determine which intersection to use?
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
    };
}
exports.default = function() {
    var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = _constantJsDefault.default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
    function arc() {
        var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - _mathJs.halfPi, a1 = endAngle.apply(this, arguments) - _mathJs.halfPi, da = _mathJs.abs(a1 - a0), cw = a1 > a0;
        if (!context) context = buffer = _d3Path.path();
        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;
        // Is it a point?
        if (!(r1 > _mathJs.epsilon)) context.moveTo(0, 0);
        else if (da > _mathJs.tau - _mathJs.epsilon) {
            context.moveTo(r1 * _mathJs.cos(a0), r1 * _mathJs.sin(a0));
            context.arc(0, 0, r1, a0, a1, !cw);
            if (r0 > _mathJs.epsilon) {
                context.moveTo(r0 * _mathJs.cos(a1), r0 * _mathJs.sin(a1));
                context.arc(0, 0, r0, a1, a0, cw);
            }
        } else {
            var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > _mathJs.epsilon && (padRadius ? +padRadius.apply(this, arguments) : _mathJs.sqrt(r0 * r0 + r1 * r1)), rc = _mathJs.min(_mathJs.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
            // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
            if (rp > _mathJs.epsilon) {
                var p0 = _mathJs.asin(rp / r0 * _mathJs.sin(ap)), p1 = _mathJs.asin(rp / r1 * _mathJs.sin(ap));
                if ((da0 -= p0 * 2) > _mathJs.epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
                else da0 = 0, a00 = a10 = (a0 + a1) / 2;
                if ((da1 -= p1 * 2) > _mathJs.epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
                else da1 = 0, a01 = a11 = (a0 + a1) / 2;
            }
            var x01 = r1 * _mathJs.cos(a01), y01 = r1 * _mathJs.sin(a01), x10 = r0 * _mathJs.cos(a10), y10 = r0 * _mathJs.sin(a10);
            // Apply rounded corners?
            if (rc > _mathJs.epsilon) {
                var x11 = r1 * _mathJs.cos(a11), y11 = r1 * _mathJs.sin(a11), x00 = r0 * _mathJs.cos(a00), y00 = r0 * _mathJs.sin(a00), oc;
                // Restrict the corner radius according to the sector angle.
                if (da < _mathJs.pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
                    var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / _mathJs.sin(_mathJs.acos((ax * bx + ay * by) / (_mathJs.sqrt(ax * ax + ay * ay) * _mathJs.sqrt(bx * bx + by * by))) / 2), lc = _mathJs.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                    rc0 = _mathJs.min(rc, (r0 - lc) / (kc - 1));
                    rc1 = _mathJs.min(rc, (r1 - lc) / (kc + 1));
                }
            }
            // Is the sector collapsed to a line?
            if (!(da1 > _mathJs.epsilon)) context.moveTo(x01, y01);
            else if (rc1 > _mathJs.epsilon) {
                t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
                t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
                context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
                // Have the corners merged?
                if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, _mathJs.atan2(t0.y01, t0.x01), _mathJs.atan2(t1.y01, t1.x01), !cw);
                else {
                    context.arc(t0.cx, t0.cy, rc1, _mathJs.atan2(t0.y01, t0.x01), _mathJs.atan2(t0.y11, t0.x11), !cw);
                    context.arc(0, 0, r1, _mathJs.atan2(t0.cy + t0.y11, t0.cx + t0.x11), _mathJs.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                    context.arc(t1.cx, t1.cy, rc1, _mathJs.atan2(t1.y11, t1.x11), _mathJs.atan2(t1.y01, t1.x01), !cw);
                }
            } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
            // Is there no inner ring, and it’s a circular sector?
            // Or perhaps it’s an annular sector collapsed due to padding?
            if (!(r0 > _mathJs.epsilon) || !(da0 > _mathJs.epsilon)) context.lineTo(x10, y10);
            else if (rc0 > _mathJs.epsilon) {
                t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
                t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
                context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
                // Have the corners merged?
                if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, _mathJs.atan2(t0.y01, t0.x01), _mathJs.atan2(t1.y01, t1.x01), !cw);
                else {
                    context.arc(t0.cx, t0.cy, rc0, _mathJs.atan2(t0.y01, t0.x01), _mathJs.atan2(t0.y11, t0.x11), !cw);
                    context.arc(0, 0, r0, _mathJs.atan2(t0.cy + t0.y11, t0.cx + t0.x11), _mathJs.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                    context.arc(t1.cx, t1.cy, rc0, _mathJs.atan2(t1.y11, t1.x11), _mathJs.atan2(t1.y01, t1.x01), !cw);
                }
            } else context.arc(0, 0, r0, a10, a00, cw);
        }
        context.closePath();
        if (buffer) return context = null, buffer + "" || null;
    }
    arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _mathJs.pi / 2;
        return [
            _mathJs.cos(a) * r,
            _mathJs.sin(a) * r
        ];
    };
    arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : _constantJsDefault.default(+_), arc) : innerRadius;
    };
    arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : _constantJsDefault.default(+_), arc) : outerRadius;
    };
    arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : _constantJsDefault.default(+_), arc) : cornerRadius;
    };
    arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : _constantJsDefault.default(+_), arc) : padRadius;
    };
    arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : _constantJsDefault.default(+_), arc) : startAngle;
    };
    arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : _constantJsDefault.default(+_), arc) : endAngle;
    };
    arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : _constantJsDefault.default(+_), arc) : padAngle;
    };
    arc.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, arc) : context;
    };
    return arc;
};

},{"d3-path":"4S67G","./constant.js":"eKjAq","./math.js":"9EE85","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eKjAq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function constant() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9EE85":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "abs", ()=>abs
);
parcelHelpers.export(exports, "atan2", ()=>atan2
);
parcelHelpers.export(exports, "cos", ()=>cos
);
parcelHelpers.export(exports, "max", ()=>max
);
parcelHelpers.export(exports, "min", ()=>min
);
parcelHelpers.export(exports, "sin", ()=>sin
);
parcelHelpers.export(exports, "sqrt", ()=>sqrt
);
parcelHelpers.export(exports, "epsilon", ()=>epsilon
);
parcelHelpers.export(exports, "pi", ()=>pi
);
parcelHelpers.export(exports, "halfPi", ()=>halfPi
);
parcelHelpers.export(exports, "tau", ()=>tau
);
parcelHelpers.export(exports, "acos", ()=>acos
);
parcelHelpers.export(exports, "asin", ()=>asin
);
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon = 0.000000000001;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
    return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gvvw5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Path = require("d3-path");
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _linearJs = require("./curve/linear.js");
var _linearJsDefault = parcelHelpers.interopDefault(_linearJs);
var _lineJs = require("./line.js");
var _lineJsDefault = parcelHelpers.interopDefault(_lineJs);
var _pointJs = require("./point.js");
exports.default = function() {
    var x0 = _pointJs.x, x1 = null, y0 = _constantJsDefault.default(0), y1 = _pointJs.y, defined = _constantJsDefault.default(true), context = null, curve = _linearJsDefault.default, output = null;
    function area(data) {
        var i, j, k, n = data.length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
        if (context == null) output = curve(buffer = _d3Path.path());
        for(i = 0; i <= n; ++i){
            if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                if (defined0 = !defined0) {
                    j = i;
                    output.areaStart();
                    output.lineStart();
                } else {
                    output.lineEnd();
                    output.lineStart();
                    for(k = i - 1; k >= j; --k)output.point(x0z[k], y0z[k]);
                    output.lineEnd();
                    output.areaEnd();
                }
            }
            if (defined0) {
                x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
                output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
            }
        }
        if (buffer) return output = null, buffer + "" || null;
    }
    function arealine() {
        return _lineJsDefault.default().defined(defined).curve(curve).context(context);
    }
    area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : _constantJsDefault.default(+_), x1 = null, area) : x0;
    };
    area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : _constantJsDefault.default(+_), area) : x0;
    };
    area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : _constantJsDefault.default(+_), area) : x1;
    };
    area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : _constantJsDefault.default(+_), y1 = null, area) : y0;
    };
    area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : _constantJsDefault.default(+_), area) : y0;
    };
    area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : _constantJsDefault.default(+_), area) : y1;
    };
    area.lineX0 = area.lineY0 = function() {
        return arealine().x(x0).y(y0);
    };
    area.lineY1 = function() {
        return arealine().x(x0).y(y1);
    };
    area.lineX1 = function() {
        return arealine().x(x1).y(y0);
    };
    area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : _constantJsDefault.default(!!_), area) : defined;
    };
    area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
    };
    area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
    };
    return area;
};

},{"d3-path":"4S67G","./constant.js":"eKjAq","./curve/linear.js":"dgYF5","./line.js":"bELRt","./point.js":"cSKUZ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dgYF5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function Linear(context) {
    this._context = context;
}
Linear.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._point = 0;
    },
    lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2; // proceed
            default:
                this._context.lineTo(x, y);
                break;
        }
    }
};
exports.default = function(context) {
    return new Linear(context);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bELRt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Path = require("d3-path");
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _linearJs = require("./curve/linear.js");
var _linearJsDefault = parcelHelpers.interopDefault(_linearJs);
var _pointJs = require("./point.js");
exports.default = function() {
    var x = _pointJs.x, y = _pointJs.y, defined = _constantJsDefault.default(true), context = null, curve = _linearJsDefault.default, output = null;
    function line(data) {
        var i, n = data.length, d, defined0 = false, buffer;
        if (context == null) output = curve(buffer = _d3Path.path());
        for(i = 0; i <= n; ++i){
            if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                if (defined0 = !defined0) output.lineStart();
                else output.lineEnd();
            }
            if (defined0) output.point(+x(d, i, data), +y(d, i, data));
        }
        if (buffer) return output = null, buffer + "" || null;
    }
    line.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : _constantJsDefault.default(+_), line) : x;
    };
    line.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : _constantJsDefault.default(+_), line) : y;
    };
    line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : _constantJsDefault.default(!!_), line) : defined;
    };
    line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
    };
    line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
    };
    return line;
};

},{"d3-path":"4S67G","./constant.js":"eKjAq","./curve/linear.js":"dgYF5","./point.js":"cSKUZ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cSKUZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "x", ()=>x
);
parcelHelpers.export(exports, "y", ()=>y
);
function x(p) {
    return p[0];
}
function y(p) {
    return p[1];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cygYf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _descendingJs = require("./descending.js");
var _descendingJsDefault = parcelHelpers.interopDefault(_descendingJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _mathJs = require("./math.js");
exports.default = function() {
    var value = _identityJsDefault.default, sortValues = _descendingJsDefault.default, sort = null, startAngle = _constantJsDefault.default(0), endAngle = _constantJsDefault.default(_mathJs.tau), padAngle = _constantJsDefault.default(0);
    function pie(data) {
        var i, n = data.length, j, k, sum = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(_mathJs.tau, Math.max(-_mathJs.tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
        for(i = 0; i < n; ++i)if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) sum += v;
        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) {
            return sortValues(arcs[i], arcs[j]);
        });
        else if (sort != null) index.sort(function(i, j) {
            return sort(data[i], data[j]);
        });
        // Compute the arcs! They are stored in the original data's order.
        for(i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1)j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
        };
        return arcs;
    }
    pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : _constantJsDefault.default(+_), pie) : value;
    };
    pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
    };
    pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
    };
    pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : _constantJsDefault.default(+_), pie) : startAngle;
    };
    pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : _constantJsDefault.default(+_), pie) : endAngle;
    };
    pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : _constantJsDefault.default(+_), pie) : padAngle;
    };
    return pie;
};

},{"./constant.js":"eKjAq","./descending.js":"8OWRN","./identity.js":"kGDpH","./math.js":"9EE85","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8OWRN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kGDpH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(d) {
    return d;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dJ9RA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _radialJs = require("./curve/radial.js");
var _radialJsDefault = parcelHelpers.interopDefault(_radialJs);
var _areaJs = require("./area.js");
var _areaJsDefault = parcelHelpers.interopDefault(_areaJs);
var _lineRadialJs = require("./lineRadial.js");
exports.default = function() {
    var a = _areaJsDefault.default().curve(_radialJs.curveRadialLinear), c = a.curve, x0 = a.lineX0, x1 = a.lineX1, y0 = a.lineY0, y1 = a.lineY1;
    a.angle = a.x, delete a.x;
    a.startAngle = a.x0, delete a.x0;
    a.endAngle = a.x1, delete a.x1;
    a.radius = a.y, delete a.y;
    a.innerRadius = a.y0, delete a.y0;
    a.outerRadius = a.y1, delete a.y1;
    a.lineStartAngle = function() {
        return _lineRadialJs.lineRadial(x0());
    }, delete a.lineX0;
    a.lineEndAngle = function() {
        return _lineRadialJs.lineRadial(x1());
    }, delete a.lineX1;
    a.lineInnerRadius = function() {
        return _lineRadialJs.lineRadial(y0());
    }, delete a.lineY0;
    a.lineOuterRadius = function() {
        return _lineRadialJs.lineRadial(y1());
    }, delete a.lineY1;
    a.curve = function(_) {
        return arguments.length ? c(_radialJsDefault.default(_)) : c()._curve;
    };
    return a;
};

},{"./curve/radial.js":"4tTTY","./area.js":"gvvw5","./lineRadial.js":"9gVbr","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4tTTY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "curveRadialLinear", ()=>curveRadialLinear
);
var _linearJs = require("./linear.js");
var _linearJsDefault = parcelHelpers.interopDefault(_linearJs);
var curveRadialLinear = curveRadial(_linearJsDefault.default);
function Radial(curve) {
    this._curve = curve;
}
Radial.prototype = {
    areaStart: function() {
        this._curve.areaStart();
    },
    areaEnd: function() {
        this._curve.areaEnd();
    },
    lineStart: function() {
        this._curve.lineStart();
    },
    lineEnd: function() {
        this._curve.lineEnd();
    },
    point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
    }
};
function curveRadial(curve) {
    function radial(context) {
        return new Radial(curve(context));
    }
    radial._curve = curve;
    return radial;
}
exports.default = curveRadial;

},{"./linear.js":"dgYF5","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9gVbr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lineRadial", ()=>lineRadial
);
var _radialJs = require("./curve/radial.js");
var _radialJsDefault = parcelHelpers.interopDefault(_radialJs);
var _lineJs = require("./line.js");
var _lineJsDefault = parcelHelpers.interopDefault(_lineJs);
function lineRadial(l) {
    var c = l.curve;
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    l.curve = function(_) {
        return arguments.length ? c(_radialJsDefault.default(_)) : c()._curve;
    };
    return l;
}
exports.default = function() {
    return lineRadial(_lineJsDefault.default().curve(_radialJs.curveRadialLinear));
};

},{"./curve/radial.js":"4tTTY","./line.js":"bELRt","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"l0dNC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x, y) {
    return [
        (y = +y) * Math.cos(x -= Math.PI / 2),
        y * Math.sin(x)
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cdFcN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "linkHorizontal", ()=>linkHorizontal
);
parcelHelpers.export(exports, "linkVertical", ()=>linkVertical
);
parcelHelpers.export(exports, "linkRadial", ()=>linkRadial
);
var _d3Path = require("d3-path");
var _arrayJs = require("../array.js");
var _constantJs = require("../constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _pointJs = require("../point.js");
var _pointRadialJs = require("../pointRadial.js");
var _pointRadialJsDefault = parcelHelpers.interopDefault(_pointRadialJs);
function linkSource(d) {
    return d.source;
}
function linkTarget(d) {
    return d.target;
}
function link1(curve) {
    var source = linkSource, target = linkTarget, x = _pointJs.x, y = _pointJs.y, context = null;
    function link() {
        var buffer, argv = _arrayJs.slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
        if (!context) context = buffer = _d3Path.path();
        curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
        if (buffer) return context = null, buffer + "" || null;
    }
    link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
    };
    link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
    };
    link.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : _constantJsDefault.default(+_), link) : x;
    };
    link.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : _constantJsDefault.default(+_), link) : y;
    };
    link.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, link) : context;
    };
    return link;
}
function curveHorizontal(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}
function curveVertical(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}
function curveRadial(context, x0, y0, x1, y1) {
    var p0 = _pointRadialJsDefault.default(x0, y0), p1 = _pointRadialJsDefault.default(x0, y0 = (y0 + y1) / 2), p2 = _pointRadialJsDefault.default(x1, y0), p3 = _pointRadialJsDefault.default(x1, y1);
    context.moveTo(p0[0], p0[1]);
    context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}
function linkHorizontal() {
    return link1(curveHorizontal);
}
function linkVertical() {
    return link1(curveVertical);
}
function linkRadial() {
    var l = link1(curveRadial);
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    return l;
}

},{"d3-path":"4S67G","../array.js":"h9Y8M","../constant.js":"eKjAq","../point.js":"cSKUZ","../pointRadial.js":"l0dNC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"h9Y8M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "slice", ()=>slice
);
var slice = Array.prototype.slice;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5fI0H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "symbols", ()=>symbols
);
var _d3Path = require("d3-path");
var _circleJs = require("./symbol/circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _crossJs = require("./symbol/cross.js");
var _crossJsDefault = parcelHelpers.interopDefault(_crossJs);
var _diamondJs = require("./symbol/diamond.js");
var _diamondJsDefault = parcelHelpers.interopDefault(_diamondJs);
var _starJs = require("./symbol/star.js");
var _starJsDefault = parcelHelpers.interopDefault(_starJs);
var _squareJs = require("./symbol/square.js");
var _squareJsDefault = parcelHelpers.interopDefault(_squareJs);
var _triangleJs = require("./symbol/triangle.js");
var _triangleJsDefault = parcelHelpers.interopDefault(_triangleJs);
var _wyeJs = require("./symbol/wye.js");
var _wyeJsDefault = parcelHelpers.interopDefault(_wyeJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var symbols = [
    _circleJsDefault.default,
    _crossJsDefault.default,
    _diamondJsDefault.default,
    _squareJsDefault.default,
    _starJsDefault.default,
    _triangleJsDefault.default,
    _wyeJsDefault.default
];
exports.default = function() {
    var type = _constantJsDefault.default(_circleJsDefault.default), size = _constantJsDefault.default(64), context = null;
    function symbol() {
        var buffer;
        if (!context) context = buffer = _d3Path.path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
    }
    symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : _constantJsDefault.default(_), symbol) : type;
    };
    symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : _constantJsDefault.default(+_), symbol) : size;
    };
    symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
    };
    return symbol;
};

},{"d3-path":"4S67G","./symbol/circle.js":"kJX1p","./symbol/cross.js":"csQ4j","./symbol/diamond.js":"cDzr1","./symbol/star.js":"cCUQj","./symbol/square.js":"gwOZl","./symbol/triangle.js":"lC5to","./symbol/wye.js":"gmetX","./constant.js":"eKjAq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kJX1p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mathJs = require("../math.js");
exports.default = {
    draw: function(context, size) {
        var r = Math.sqrt(size / _mathJs.pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, _mathJs.tau);
    }
};

},{"../math.js":"9EE85","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"csQ4j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    draw: function(context, size) {
        var r = Math.sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cDzr1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2;
exports.default = {
    draw: function(context, size) {
        var y = Math.sqrt(size / tan30_2), x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cCUQj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mathJs = require("../math.js");
var ka = 0.8908130915292852, kr = Math.sin(_mathJs.pi / 10) / Math.sin(7 * _mathJs.pi / 10), kx = Math.sin(_mathJs.tau / 10) * kr, ky = -Math.cos(_mathJs.tau / 10) * kr;
exports.default = {
    draw: function(context, size) {
        var r = Math.sqrt(size * ka), x = kx * r, y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for(var i = 1; i < 5; ++i){
            var a = _mathJs.tau * i / 5, c = Math.cos(a), s = Math.sin(a);
            context.lineTo(s * r, -c * r);
            context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
    }
};

},{"../math.js":"9EE85","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gwOZl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    draw: function(context, size) {
        var w = Math.sqrt(size), x = -w / 2;
        context.rect(x, x, w, w);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lC5to":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var sqrt3 = Math.sqrt(3);
exports.default = {
    draw: function(context, size) {
        var y = -Math.sqrt(size / (sqrt3 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3 * y, -y);
        context.lineTo(sqrt3 * y, -y);
        context.closePath();
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gmetX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var c = -0.5, s = Math.sqrt(3) / 2, k = 1 / Math.sqrt(12), a = (k / 2 + 1) * 3;
exports.default = {
    draw: function(context, size) {
        var r = Math.sqrt(size / a), x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3v0R7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _basisJs = require("./basis.js");
function BasisClosed(context) {
    this._context = context;
}
BasisClosed.prototype = {
    areaStart: _noopJsDefault.default,
    areaEnd: _noopJsDefault.default,
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 1:
                this._context.moveTo(this._x2, this._y2);
                this._context.closePath();
                break;
            case 2:
                this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
                this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
                this._context.closePath();
                break;
            case 3:
                this.point(this._x2, this._y2);
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                break;
        }
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._x2 = x, this._y2 = y;
                break;
            case 1:
                this._point = 2;
                this._x3 = x, this._y3 = y;
                break;
            case 2:
                this._point = 3;
                this._x4 = x, this._y4 = y;
                this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);
                break;
            default:
                _basisJs.point(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
    }
};
exports.default = function(context) {
    return new BasisClosed(context);
};

},{"../noop.js":"l5hui","./basis.js":"haiwm","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"l5hui":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function() {
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"haiwm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "point", ()=>point
);
parcelHelpers.export(exports, "Basis", ()=>Basis
);
function point(that, x, y) {
    that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
}
function Basis(context) {
    this._context = context;
}
Basis.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 3:
                point(this, this._x1, this._y1); // proceed
            case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
            default:
                point(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
    }
};
exports.default = function(context) {
    return new Basis(context);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hhNWq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _basisJs = require("./basis.js");
function BasisOpen(context) {
    this._context = context;
}
BasisOpen.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6;
                this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
                break;
            case 3:
                this._point = 4; // proceed
            default:
                _basisJs.point(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
    }
};
exports.default = function(context) {
    return new BasisOpen(context);
};

},{"./basis.js":"haiwm","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ejKn0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _basisJs = require("./basis.js");
function Bundle(context, beta) {
    this._basis = new _basisJs.Basis(context);
    this._beta = beta;
}
Bundle.prototype = {
    lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
    },
    lineEnd: function() {
        var x = this._x, y = this._y, j = x.length - 1;
        if (j > 0) {
            var x0 = x[0], y0 = y[0], dx = x[j] - x0, dy = y[j] - y0, i = -1, t;
            while(++i <= j){
                t = i / j;
                this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
            }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
    },
    point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
    }
};
exports.default = (function custom(beta1) {
    function bundle(context) {
        return beta1 === 1 ? new _basisJs.Basis(context) : new Bundle(context, beta1);
    }
    bundle.beta = function(beta) {
        return custom(+beta);
    };
    return bundle;
})(0.85);

},{"./basis.js":"haiwm","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2Lnb5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CardinalClosed", ()=>CardinalClosed
);
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _cardinalJs = require("./cardinal.js");
function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
    areaStart: _noopJsDefault.default,
    areaEnd: _noopJsDefault.default,
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 1:
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
            case 2:
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
            case 3:
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
        }
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._x3 = x, this._y3 = y;
                break;
            case 1:
                this._point = 2;
                this._context.moveTo(this._x4 = x, this._y4 = y);
                break;
            case 2:
                this._point = 3;
                this._x5 = x, this._y5 = y;
                break;
            default:
                _cardinalJs.point(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
exports.default = (function custom(tension1) {
    function cardinal(context) {
        return new CardinalClosed(context, tension1);
    }
    cardinal.tension = function(tension) {
        return custom(+tension);
    };
    return cardinal;
})(0);

},{"../noop.js":"l5hui","./cardinal.js":"lY1cC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lY1cC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "point", ()=>point
);
parcelHelpers.export(exports, "Cardinal", ()=>Cardinal
);
function point(that, x, y) {
    that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
}
function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 2:
                this._context.lineTo(this._x2, this._y2);
                break;
            case 3:
                point(this, this._x1, this._y1);
                break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                this._x1 = x, this._y1 = y;
                break;
            case 2:
                this._point = 3; // proceed
            default:
                point(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
exports.default = (function custom(tension1) {
    function cardinal(context) {
        return new Cardinal(context, tension1);
    }
    cardinal.tension = function(tension) {
        return custom(+tension);
    };
    return cardinal;
})(0);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"imrN3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CardinalOpen", ()=>CardinalOpen
);
var _cardinalJs = require("./cardinal.js");
function CardinalOpen(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                break;
            case 3:
                this._point = 4; // proceed
            default:
                _cardinalJs.point(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
exports.default = (function custom(tension1) {
    function cardinal(context) {
        return new CardinalOpen(context, tension1);
    }
    cardinal.tension = function(tension) {
        return custom(+tension);
    };
    return cardinal;
})(0);

},{"./cardinal.js":"lY1cC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"j5Vzy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cardinalClosedJs = require("./cardinalClosed.js");
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _catmullRomJs = require("./catmullRom.js");
function CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
}
CatmullRomClosed.prototype = {
    areaStart: _noopJsDefault.default,
    areaEnd: _noopJsDefault.default,
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 1:
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
            case 2:
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
            case 3:
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
        }
    },
    point: function(x, y) {
        x = +x, y = +y;
        if (this._point) {
            var x23 = this._x2 - x, y23 = this._y2 - y;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch(this._point){
            case 0:
                this._point = 1;
                this._x3 = x, this._y3 = y;
                break;
            case 1:
                this._point = 2;
                this._context.moveTo(this._x4 = x, this._y4 = y);
                break;
            case 2:
                this._point = 3;
                this._x5 = x, this._y5 = y;
                break;
            default:
                _catmullRomJs.point(this, x, y);
                break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
exports.default = (function custom(alpha1) {
    function catmullRom(context) {
        return alpha1 ? new CatmullRomClosed(context, alpha1) : new _cardinalClosedJs.CardinalClosed(context, 0);
    }
    catmullRom.alpha = function(alpha) {
        return custom(+alpha);
    };
    return catmullRom;
})(0.5);

},{"./cardinalClosed.js":"2Lnb5","../noop.js":"l5hui","./catmullRom.js":"alELy","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"alELy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "point", ()=>point
);
var _mathJs = require("../math.js");
var _cardinalJs = require("./cardinal.js");
function point(that, x, y) {
    var x1 = that._x1, y1 = that._y1, x2 = that._x2, y2 = that._y2;
    if (that._l01_a > _mathJs.epsilon) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
    }
    if (that._l23_a > _mathJs.epsilon) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
    }
    that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
}
CatmullRom.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 2:
                this._context.lineTo(this._x2, this._y2);
                break;
            case 3:
                this.point(this._x2, this._y2);
                break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        if (this._point) {
            var x23 = this._x2 - x, y23 = this._y2 - y;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3; // proceed
            default:
                point(this, x, y);
                break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
exports.default = (function custom(alpha1) {
    function catmullRom(context) {
        return alpha1 ? new CatmullRom(context, alpha1) : new _cardinalJs.Cardinal(context, 0);
    }
    catmullRom.alpha = function(alpha) {
        return custom(+alpha);
    };
    return catmullRom;
})(0.5);

},{"../math.js":"9EE85","./cardinal.js":"lY1cC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fw3h3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cardinalOpenJs = require("./cardinalOpen.js");
var _catmullRomJs = require("./catmullRom.js");
function CatmullRomOpen(context, alpha) {
    this._context = context;
    this._alpha = alpha;
}
CatmullRomOpen.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        if (this._point) {
            var x23 = this._x2 - x, y23 = this._y2 - y;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch(this._point){
            case 0:
                this._point = 1;
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                break;
            case 3:
                this._point = 4; // proceed
            default:
                _catmullRomJs.point(this, x, y);
                break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
exports.default = (function custom(alpha1) {
    function catmullRom(context) {
        return alpha1 ? new CatmullRomOpen(context, alpha1) : new _cardinalOpenJs.CardinalOpen(context, 0);
    }
    catmullRom.alpha = function(alpha) {
        return custom(+alpha);
    };
    return catmullRom;
})(0.5);

},{"./cardinalOpen.js":"imrN3","./catmullRom.js":"alELy","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6OXjp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
function LinearClosed(context) {
    this._context = context;
}
LinearClosed.prototype = {
    areaStart: _noopJsDefault.default,
    areaEnd: _noopJsDefault.default,
    lineStart: function() {
        this._point = 0;
    },
    lineEnd: function() {
        if (this._point) this._context.closePath();
    },
    point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
    }
};
exports.default = function(context) {
    return new LinearClosed(context);
};

},{"../noop.js":"l5hui","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ej0HE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "monotoneX", ()=>monotoneX
);
parcelHelpers.export(exports, "monotoneY", ()=>monotoneY
);
function sign(x) {
    return x < 0 ? -1 : 1;
}
// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
    var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
// Calculate a one-sided slope.
function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
    var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}
function MonotoneX(context) {
    this._context = context;
}
MonotoneX.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
            case 3:
                point(this, this._t0, slope2(this, this._t0));
                break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        var t1 = NaN;
        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                point(this, slope2(this, t1 = slope3(this, x, y)), t1);
                break;
            default:
                point(this, this._t0, t1 = slope3(this, x, y));
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
    }
};
function MonotoneY(context) {
    this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
    MonotoneX.prototype.point.call(this, y, x);
};
function ReflectContext(context) {
    this._context = context;
}
ReflectContext.prototype = {
    moveTo: function(x, y) {
        this._context.moveTo(y, x);
    },
    closePath: function() {
        this._context.closePath();
    },
    lineTo: function(x, y) {
        this._context.lineTo(y, x);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
    }
};
function monotoneX(context) {
    return new MonotoneX(context);
}
function monotoneY(context) {
    return new MonotoneY(context);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kU29F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function Natural(context) {
    this._context = context;
}
Natural.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x = [];
        this._y = [];
    },
    lineEnd: function() {
        var x = this._x, y = this._y, n = x.length;
        if (n) {
            this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
            if (n === 2) this._context.lineTo(x[1], y[1]);
            else {
                var px = controlPoints(x), py = controlPoints(y);
                for(var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1)this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
        }
        if (this._line || this._line !== 0 && n === 1) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
    },
    point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
    }
};
// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
    var i, n = x.length - 1, m, a = new Array(n), b = new Array(n), r = new Array(n);
    a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
    for(i = 1; i < n - 1; ++i)a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
    a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
    for(i = 1; i < n; ++i)m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
    a[n - 1] = r[n - 1] / b[n - 1];
    for(i = n - 2; i >= 0; --i)a[i] = (r[i] - a[i + 1]) / b[i];
    b[n - 1] = (x[n] + a[n - 1]) / 2;
    for(i = 0; i < n - 1; ++i)b[i] = 2 * x[i + 1] - a[i + 1];
    return [
        a,
        b
    ];
}
exports.default = function(context) {
    return new Natural(context);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2h2VG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stepBefore", ()=>stepBefore
);
parcelHelpers.export(exports, "stepAfter", ()=>stepAfter
);
function Step(context, t) {
    this._context = context;
    this._t = t;
}
Step.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2; // proceed
            default:
                if (this._t <= 0) {
                    this._context.lineTo(this._x, y);
                    this._context.lineTo(x, y);
                } else {
                    var x1 = this._x * (1 - this._t) + x * this._t;
                    this._context.lineTo(x1, this._y);
                    this._context.lineTo(x1, y);
                }
                break;
        }
        this._x = x, this._y = y;
    }
};
exports.default = function(context) {
    return new Step(context, 0.5);
};
function stepBefore(context) {
    return new Step(context, 0);
}
function stepAfter(context) {
    return new Step(context, 1);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8FoPn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayJs = require("./array.js");
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _noneJs = require("./offset/none.js");
var _noneJsDefault = parcelHelpers.interopDefault(_noneJs);
var _noneJs1 = require("./order/none.js");
var _noneJsDefault1 = parcelHelpers.interopDefault(_noneJs1);
function stackValue(d, key) {
    return d[key];
}
exports.default = function() {
    var keys = _constantJsDefault.default([]), order = _noneJsDefault1.default, offset = _noneJsDefault.default, value = stackValue;
    function stack(data) {
        var kz = keys.apply(this, arguments), i, m = data.length, n = kz.length, sz = new Array(n), oz;
        for(i = 0; i < n; ++i){
            for(var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j){
                si[j] = sij = [
                    0,
                    +value(data[j], ki, j, data)
                ];
                sij.data = data[j];
            }
            si.key = ki;
        }
        for(i = 0, oz = order(sz); i < n; ++i)sz[oz[i]].index = i;
        offset(sz, oz);
        return sz;
    }
    stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : _constantJsDefault.default(_arrayJs.slice.call(_)), stack) : keys;
    };
    stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : _constantJsDefault.default(+_), stack) : value;
    };
    stack.order = function(_) {
        return arguments.length ? (order = _ == null ? _noneJsDefault1.default : typeof _ === "function" ? _ : _constantJsDefault.default(_arrayJs.slice.call(_)), stack) : order;
    };
    stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? _noneJsDefault.default : _, stack) : offset;
    };
    return stack;
};

},{"./array.js":"h9Y8M","./constant.js":"eKjAq","./offset/none.js":"kmdsk","./order/none.js":"7PXGK","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kmdsk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(series, order) {
    if (!((n = series.length) > 1)) return;
    for(var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i){
        s0 = s1, s1 = series[order[i]];
        for(j = 0; j < m; ++j)s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7PXGK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(series) {
    var n = series.length, o = new Array(n);
    while(--n >= 0)o[n] = n;
    return o;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kheNr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noneJs = require("./none.js");
var _noneJsDefault = parcelHelpers.interopDefault(_noneJs);
exports.default = function(series, order) {
    if (!((n = series.length) > 0)) return;
    for(var i, n, j = 0, m = series[0].length, y; j < m; ++j){
        for(y = i = 0; i < n; ++i)y += series[i][j][1] || 0;
        if (y) for(i = 0; i < n; ++i)series[i][j][1] /= y;
    }
    _noneJsDefault.default(series, order);
};

},{"./none.js":"kmdsk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ahsJE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(series, order) {
    if (!((n = series.length) > 0)) return;
    for(var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j)for(yp = yn = 0, i = 0; i < n; ++i){
        if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) d[0] = yp, d[1] = yp += dy;
        else if (dy < 0) d[1] = yn, d[0] = yn += dy;
        else d[0] = 0, d[1] = dy;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"isPKf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noneJs = require("./none.js");
var _noneJsDefault = parcelHelpers.interopDefault(_noneJs);
exports.default = function(series, order) {
    if (!((n = series.length) > 0)) return;
    for(var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j){
        for(var i = 0, y = 0; i < n; ++i)y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
    }
    _noneJsDefault.default(series, order);
};

},{"./none.js":"kmdsk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eeem3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noneJs = require("./none.js");
var _noneJsDefault = parcelHelpers.interopDefault(_noneJs);
exports.default = function(series, order) {
    if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
    for(var y = 0, j = 1, s0, m, n; j < m; ++j){
        for(var i = 0, s1 = 0, s2 = 0; i < n; ++i){
            var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
            for(var k = 0; k < i; ++k){
                var sk = series[order[k]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
                s3 += skj0 - skj1;
            }
            s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    _noneJsDefault.default(series, order);
};

},{"./none.js":"kmdsk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cq85r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noneJs = require("./none.js");
var _noneJsDefault = parcelHelpers.interopDefault(_noneJs);
exports.default = function(series) {
    var peaks = series.map(peak);
    return _noneJsDefault.default(series).sort(function(a, b) {
        return peaks[a] - peaks[b];
    });
};
function peak(series) {
    var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
    while(++i < n)if ((vi = +series[i][1]) > vj) vj = vi, j = i;
    return j;
}

},{"./none.js":"7PXGK","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"02faF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sum", ()=>sum
);
var _noneJs = require("./none.js");
var _noneJsDefault = parcelHelpers.interopDefault(_noneJs);
exports.default = function(series) {
    var sums = series.map(sum);
    return _noneJsDefault.default(series).sort(function(a, b) {
        return sums[a] - sums[b];
    });
};
function sum(series) {
    var s = 0, i = -1, n = series.length, v;
    while(++i < n)if (v = +series[i][1]) s += v;
    return s;
}

},{"./none.js":"7PXGK","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9HajE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _ascendingJs = require("./ascending.js");
var _ascendingJsDefault = parcelHelpers.interopDefault(_ascendingJs);
exports.default = function(series) {
    return _ascendingJsDefault.default(series).reverse();
};

},{"./ascending.js":"02faF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kFg22":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _appearanceJs = require("./appearance.js");
var _appearanceJsDefault = parcelHelpers.interopDefault(_appearanceJs);
var _ascendingJs = require("./ascending.js");
exports.default = function(series) {
    var n = series.length, i, j, sums = series.map(_ascendingJs.sum), order = _appearanceJsDefault.default(series), top = 0, bottom = 0, tops = [], bottoms = [];
    for(i = 0; i < n; ++i){
        j = order[i];
        if (top < bottom) {
            top += sums[j];
            tops.push(j);
        } else {
            bottom += sums[j];
            bottoms.push(j);
        }
    }
    return bottoms.reverse().concat(tops);
};

},{"./appearance.js":"cq85r","./ascending.js":"02faF","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6qcQw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noneJs = require("./none.js");
var _noneJsDefault = parcelHelpers.interopDefault(_noneJs);
exports.default = function(series) {
    return _noneJsDefault.default(series).reverse();
};

},{"./none.js":"7PXGK","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1EzfH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "voronoi", ()=>_voronoiDefault.default
);
var _voronoi = require("./voronoi");
var _voronoiDefault = parcelHelpers.interopDefault(_voronoi);

},{"./voronoi":"4wlI5","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4wlI5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constant = require("./constant");
var _constantDefault = parcelHelpers.interopDefault(_constant);
var _point = require("./point");
var _diagram = require("./Diagram");
var _diagramDefault = parcelHelpers.interopDefault(_diagram);
exports.default = function() {
    var x = _point.x, y = _point.y, extent = null;
    function voronoi(data) {
        return new _diagramDefault.default(data.map(function(d, i) {
            var s = [
                Math.round(x(d, i, data) / _diagram.epsilon) * _diagram.epsilon,
                Math.round(y(d, i, data) / _diagram.epsilon) * _diagram.epsilon
            ];
            s.index = i;
            s.data = d;
            return s;
        }), extent);
    }
    voronoi.polygons = function(data) {
        return voronoi(data).polygons();
    };
    voronoi.links = function(data) {
        return voronoi(data).links();
    };
    voronoi.triangles = function(data) {
        return voronoi(data).triangles();
    };
    voronoi.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : _constantDefault.default(+_), voronoi) : x;
    };
    voronoi.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : _constantDefault.default(+_), voronoi) : y;
    };
    voronoi.extent = function(_) {
        return arguments.length ? (extent = _ == null ? null : [
            [
                +_[0][0],
                +_[0][1]
            ],
            [
                +_[1][0],
                +_[1][1]
            ]
        ], voronoi) : extent && [
            [
                extent[0][0],
                extent[0][1]
            ],
            [
                extent[1][0],
                extent[1][1]
            ]
        ];
    };
    voronoi.size = function(_) {
        return arguments.length ? (extent = _ == null ? null : [
            [
                0,
                0
            ],
            [
                +_[0],
                +_[1]
            ]
        ], voronoi) : extent && [
            extent[1][0] - extent[0][0],
            extent[1][1] - extent[0][1]
        ];
    };
    return voronoi;
};

},{"./constant":"a7Jzk","./point":"kXIKp","./Diagram":"47GiB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"a7Jzk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kXIKp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "x", ()=>x
);
parcelHelpers.export(exports, "y", ()=>y
);
function x(d) {
    return d[0];
}
function y(d) {
    return d[1];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"47GiB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "epsilon", ()=>epsilon
);
parcelHelpers.export(exports, "epsilon2", ()=>epsilon2
);
parcelHelpers.export(exports, "beaches", ()=>beaches
);
parcelHelpers.export(exports, "cells", ()=>cells
);
parcelHelpers.export(exports, "circles", ()=>circles
);
parcelHelpers.export(exports, "edges", ()=>edges1
);
var _beach = require("./Beach");
var _cell = require("./Cell");
var _circle = require("./Circle");
var _edge = require("./Edge");
var _redBlackTree = require("./RedBlackTree");
var _redBlackTreeDefault = parcelHelpers.interopDefault(_redBlackTree);
var epsilon = 0.000001;
var epsilon2 = 0.000000000001;
var beaches;
var cells;
var circles;
var edges1;
function triangleArea(a, b, c) {
    return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}
function lexicographic(a, b) {
    return b[1] - a[1] || b[0] - a[0];
}
function Diagram(sites, extent) {
    var site = sites.sort(lexicographic).pop(), x, y, circle;
    edges1 = [];
    cells = new Array(sites.length);
    beaches = new _redBlackTreeDefault.default;
    circles = new _redBlackTreeDefault.default;
    while(true){
        circle = _circle.firstCircle;
        if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
            if (site[0] !== x || site[1] !== y) {
                _beach.addBeach(site);
                x = site[0], y = site[1];
            }
            site = sites.pop();
        } else if (circle) _beach.removeBeach(circle.arc);
        else break;
    }
    _cell.sortCellHalfedges();
    if (extent) {
        var x0 = +extent[0][0], y0 = +extent[0][1], x1 = +extent[1][0], y1 = +extent[1][1];
        _edge.clipEdges(x0, y0, x1, y1);
        _cell.clipCells(x0, y0, x1, y1);
    }
    this.edges = edges1;
    this.cells = cells;
    beaches = circles = edges1 = cells = null;
}
exports.default = Diagram;
Diagram.prototype = {
    constructor: Diagram,
    polygons: function() {
        var edges = this.edges;
        return this.cells.map(function(cell) {
            var polygon = cell.halfedges.map(function(i) {
                return _cell.cellHalfedgeStart(cell, edges[i]);
            });
            polygon.data = cell.site.data;
            return polygon;
        });
    },
    triangles: function() {
        var triangles = [], edges = this.edges;
        this.cells.forEach(function(cell, i) {
            if (!(m = (halfedges = cell.halfedges).length)) return;
            var site = cell.site, halfedges, j = -1, m, s0, e1 = edges[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
            while(++j < m){
                s0 = s1;
                e1 = edges[halfedges[j]];
                s1 = e1.left === site ? e1.right : e1.left;
                if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) triangles.push([
                    site.data,
                    s0.data,
                    s1.data
                ]);
            }
        });
        return triangles;
    },
    links: function() {
        return this.edges.filter(function(edge) {
            return edge.right;
        }).map(function(edge) {
            return {
                source: edge.left.data,
                target: edge.right.data
            };
        });
    },
    find: function(x, y, radius) {
        var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
        // Use the previously-found cell, or start with an arbitrary one.
        while(!(cell = that.cells[i1]))if (++i1 >= n) return null;
        var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;
        // Traverse the half-edges to find a closer cell, if any.
        do {
            cell = that.cells[i0 = i1], i1 = null;
            cell.halfedges.forEach(function(e) {
                var edge = that.edges[e], v = edge.left;
                if ((v === cell.site || !v) && !(v = edge.right)) return;
                var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
                if (v2 < d2) d2 = v2, i1 = v.index;
            });
        }while (i1 !== null)
        that._found = i0;
        return radius == null || d2 <= radius * radius ? cell.site : null;
    }
};

},{"./Beach":"31Iig","./Cell":"440U1","./Circle":"k1df5","./Edge":"kOS7Q","./RedBlackTree":"2H1d1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"31Iig":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "removeBeach", ()=>removeBeach
);
parcelHelpers.export(exports, "addBeach", ()=>addBeach
);
var _redBlackTree = require("./RedBlackTree");
var _cell = require("./Cell");
var _circle = require("./Circle");
var _edge = require("./Edge");
var _diagram = require("./Diagram");
var beachPool = [];
function Beach() {
    _redBlackTree.RedBlackNode(this);
    this.edge = this.site = this.circle = null;
}
function createBeach(site) {
    var beach = beachPool.pop() || new Beach;
    beach.site = site;
    return beach;
}
function detachBeach(beach) {
    _circle.detachCircle(beach);
    _diagram.beaches.remove(beach);
    beachPool.push(beach);
    _redBlackTree.RedBlackNode(beach);
}
function removeBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = [
        x,
        y
    ], previous = beach.P, next = beach.N, disappearing = [
        beach
    ];
    detachBeach(beach);
    var lArc = previous;
    while(lArc.circle && Math.abs(x - lArc.circle.x) < _diagram.epsilon && Math.abs(y - lArc.circle.cy) < _diagram.epsilon){
        previous = lArc.P;
        disappearing.unshift(lArc);
        detachBeach(lArc);
        lArc = previous;
    }
    disappearing.unshift(lArc);
    _circle.detachCircle(lArc);
    var rArc = next;
    while(rArc.circle && Math.abs(x - rArc.circle.x) < _diagram.epsilon && Math.abs(y - rArc.circle.cy) < _diagram.epsilon){
        next = rArc.N;
        disappearing.push(rArc);
        detachBeach(rArc);
        rArc = next;
    }
    disappearing.push(rArc);
    _circle.detachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for(iArc = 1; iArc < nArcs; ++iArc){
        rArc = disappearing[iArc];
        lArc = disappearing[iArc - 1];
        _edge.setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = _edge.createEdge(lArc.site, rArc.site, null, vertex);
    _circle.attachCircle(lArc);
    _circle.attachCircle(rArc);
}
function addBeach(site) {
    var x = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = _diagram.beaches._;
    while(node){
        dxl = leftBreakPoint(node, directrix) - x;
        if (dxl > _diagram.epsilon) node = node.L;
        else {
            dxr = x - rightBreakPoint(node, directrix);
            if (dxr > _diagram.epsilon) {
                if (!node.R) {
                    lArc = node;
                    break;
                }
                node = node.R;
            } else {
                if (dxl > -_diagram.epsilon) {
                    lArc = node.P;
                    rArc = node;
                } else if (dxr > -_diagram.epsilon) {
                    lArc = node;
                    rArc = node.N;
                } else lArc = rArc = node;
                break;
            }
        }
    }
    _cell.createCell(site);
    var newArc = createBeach(site);
    _diagram.beaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
        _circle.detachCircle(lArc);
        rArc = createBeach(lArc.site);
        _diagram.beaches.insert(newArc, rArc);
        newArc.edge = rArc.edge = _edge.createEdge(lArc.site, newArc.site);
        _circle.attachCircle(lArc);
        _circle.attachCircle(rArc);
        return;
    }
    if (!rArc) {
        newArc.edge = _edge.createEdge(lArc.site, newArc.site);
        return;
    }
    // else lArc !== rArc
    _circle.detachCircle(lArc);
    _circle.detachCircle(rArc);
    var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [
        (cy * hb - by * hc) / d + ax,
        (bx * hc - cx * hb) / d + ay
    ];
    _edge.setEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = _edge.createEdge(lSite, site, null, vertex);
    rArc.edge = _edge.createEdge(site, rSite, null, vertex);
    _circle.attachCircle(lArc);
    _circle.attachCircle(rArc);
}
function leftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
}
function rightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return leftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site[1] === directrix ? site[0] : Infinity;
}

},{"./RedBlackTree":"2H1d1","./Cell":"440U1","./Circle":"k1df5","./Edge":"kOS7Q","./Diagram":"47GiB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2H1d1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RedBlackNode", ()=>RedBlackNode
);
function RedBlackTree() {
    this._ = null; // root node
}
function RedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null; // next node
}
RedBlackTree.prototype = {
    constructor: RedBlackTree,
    insert: function(after, node) {
        var parent, grandpa, uncle;
        if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N) after.N.P = node;
            after.N = node;
            if (after.R) {
                after = after.R;
                while(after.L)after = after.L;
                after.L = node;
            } else after.R = node;
            parent = after;
        } else if (this._) {
            after = RedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
        } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
        }
        node.L = node.R = null;
        node.U = parent;
        node.C = true;
        after = node;
        while(parent && parent.C){
            grandpa = parent.U;
            if (parent === grandpa.L) {
                uncle = grandpa.R;
                if (uncle && uncle.C) {
                    parent.C = uncle.C = false;
                    grandpa.C = true;
                    after = grandpa;
                } else {
                    if (after === parent.R) {
                        RedBlackRotateLeft(this, parent);
                        after = parent;
                        parent = after.U;
                    }
                    parent.C = false;
                    grandpa.C = true;
                    RedBlackRotateRight(this, grandpa);
                }
            } else {
                uncle = grandpa.L;
                if (uncle && uncle.C) {
                    parent.C = uncle.C = false;
                    grandpa.C = true;
                    after = grandpa;
                } else {
                    if (after === parent.L) {
                        RedBlackRotateRight(this, parent);
                        after = parent;
                        parent = after.U;
                    }
                    parent.C = false;
                    grandpa.C = true;
                    RedBlackRotateLeft(this, grandpa);
                }
            }
            parent = after.U;
        }
        this._.C = false;
    },
    remove: function(node) {
        if (node.N) node.N.P = node.P;
        if (node.P) node.P.N = node.N;
        node.N = node.P = null;
        var parent = node.U, sibling, left = node.L, right = node.R, next, red;
        if (!left) next = right;
        else if (!right) next = left;
        else next = RedBlackFirst(right);
        if (parent) {
            if (parent.L === node) parent.L = next;
            else parent.R = next;
        } else this._ = next;
        if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
                parent = next.U;
                next.U = node.U;
                node = next.R;
                parent.L = node;
                next.R = right;
                right.U = next;
            } else {
                next.U = parent;
                parent = next;
                node = next.R;
            }
        } else {
            red = node.C;
            node = next;
        }
        if (node) node.U = parent;
        if (red) return;
        if (node && node.C) {
            node.C = false;
            return;
        }
        do {
            if (node === this._) break;
            if (node === parent.L) {
                sibling = parent.R;
                if (sibling.C) {
                    sibling.C = false;
                    parent.C = true;
                    RedBlackRotateLeft(this, parent);
                    sibling = parent.R;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                    if (!sibling.R || !sibling.R.C) {
                        sibling.L.C = false;
                        sibling.C = true;
                        RedBlackRotateRight(this, sibling);
                        sibling = parent.R;
                    }
                    sibling.C = parent.C;
                    parent.C = sibling.R.C = false;
                    RedBlackRotateLeft(this, parent);
                    node = this._;
                    break;
                }
            } else {
                sibling = parent.L;
                if (sibling.C) {
                    sibling.C = false;
                    parent.C = true;
                    RedBlackRotateRight(this, parent);
                    sibling = parent.L;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                    if (!sibling.L || !sibling.L.C) {
                        sibling.R.C = false;
                        sibling.C = true;
                        RedBlackRotateLeft(this, sibling);
                        sibling = parent.L;
                    }
                    sibling.C = parent.C;
                    parent.C = sibling.L.C = false;
                    RedBlackRotateRight(this, parent);
                    node = this._;
                    break;
                }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
        }while (!node.C)
        if (node) node.C = false;
    }
};
function RedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
        if (parent.L === p) parent.L = q;
        else parent.R = q;
    } else tree._ = q;
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
}
function RedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
        if (parent.L === p) parent.L = q;
        else parent.R = q;
    } else tree._ = q;
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
}
function RedBlackFirst(node) {
    while(node.L)node = node.L;
    return node;
}
exports.default = RedBlackTree;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"440U1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createCell", ()=>createCell
);
parcelHelpers.export(exports, "cellHalfedgeStart", ()=>cellHalfedgeStart
);
parcelHelpers.export(exports, "cellHalfedgeEnd", ()=>cellHalfedgeEnd
);
parcelHelpers.export(exports, "sortCellHalfedges", ()=>sortCellHalfedges
);
parcelHelpers.export(exports, "clipCells", ()=>clipCells
);
var _edge = require("./Edge");
var _diagram = require("./Diagram");
function createCell(site) {
    return _diagram.cells[site.index] = {
        site: site,
        halfedges: []
    };
}
function cellHalfedgeAngle(cell, edge) {
    var site = cell.site, va = edge.left, vb = edge.right;
    if (site === vb) vb = va, va = site;
    if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
    if (site === va) va = edge[1], vb = edge[0];
    else va = edge[0], vb = edge[1];
    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}
function cellHalfedgeStart(cell, edge) {
    return edge[+(edge.left !== cell.site)];
}
function cellHalfedgeEnd(cell, edge) {
    return edge[+(edge.left === cell.site)];
}
function sortCellHalfedges() {
    for(var i = 0, n = _diagram.cells.length, cell, halfedges, j, m; i < n; ++i)if ((cell = _diagram.cells[i]) && (m = (halfedges = cell.halfedges).length)) {
        var index = new Array(m), array = new Array(m);
        for(j = 0; j < m; ++j)index[j] = j, array[j] = cellHalfedgeAngle(cell, _diagram.edges[halfedges[j]]);
        index.sort(function(i, j) {
            return array[j] - array[i];
        });
        for(j = 0; j < m; ++j)array[j] = halfedges[index[j]];
        for(j = 0; j < m; ++j)halfedges[j] = array[j];
    }
}
function clipCells(x0, y0, x1, y1) {
    var nCells = _diagram.cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
    for(iCell = 0; iCell < nCells; ++iCell)if (cell = _diagram.cells[iCell]) {
        site = cell.site;
        halfedges = cell.halfedges;
        iHalfedge = halfedges.length;
        // Remove any dangling clipped edges.
        while(iHalfedge--)if (!_diagram.edges[halfedges[iHalfedge]]) halfedges.splice(iHalfedge, 1);
        // Insert any border edges as necessary.
        iHalfedge = 0, nHalfedges = halfedges.length;
        while(iHalfedge < nHalfedges){
            end = cellHalfedgeEnd(cell, _diagram.edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
            start = cellHalfedgeStart(cell, _diagram.edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
            if (Math.abs(endX - startX) > _diagram.epsilon || Math.abs(endY - startY) > _diagram.epsilon) {
                halfedges.splice(iHalfedge, 0, _diagram.edges.push(_edge.createBorderEdge(site, end, Math.abs(endX - x0) < _diagram.epsilon && y1 - endY > _diagram.epsilon ? [
                    x0,
                    Math.abs(startX - x0) < _diagram.epsilon ? startY : y1
                ] : Math.abs(endY - y1) < _diagram.epsilon && x1 - endX > _diagram.epsilon ? [
                    Math.abs(startY - y1) < _diagram.epsilon ? startX : x1,
                    y1
                ] : Math.abs(endX - x1) < _diagram.epsilon && endY - y0 > _diagram.epsilon ? [
                    x1,
                    Math.abs(startX - x1) < _diagram.epsilon ? startY : y0
                ] : Math.abs(endY - y0) < _diagram.epsilon && endX - x0 > _diagram.epsilon ? [
                    Math.abs(startY - y0) < _diagram.epsilon ? startX : x0,
                    y0
                ] : null)) - 1);
                ++nHalfedges;
            }
        }
        if (nHalfedges) cover = false;
    }
    // If there weren’t any edges, have the closest site cover the extent.
    // It doesn’t matter which corner of the extent we measure!
    if (cover) {
        var dx, dy, d2, dc = Infinity;
        for(iCell = 0, cover = null; iCell < nCells; ++iCell)if (cell = _diagram.cells[iCell]) {
            site = cell.site;
            dx = site[0] - x0;
            dy = site[1] - y0;
            d2 = dx * dx + dy * dy;
            if (d2 < dc) dc = d2, cover = cell;
        }
        if (cover) {
            var v00 = [
                x0,
                y0
            ], v01 = [
                x0,
                y1
            ], v11 = [
                x1,
                y1
            ], v10 = [
                x1,
                y0
            ];
            cover.halfedges.push(_diagram.edges.push(_edge.createBorderEdge(site = cover.site, v00, v01)) - 1, _diagram.edges.push(_edge.createBorderEdge(site, v01, v11)) - 1, _diagram.edges.push(_edge.createBorderEdge(site, v11, v10)) - 1, _diagram.edges.push(_edge.createBorderEdge(site, v10, v00)) - 1);
        }
    }
    // Lastly delete any cells with no edges; these were entirely clipped.
    for(iCell = 0; iCell < nCells; ++iCell){
        if (cell = _diagram.cells[iCell]) {
            if (!cell.halfedges.length) delete _diagram.cells[iCell];
        }
    }
}

},{"./Edge":"kOS7Q","./Diagram":"47GiB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kOS7Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createEdge", ()=>createEdge
);
parcelHelpers.export(exports, "createBorderEdge", ()=>createBorderEdge
);
parcelHelpers.export(exports, "setEdgeEnd", ()=>setEdgeEnd
);
parcelHelpers.export(exports, "clipEdges", ()=>clipEdges
);
var _diagram = require("./Diagram");
function createEdge(left, right, v0, v1) {
    var edge = [
        null,
        null
    ], index = _diagram.edges.push(edge) - 1;
    edge.left = left;
    edge.right = right;
    if (v0) setEdgeEnd(edge, left, right, v0);
    if (v1) setEdgeEnd(edge, right, left, v1);
    _diagram.cells[left.index].halfedges.push(index);
    _diagram.cells[right.index].halfedges.push(index);
    return edge;
}
function createBorderEdge(left, v0, v1) {
    var edge = [
        v0,
        v1
    ];
    edge.left = left;
    return edge;
}
function setEdgeEnd(edge, left, right, vertex) {
    if (!edge[0] && !edge[1]) {
        edge[0] = vertex;
        edge.left = left;
        edge.right = right;
    } else if (edge.left === right) edge[1] = vertex;
    else edge[0] = vertex;
}
// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
    var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x0 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    }
    r = x1 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    }
    r = y0 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    }
    r = y1 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    }
    if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?
    if (t0 > 0) edge[0] = [
        ax + t0 * dx,
        ay + t0 * dy
    ];
    if (t1 < 1) edge[1] = [
        ax + t1 * dx,
        ay + t1 * dy
    ];
    return true;
}
function connectEdge(edge, x0, y0, x1, y1) {
    var v1 = edge[1];
    if (v1) return true;
    var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
        if (fx < x0 || fx >= x1) return;
        if (lx > rx) {
            if (!v0) v0 = [
                fx,
                y0
            ];
            else if (v0[1] >= y1) return;
            v1 = [
                fx,
                y1
            ];
        } else {
            if (!v0) v0 = [
                fx,
                y1
            ];
            else if (v0[1] < y0) return;
            v1 = [
                fx,
                y0
            ];
        }
    } else {
        fm = (lx - rx) / (ry - ly);
        fb = fy - fm * fx;
        if (fm < -1 || fm > 1) {
            if (lx > rx) {
                if (!v0) v0 = [
                    (y0 - fb) / fm,
                    y0
                ];
                else if (v0[1] >= y1) return;
                v1 = [
                    (y1 - fb) / fm,
                    y1
                ];
            } else {
                if (!v0) v0 = [
                    (y1 - fb) / fm,
                    y1
                ];
                else if (v0[1] < y0) return;
                v1 = [
                    (y0 - fb) / fm,
                    y0
                ];
            }
        } else if (ly < ry) {
            if (!v0) v0 = [
                x0,
                fm * x0 + fb
            ];
            else if (v0[0] >= x1) return;
            v1 = [
                x1,
                fm * x1 + fb
            ];
        } else {
            if (!v0) v0 = [
                x1,
                fm * x1 + fb
            ];
            else if (v0[0] < x0) return;
            v1 = [
                x0,
                fm * x0 + fb
            ];
        }
    }
    edge[0] = v0;
    edge[1] = v1;
    return true;
}
function clipEdges(x0, y0, x1, y1) {
    var i = _diagram.edges.length, edge;
    while(i--)if (!connectEdge(edge = _diagram.edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > _diagram.epsilon || Math.abs(edge[0][1] - edge[1][1]) > _diagram.epsilon)) delete _diagram.edges[i];
}

},{"./Diagram":"47GiB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"k1df5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "firstCircle", ()=>firstCircle
);
parcelHelpers.export(exports, "attachCircle", ()=>attachCircle
);
parcelHelpers.export(exports, "detachCircle", ()=>detachCircle
);
var _redBlackTree = require("./RedBlackTree");
var _diagram = require("./Diagram");
var circlePool = [];
var firstCircle;
function Circle() {
    _redBlackTree.RedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
}
function attachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -_diagram.epsilon2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d;
    var circle = circlePool.pop() || new Circle;
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom
    arc.circle = circle;
    var before = null, node = _diagram.circles._;
    while(node){
        if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L) node = node.L;
            else {
                before = node.P;
                break;
            }
        } else if (node.R) node = node.R;
        else {
            before = node;
            break;
        }
    }
    _diagram.circles.insert(before, circle);
    if (!before) firstCircle = circle;
}
function detachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
        if (!circle.P) firstCircle = circle.N;
        _diagram.circles.remove(circle);
        circlePool.push(circle);
        _redBlackTree.RedBlackNode(circle);
        arc.circle = null;
    }
}

},{"./RedBlackTree":"2H1d1","./Diagram":"47GiB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7E00u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zoom", ()=>_zoomJsDefault.default
);
parcelHelpers.export(exports, "zoomTransform", ()=>_transformJsDefault.default
);
parcelHelpers.export(exports, "zoomIdentity", ()=>_transformJs.identity
);
var _zoomJs = require("./zoom.js");
var _zoomJsDefault = parcelHelpers.interopDefault(_zoomJs);
var _transformJs = require("./transform.js");
var _transformJsDefault = parcelHelpers.interopDefault(_transformJs);

},{"./zoom.js":"lIHvw","./transform.js":"aPs4a","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lIHvw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _d3Dispatch = require("d3-dispatch");
var _d3Drag = require("d3-drag");
var _d3Interpolate = require("d3-interpolate");
var _d3Selection = require("d3-selection");
var _d3Transition = require("d3-transition");
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _eventJs = require("./event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _transformJs = require("./transform.js");
var _noeventJs = require("./noevent.js");
var _noeventJsDefault = parcelHelpers.interopDefault(_noeventJs);
// Ignore right-click, since that should open the context menu.
function defaultFilter() {
    return !_d3Selection.event.ctrlKey && !_d3Selection.event.button;
}
function defaultExtent() {
    var e = this;
    if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
            e = e.viewBox.baseVal;
            return [
                [
                    e.x,
                    e.y
                ],
                [
                    e.x + e.width,
                    e.y + e.height
                ]
            ];
        }
        return [
            [
                0,
                0
            ],
            [
                e.width.baseVal.value,
                e.height.baseVal.value
            ]
        ];
    }
    return [
        [
            0,
            0
        ],
        [
            e.clientWidth,
            e.clientHeight
        ]
    ];
}
function defaultTransform() {
    return this.__zoom || _transformJs.identity;
}
function defaultWheelDelta() {
    return -_d3Selection.event.deltaY * (_d3Selection.event.deltaMode === 1 ? 0.05 : _d3Selection.event.deltaMode ? 1 : 0.002);
}
function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform, extent, translateExtent) {
    var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
    return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}
exports.default = function() {
    var filter = defaultFilter, extent1 = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [
        0,
        Infinity
    ], translateExtent = [
        [
            -Infinity,
            -Infinity
        ],
        [
            Infinity,
            Infinity
        ]
    ], duration = 250, interpolate = _d3Interpolate.interpolateZoom, listeners = _d3Dispatch.dispatch("start", "zoom", "end"), touchstarting, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0;
    function zoom(selection) {
        selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    zoom.transform = function(collection, transform, point) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) schedule(collection, transform, point);
        else selection.interrupt().each(function() {
            gesture(this, arguments).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
        });
    };
    zoom.scaleBy = function(selection, k, p) {
        zoom.scaleTo(selection, function() {
            var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
            return k0 * k1;
        }, p);
    };
    zoom.scaleTo = function(selection, k, p) {
        zoom.transform(selection, function() {
            var e = extent1.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
            return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p);
    };
    zoom.translateBy = function(selection, x, y) {
        zoom.transform(selection, function() {
            return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent1.apply(this, arguments), translateExtent);
        });
    };
    zoom.translateTo = function(selection, x, y, p) {
        zoom.transform(selection, function() {
            var e = extent1.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
            return constrain(_transformJs.identity.translate(p0[0], p0[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
        }, p);
    };
    function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new _transformJs.Transform(k, transform.x, transform.y);
    }
    function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new _transformJs.Transform(transform.k, x, y);
    }
    function centroid(extent) {
        return [
            (+extent[0][0] + +extent[1][0]) / 2,
            (+extent[0][1] + +extent[1][1]) / 2
        ];
    }
    function schedule(transition, transform, point) {
        transition.on("start.zoom", function() {
            gesture(this, arguments).start();
        }).on("interrupt.zoom end.zoom", function() {
            gesture(this, arguments).end();
        }).tween("zoom", function() {
            var that = this, args = arguments, g = gesture(that, args), e = extent1.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform === "function" ? transform.apply(that, args) : transform, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
            return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else {
                    var l = i(t), k = w / l[2];
                    t = new _transformJs.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
                }
                g.zoom(null, t);
            };
        });
    }
    function gesture(that, args, clean) {
        return !clean && that.__zooming || new Gesture(that, args);
    }
    function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.extent = extent1.apply(that, args);
        this.taps = 0;
    }
    Gesture.prototype = {
        start: function() {
            if (++this.active === 1) {
                this.that.__zooming = this;
                this.emit("start");
            }
            return this;
        },
        zoom: function(key, transform) {
            if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
            if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
            if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
            this.that.__zoom = transform;
            this.emit("zoom");
            return this;
        },
        end: function() {
            if (--this.active === 0) {
                delete this.that.__zooming;
                this.emit("end");
            }
            return this;
        },
        emit: function(type) {
            _d3Selection.customEvent(new _eventJsDefault.default(zoom, type, this.that.__zoom), listeners.apply, listeners, [
                type,
                this.that,
                this.args
            ]);
        }
    };
    function wheeled() {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, arguments), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = _d3Selection.mouse(this);
        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
            if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) g.mouse[1] = t.invert(g.mouse[0] = p);
            clearTimeout(g.wheel);
        } else if (t.k === k) return;
        else {
            g.mouse = [
                p,
                t.invert(p)
            ];
            _d3Transition.interrupt(this);
            g.start();
        }
        _noeventJsDefault.default();
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
        function wheelidled() {
            g.wheel = null;
            g.end();
        }
    }
    function mousedowned() {
        if (touchending || !filter.apply(this, arguments)) return;
        var g = gesture(this, arguments, true), v = _d3Selection.select(_d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = _d3Selection.mouse(this), x0 = _d3Selection.event.clientX, y0 = _d3Selection.event.clientY;
        _d3Drag.dragDisable(_d3Selection.event.view);
        _noeventJs.nopropagation();
        g.mouse = [
            p,
            this.__zoom.invert(p)
        ];
        _d3Transition.interrupt(this);
        g.start();
        function mousemoved() {
            _noeventJsDefault.default();
            if (!g.moved) {
                var dx = _d3Selection.event.clientX - x0, dy = _d3Selection.event.clientY - y0;
                g.moved = dx * dx + dy * dy > clickDistance2;
            }
            g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = _d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
        }
        function mouseupped() {
            v.on("mousemove.zoom mouseup.zoom", null);
            _d3Drag.dragEnable(_d3Selection.event.view, g.moved);
            _noeventJsDefault.default();
            g.end();
        }
    }
    function dblclicked() {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom, p0 = _d3Selection.mouse(this), p1 = t0.invert(p0), k1 = t0.k * (_d3Selection.event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent1.apply(this, arguments), translateExtent);
        _noeventJsDefault.default();
        if (duration > 0) _d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
        else _d3Selection.select(this).call(zoom.transform, t1);
    }
    function touchstarted() {
        if (!filter.apply(this, arguments)) return;
        var touches = _d3Selection.event.touches, n = touches.length, g = gesture(this, arguments, _d3Selection.event.changedTouches.length === n), started, i, t, p;
        _noeventJs.nopropagation();
        for(i = 0; i < n; ++i){
            t = touches[i], p = _d3Selection.touch(this, touches, t.identifier);
            p = [
                p,
                this.__zoom.invert(p),
                t.identifier
            ];
            if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
            else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }
        if (touchstarting) touchstarting = clearTimeout(touchstarting);
        if (started) {
            if (g.taps < 2) touchstarting = setTimeout(function() {
                touchstarting = null;
            }, touchDelay);
            _d3Transition.interrupt(this);
            g.start();
        }
    }
    function touchmoved() {
        if (!this.__zooming) return;
        var g = gesture(this, arguments), touches = _d3Selection.event.changedTouches, n = touches.length, i, t, p, l;
        _noeventJsDefault.default();
        if (touchstarting) touchstarting = clearTimeout(touchstarting);
        g.taps = 0;
        for(i = 0; i < n; ++i){
            t = touches[i], p = _d3Selection.touch(this, touches, t.identifier);
            if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
            else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
            var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
            t = scale(t, Math.sqrt(dp / dl));
            p = [
                (p0[0] + p1[0]) / 2,
                (p0[1] + p1[1]) / 2
            ];
            l = [
                (l0[0] + l1[0]) / 2,
                (l0[1] + l1[1]) / 2
            ];
        } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;
        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
    }
    function touchended() {
        if (!this.__zooming) return;
        var g = gesture(this, arguments), touches = _d3Selection.event.changedTouches, n = touches.length, i, t;
        _noeventJs.nopropagation();
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() {
            touchending = null;
        }, touchDelay);
        for(i = 0; i < n; ++i){
            t = touches[i];
            if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
            else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
            g.end();
            // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
            if (g.taps === 2) {
                var p = _d3Selection.select(this).on("dblclick.zoom");
                if (p) p.apply(this, arguments);
            }
        }
    }
    zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : _constantJsDefault.default(+_), zoom) : wheelDelta;
    };
    zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : _constantJsDefault.default(!!_), zoom) : filter;
    };
    zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : _constantJsDefault.default(!!_), zoom) : touchable;
    };
    zoom.extent = function(_) {
        return arguments.length ? (extent1 = typeof _ === "function" ? _ : _constantJsDefault.default([
            [
                +_[0][0],
                +_[0][1]
            ],
            [
                +_[1][0],
                +_[1][1]
            ]
        ]), zoom) : extent1;
    };
    zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [
            scaleExtent[0],
            scaleExtent[1]
        ];
    };
    zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [
            [
                translateExtent[0][0],
                translateExtent[0][1]
            ],
            [
                translateExtent[1][0],
                translateExtent[1][1]
            ]
        ];
    };
    zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
    };
    zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
    };
    zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
    };
    zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
    };
    zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
    };
    return zoom;
};

},{"d3-dispatch":"9d2te","d3-drag":"dKCUo","d3-interpolate":"e7XwA","d3-selection":"hgWtk","d3-transition":"cRYyR","./constant.js":"5Itz2","./event.js":"bMq36","./transform.js":"aPs4a","./noevent.js":"cgyVb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5Itz2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = function(x) {
    return function() {
        return x;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bMq36":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function ZoomEvent(target, type, transform) {
    this.target = target;
    this.type = type;
    this.transform = transform;
}
exports.default = ZoomEvent;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aPs4a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transform", ()=>Transform
);
parcelHelpers.export(exports, "identity", ()=>identity
);
function Transform(k, x, y) {
    this.k = k;
    this.x = x;
    this.y = y;
}
Transform.prototype = {
    constructor: Transform,
    scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
    },
    translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
    },
    apply: function(point) {
        return [
            point[0] * this.k + this.x,
            point[1] * this.k + this.y
        ];
    },
    applyX: function(x) {
        return x * this.k + this.x;
    },
    applyY: function(y) {
        return y * this.k + this.y;
    },
    invert: function(location) {
        return [
            (location[0] - this.x) / this.k,
            (location[1] - this.y) / this.k
        ];
    },
    invertX: function(x) {
        return (x - this.x) / this.k;
    },
    invertY: function(y) {
        return (y - this.y) / this.k;
    },
    rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
    },
    rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
    },
    toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
    while(!node.__zoom)if (!(node = node.parentNode)) return identity;
    return node.__zoom;
}
exports.default = transform;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cgyVb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nopropagation", ()=>nopropagation
);
var _d3Selection = require("d3-selection");
function nopropagation() {
    _d3Selection.event.stopImmediatePropagation();
}
exports.default = function() {
    _d3Selection.event.preventDefault();
    _d3Selection.event.stopImmediatePropagation();
};

},{"d3-selection":"hgWtk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ki8vQ":[function(require,module,exports) {
/*!Please JS v0.4.2, Jordan Checkman 2014, Checkman.io, MIT License, Have fun.*/ !function(e, r, a) {
    "function" == typeof define && define.amd ? define([], a) : "object" == typeof exports ? module.exports = a() : r[e] = a();
}("Please", this, function() {
    "use strict";
    function e1() {
        function e2(e, r, a) {
            var o = Math.random;
            return a instanceof l1 && (o = a.random), Math.floor(o() * (r - e + 1)) + e;
        }
        function r1(e, r, a) {
            var o = Math.random;
            return a instanceof l1 && (o = a.random), o() * (r - e) + e;
        }
        function a1(e, r, a) {
            return Math.max(r, Math.min(e, a));
        }
        function o1(e, r) {
            var a;
            switch(e){
                case "hex":
                    for(a = 0; a < r.length; a++)r[a] = F1.HSV_to_HEX(r[a]);
                    break;
                case "rgb":
                    for(a = 0; a < r.length; a++)r[a] = F1.HSV_to_RGB(r[a]);
                    break;
                case "rgb-string":
                    for(a = 0; a < r.length; a++){
                        var o = F1.HSV_to_RGB(r[a]);
                        r[a] = "rgb(" + o.r + "," + o.g + "," + o.b + ")";
                    }
                    break;
                case "hsv":
                    break;
                default:
                    console.error("Format not recognized.");
            }
            return r;
        }
        function n1(e) {
            var r = F1.HSV_to_RGB(e), a = (299 * r.r + 587 * r.g + 114 * r.b) / 1000;
            return a >= 128 ? "dark" : "light";
        }
        function t1(e) {
            var r = {
            };
            for(var a in e)e.hasOwnProperty(a) && (r[a] = e[a]);
            return r;
        }
        function l1(e3) {
            function r() {
                o2 = (o2 + 1) % 256, n = (n + a2[o2]) % 256;
                var e = a2[o2];
                return a2[o2] = a2[n], a2[n] = e, a2[(a2[o2] + a2[n]) % 256];
            }
            for(var a2 = [], o2 = 0, n = 0, t = 0; 256 > t; t++)a2[t] = t;
            for(var l = 0, F = 0; 256 > l; l++){
                F = (F + a2[l] + e3.charCodeAt(l % e3.length)) % 256;
                var s = a2[l];
                a2[l] = a2[F], a2[F] = s;
            }
            this.random = function() {
                for(var e = 0, a = 0, o = 1; 8 > e; e++)a += r() * o, o *= 256;
                return a / 18446744073709552000;
            };
        }
        var F1 = {
        }, s1 = {
            aliceblue: "F0F8FF",
            antiquewhite: "FAEBD7",
            aqua: "00FFFF",
            aquamarine: "7FFFD4",
            azure: "F0FFFF",
            beige: "F5F5DC",
            bisque: "FFE4C4",
            black: "000000",
            blanchedalmond: "FFEBCD",
            blue: "0000FF",
            blueviolet: "8A2BE2",
            brown: "A52A2A",
            burlywood: "DEB887",
            cadetblue: "5F9EA0",
            chartreuse: "7FFF00",
            chocolate: "D2691E",
            coral: "FF7F50",
            cornflowerblue: "6495ED",
            cornsilk: "FFF8DC",
            crimson: "DC143C",
            cyan: "00FFFF",
            darkblue: "00008B",
            darkcyan: "008B8B",
            darkgoldenrod: "B8860B",
            darkgray: "A9A9A9",
            darkgrey: "A9A9A9",
            darkgreen: "006400",
            darkkhaki: "BDB76B",
            darkmagenta: "8B008B",
            darkolivegreen: "556B2F",
            darkorange: "FF8C00",
            darkorchid: "9932CC",
            darkred: "8B0000",
            darksalmon: "E9967A",
            darkseagreen: "8FBC8F",
            darkslateblue: "483D8B",
            darkslategray: "2F4F4F",
            darkslategrey: "2F4F4F",
            darkturquoise: "00CED1",
            darkviolet: "9400D3",
            deeppink: "FF1493",
            deepskyblue: "00BFFF",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1E90FF",
            firebrick: "B22222",
            floralwhite: "FFFAF0",
            forestgreen: "228B22",
            fuchsia: "FF00FF",
            gainsboro: "DCDCDC",
            ghostwhite: "F8F8FF",
            gold: "FFD700",
            goldenrod: "DAA520",
            gray: "808080",
            grey: "808080",
            green: "008000",
            greenyellow: "ADFF2F",
            honeydew: "F0FFF0",
            hotpink: "FF69B4",
            indianred: "CD5C5C",
            indigo: "4B0082",
            ivory: "FFFFF0",
            khaki: "F0E68C",
            lavender: "E6E6FA",
            lavenderblush: "FFF0F5",
            lawngreen: "7CFC00",
            lemonchiffon: "FFFACD",
            lightblue: "ADD8E6",
            lightcoral: "F08080",
            lightcyan: "E0FFFF",
            lightgoldenrodyellow: "FAFAD2",
            lightgray: "D3D3D3",
            lightgrey: "D3D3D3",
            lightgreen: "90EE90",
            lightpink: "FFB6C1",
            lightsalmon: "FFA07A",
            lightseagreen: "20B2AA",
            lightskyblue: "87CEFA",
            lightslategray: "778899",
            lightslategrey: "778899",
            lightsteelblue: "B0C4DE",
            lightyellow: "FFFFE0",
            lime: "00FF00",
            limegreen: "32CD32",
            linen: "FAF0E6",
            magenta: "FF00FF",
            maroon: "800000",
            mediumaquamarine: "66CDAA",
            mediumblue: "0000CD",
            mediumorchid: "BA55D3",
            mediumpurple: "9370D8",
            mediumseagreen: "3CB371",
            mediumslateblue: "7B68EE",
            mediumspringgreen: "00FA9A",
            mediumturquoise: "48D1CC",
            mediumvioletred: "C71585",
            midnightblue: "191970",
            mintcream: "F5FFFA",
            mistyrose: "FFE4E1",
            moccasin: "FFE4B5",
            navajowhite: "FFDEAD",
            navy: "000080",
            oldlace: "FDF5E6",
            olive: "808000",
            olivedrab: "6B8E23",
            orange: "FFA500",
            orangered: "FF4500",
            orchid: "DA70D6",
            palegoldenrod: "EEE8AA",
            palegreen: "98FB98",
            paleturquoise: "AFEEEE",
            palevioletred: "D87093",
            papayawhip: "FFEFD5",
            peachpuff: "FFDAB9",
            peru: "CD853F",
            pink: "FFC0CB",
            plum: "DDA0DD",
            powderblue: "B0E0E6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "FF0000",
            rosybrown: "BC8F8F",
            royalblue: "4169E1",
            saddlebrown: "8B4513",
            salmon: "FA8072",
            sandybrown: "F4A460",
            seagreen: "2E8B57",
            seashell: "FFF5EE",
            sienna: "A0522D",
            silver: "C0C0C0",
            skyblue: "87CEEB",
            slateblue: "6A5ACD",
            slategray: "708090",
            slategrey: "708090",
            snow: "FFFAFA",
            springgreen: "00FF7F",
            steelblue: "4682B4",
            tan: "D2B48C",
            teal: "008080",
            thistle: "D8BFD8",
            tomato: "FF6347",
            turquoise: "40E0D0",
            violet: "EE82EE",
            wheat: "F5DEB3",
            white: "FFFFFF",
            whitesmoke: "F5F5F5",
            yellow: "FFFF00",
            yellowgreen: "9ACD32"
        }, i1 = 0.618033988749895, u1 = {
            hue: null,
            saturation: null,
            value: null,
            base_color: "",
            greyscale: !1,
            grayscale: !1,
            golden: !0,
            full_random: !1,
            colors_returned: 1,
            format: "hex",
            seed: null
        }, c1 = {
            scheme_type: "analogous",
            format: "hex"
        }, h1 = {
            golden: !1,
            format: "hex"
        };
        return F1.NAME_to_HEX = function(e) {
            return e = e.toLowerCase(), e in s1 ? s1[e] : (console.error("Color name not recognized."), void 0);
        }, F1.NAME_to_RGB = function(e) {
            return F1.HEX_to_RGB(F1.NAME_to_HEX(e));
        }, F1.NAME_to_HSV = function(e) {
            return F1.HEX_to_HSV(F1.NAME_to_HEX(e));
        }, F1.HEX_to_RGB = function(e) {
            var r2 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            e = e.replace(r2, function(e, r, a, o) {
                return r + r + a + a + o + o;
            });
            var a3 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
            return a3 ? {
                r: parseInt(a3[1], 16),
                g: parseInt(a3[2], 16),
                b: parseInt(a3[3], 16)
            } : null;
        }, F1.RGB_to_HEX = function(e) {
            return "#" + (16777216 + (e.r << 16) + (e.g << 8) + e.b).toString(16).slice(1);
        }, F1.HSV_to_RGB = function(e) {
            var r, a, o, n, t, l, F, s, i = e.h, u = e.s, c = e.v;
            if (0 === u) return {
                r: c,
                g: c,
                b: c
            };
            switch(i /= 60, n = Math.floor(i), t = i - n, l = c * (1 - u), F = c * (1 - u * t), s = c * (1 - u * (1 - t)), n){
                case 0:
                    r = c, a = s, o = l;
                    break;
                case 1:
                    r = F, a = c, o = l;
                    break;
                case 2:
                    r = l, a = c, o = s;
                    break;
                case 3:
                    r = l, a = F, o = c;
                    break;
                case 4:
                    r = s, a = l, o = c;
                    break;
                case 5:
                    r = c, a = l, o = F;
            }
            return {
                r: Math.floor(255 * r),
                g: Math.floor(255 * a),
                b: Math.floor(255 * o)
            };
        }, F1.RGB_to_HSV = function(e) {
            var r = e.r / 255, a = e.g / 255, o = e.b / 255, n = 0, t = 0, l = 0, F = Math.min(r, Math.min(a, o)), s = Math.max(r, Math.max(a, o));
            if (F === s) return l = F, {
                h: 0,
                s: 0,
                v: l
            };
            var i = r === F ? a - o : o === F ? r - a : o - r, u = r === F ? 3 : o === F ? 1 : 5;
            return n = 60 * (u - i / (s - F)), t = (s - F) / s, l = s, {
                h: n,
                s: t,
                v: l
            };
        }, F1.HSV_to_HEX = function(e) {
            return F1.RGB_to_HEX(F1.HSV_to_RGB(e));
        }, F1.HEX_to_HSV = function(e) {
            return F1.RGB_to_HSV(F1.HEX_to_RGB(e));
        }, F1.make_scheme = function(e4, r) {
            function n(e) {
                return {
                    h: e.h,
                    s: e.s,
                    v: e.v
                };
            }
            var l, F, s, i, u, h = t1(c1);
            if (null !== r) for(var d in r)r.hasOwnProperty(d) && (h[d] = r[d]);
            var g = [
                e4
            ];
            switch(h.scheme_type.toLowerCase()){
                case "monochromatic":
                case "mono":
                    for(u = 1; 2 >= u; u++)l = n(e4), s = l.s + 0.1 * u, s = a1(s, 0, 1), i = l.v + 0.1 * u, i = a1(i, 0, 1), l.s = s, l.v = i, g.push(l);
                    for(u = 1; 2 >= u; u++)l = n(e4), s = l.s - 0.1 * u, s = a1(s, 0, 1), i = l.v - 0.1 * u, i = a1(i, 0, 1), l.s = s, l.v = i, g.push(l);
                    break;
                case "complementary":
                case "complement":
                case "comp":
                    l = n(e4), l.h = (l.h + 180) % 360, g.push(l);
                    break;
                case "split-complementary":
                case "split-complement":
                case "split":
                    l = n(e4), l.h = (l.h + 165) % 360, g.push(l), l = n(e4), l.h = Math.abs((l.h - 165) % 360), g.push(l);
                    break;
                case "double-complementary":
                case "double-complement":
                case "double":
                    l = n(e4), l.h = (l.h + 180) % 360, g.push(l), l.h = (l.h + 30) % 360, F = n(l), g.push(l), l.h = (l.h + 180) % 360, g.push(F);
                    break;
                case "analogous":
                case "ana":
                    for(u = 1; 5 >= u; u++)l = n(e4), l.h = (l.h + 20 * u) % 360, g.push(l);
                    break;
                case "triadic":
                case "triad":
                case "tri":
                    for(u = 1; 3 > u; u++)l = n(e4), l.h = (l.h + 120 * u) % 360, g.push(l);
                    break;
                default:
                    console.error("Color scheme not recognized.");
            }
            return o1(h.format.toLowerCase(), g), g;
        }, F1.make_color = function(n) {
            var s = [], c = t1(u1), h = null;
            if (null !== n) for(var d in n)n.hasOwnProperty(d) && (c[d] = n[d]);
            var g = null;
            "string" == typeof c.seed && (g = new l1(c.seed)), c.base_color.length > 0 && (h = c.base_color.match(/^#?([0-9a-f]{3})([0-9a-f]{3})?$/i) ? F1.HEX_to_HSV(c.base_color) : F1.NAME_to_HSV(c.base_color));
            for(var m = 0; m < c.colors_returned; m++){
                var f, E, b, p = e2(0, 360, g);
                null !== h ? (f = a1(e2(h.h - 5, h.h + 5, g), 0, 360), E = 0 === h.s ? 0 : r1(0.4, 0.85, g), b = r1(0.4, 0.85, g), s.push({
                    h: f,
                    s: E,
                    v: b
                })) : (f = c.greyscale === !0 || c.grayscale === !0 ? 0 : c.golden === !0 ? (p + p / i1) % 360 : null === c.hue || c.full_random === !0 ? p : a1(c.hue, 0, 360), E = c.greyscale === !0 || c.grayscale === !0 ? 0 : c.full_random === !0 ? r1(0, 1, g) : null === c.saturation ? 0.4 : a1(c.saturation, 0, 1), b = c.full_random === !0 ? r1(0, 1, g) : c.greyscale === !0 || c.grayscale === !0 ? r1(0.15, 0.75, g) : null === c.value ? 0.75 : a1(c.value, 0, 1), s.push({
                    h: f,
                    s: E,
                    v: b
                }));
            }
            return o1(c.format.toLowerCase(), s), s;
        }, F1.make_contrast = function(e, r) {
            var l = t1(h1);
            if (null !== r) for(var s in r)r.hasOwnProperty(s) && (l[s] = r[s]);
            var u, c, d = n1(e);
            if (l.golden === !0) c = e.h * (1 + i1) % 360;
            else {
                var g = F1.make_scheme(e, {
                    scheme_type: "complementary",
                    format: "hsv"
                })[1];
                c = a1(g.h - 30, 0, 360);
            }
            var m;
            return "dark" === d ? m = a1(e.v - 0.25, 0, 1) : "light" === d && (m = a1(e.v + 0.25, 0, 1)), u = [
                {
                    h: c,
                    s: e.s,
                    v: m
                }
            ], o1(l.format.toLowerCase(), u), u[0];
        }, F1;
    }
    return e1();
});

},{}],"2B6CQ":[function(require,module,exports) {
'use strict';
const uniqueRandomArray = require('unique-random-array');
const htmlColors = require('./html-colors.json');
function names() {
    return Object.keys(htmlColors);
}
function hex(name) {
    if (typeof name !== 'string') throw new TypeError('htmlColors.hex expected a string, got ' + typeof name);
    return htmlColors[name.toLowerCase()];
}
function all() {
    return htmlColors;
}
function random() {
    const keys = Object.keys(htmlColors);
    const randomColor = uniqueRandomArray(keys);
    return randomColor();
}
module.exports = {
    names: names,
    hex: hex,
    all: all,
    random: random
};

},{"unique-random-array":"go3dC","./html-colors.json":"dYmOn"}],"go3dC":[function(require,module,exports) {
'use strict';
var uniqueRandom = require('unique-random');
module.exports = function(arr) {
    var rand = uniqueRandom(0, arr.length - 1);
    return function() {
        return arr[rand()];
    };
};

},{"unique-random":"a0WyC"}],"a0WyC":[function(require,module,exports) {
'use strict';
module.exports = function(min, max) {
    var prev;
    return function rand() {
        var num = Math.floor(Math.random() * (max - min + 1) + min);
        return prev = num === prev && min !== max ? rand() : num;
    };
};

},{}],"dYmOn":[function(require,module,exports) {
module.exports = JSON.parse("{\"black\":\"#000000\",\"silver\":\"#C0C0C0\",\"gray\":\"#808080\",\"grey\":\"#808080\",\"white\":\"#FFFFFF\",\"maroon\":\"#800000\",\"red\":\"#FF0000\",\"purple\":\"#800080\",\"fuchsia\":\"#FF00FF\",\"green\":\"#008000\",\"lime\":\"#00FF00\",\"olive\":\"#808000\",\"yellow\":\"#FFFF00\",\"navy\":\"#000080\",\"blue\":\"#0000FF\",\"teal\":\"#008080\",\"aqua\":\"#00FFFF\",\"darkblue\":\"#00008B\",\"mediumblue\":\"#0000CD\",\"darkgreen\":\"#006400\",\"darkcyan\":\"#008B8B\",\"deepskyblue\":\"#00BFFF\",\"darkturquoise\":\"#00CED1\",\"mediumspringgreen\":\"#00FA9A\",\"springgreen\":\"#00FF7F\",\"cyan\":\"#00FFFF\",\"midnightblue\":\"#191970\",\"dodgerblue\":\"#1E90FF\",\"lightseagreen\":\"#20B2AA\",\"forestgreen\":\"#228B22\",\"seagreen\":\"#2E8B57\",\"darkslategray\":\"#2F4F4F\",\"darkslategrey\":\"#2F4F4F\",\"limegreen\":\"#32CD32\",\"mediumseagreen\":\"#3CB371\",\"turquoise\":\"#40E0D0\",\"royalblue\":\"#4169E1\",\"steelblue\":\"#4682B4\",\"darkslateblue\":\"#483D8B\",\"mediumturquoise\":\"#48D1CC\",\"indigo\":\"#4B0082\",\"darkolivegreen\":\"#556B2F\",\"cadetblue\":\"#5F9EA0\",\"cornflowerblue\":\"#6495ED\",\"rebeccapurple\":\"#663399\",\"mediumaquamarine\":\"#66CDAA\",\"dimgray\":\"#696969\",\"dimgrey\":\"#696969\",\"slateblue\":\"#6A5ACD\",\"olivedrab\":\"#6B8E23\",\"slategray\":\"#708090\",\"slategrey\":\"#708090\",\"lightslategray\":\"#778899\",\"lightslategrey\":\"#778899\",\"mediumslateblue\":\"#7B68EE\",\"lawngreen\":\"#7CFC00\",\"chartreuse\":\"#7FFF00\",\"aquamarine\":\"#7FFFD4\",\"skyblue\":\"#87CEEB\",\"lightskyblue\":\"#87CEFA\",\"blueviolet\":\"#8A2BE2\",\"darkred\":\"#8B0000\",\"darkmagenta\":\"#8B008B\",\"saddlebrown\":\"#8B4513\",\"darkseagreen\":\"#8FBC8F\",\"lightgreen\":\"#90EE90\",\"mediumpurple\":\"#9370DB\",\"darkviolet\":\"#9400D3\",\"palegreen\":\"#98FB98\",\"darkorchid\":\"#9932CC\",\"yellowgreen\":\"#9ACD32\",\"sienna\":\"#A0522D\",\"brown\":\"#A52A2A\",\"darkgray\":\"#A9A9A9\",\"darkgrey\":\"#A9A9A9\",\"lightblue\":\"#ADD8E6\",\"greenyellow\":\"#ADFF2F\",\"paleturquoise\":\"#AFEEEE\",\"lightsteelblue\":\"#B0C4DE\",\"powderblue\":\"#B0E0E6\",\"firebrick\":\"#B22222\",\"darkgoldenrod\":\"#B8860B\",\"mediumorchid\":\"#BA55D3\",\"rosybrown\":\"#BC8F8F\",\"darkkhaki\":\"#BDB76B\",\"mediumvioletred\":\"#C71585\",\"indianred\":\"#CD5C5C\",\"peru\":\"#CD853F\",\"chocolate\":\"#D2691E\",\"tan\":\"#D2B48C\",\"lightgray\":\"#D3D3D3\",\"lightgrey\":\"#D3D3D3\",\"thistle\":\"#D8BFD8\",\"orchid\":\"#DA70D6\",\"goldenrod\":\"#DAA520\",\"palevioletred\":\"#DB7093\",\"crimson\":\"#DC143C\",\"gainsboro\":\"#DCDCDC\",\"plum\":\"#DDA0DD\",\"burlywood\":\"#DEB887\",\"lightcyan\":\"#E0FFFF\",\"lavender\":\"#E6E6FA\",\"darksalmon\":\"#E9967A\",\"violet\":\"#EE82EE\",\"palegoldenrod\":\"#EEE8AA\",\"lightcoral\":\"#F08080\",\"khaki\":\"#F0E68C\",\"aliceblue\":\"#F0F8FF\",\"honeydew\":\"#F0FFF0\",\"azure\":\"#F0FFFF\",\"sandybrown\":\"#F4A460\",\"wheat\":\"#F5DEB3\",\"beige\":\"#F5F5DC\",\"whitesmoke\":\"#F5F5F5\",\"mintcream\":\"#F5FFFA\",\"ghostwhite\":\"#F8F8FF\",\"salmon\":\"#FA8072\",\"antiquewhite\":\"#FAEBD7\",\"linen\":\"#FAF0E6\",\"lightgoldenrodyellow\":\"#FAFAD2\",\"oldlace\":\"#FDF5E6\",\"magenta\":\"#FF00FF\",\"deeppink\":\"#FF1493\",\"orangered\":\"#FF4500\",\"tomato\":\"#FF6347\",\"hotpink\":\"#FF69B4\",\"coral\":\"#FF7F50\",\"darkorange\":\"#FF8C00\",\"lightsalmon\":\"#FFA07A\",\"orange\":\"#FFA500\",\"lightpink\":\"#FFB6C1\",\"pink\":\"#FFC0CB\",\"gold\":\"#FFD700\",\"peachpuff\":\"#FFDAB9\",\"navajowhite\":\"#FFDEAD\",\"moccasin\":\"#FFE4B5\",\"bisque\":\"#FFE4C4\",\"mistyrose\":\"#FFE4E1\",\"blanchedalmond\":\"#FFEBCD\",\"papayawhip\":\"#FFEFD5\",\"lavenderblush\":\"#FFF0F5\",\"seashell\":\"#FFF5EE\",\"cornsilk\":\"#FFF8DC\",\"lemonchiffon\":\"#FFFACD\",\"floralwhite\":\"#FFFAF0\",\"snow\":\"#FFFAFA\",\"lightyellow\":\"#FFFFE0\",\"ivory\":\"#FFFFF0\"}");

},{}]},["4BeY2","29hU0"], "29hU0", "parcelRequire0215")

</script>
<script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"e3EAe":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "0fd80cbee0ad5dd6";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    var parents = getParents(module.bundle.root, id); // If no parents, the asset is new. Prevent reloading the page.
    if (!parents.length) return true;
    return parents.some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"hzbwC":[function(require,module,exports) {
var _graphPropertiesJs = require("./src/graph_properties.js");

},{"./src/graph_properties.js":"6Ena2"}],"6Ena2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sectionHeader", ()=>sectionHeader
);
parcelHelpers.export(exports, "showGraphMinDegree", ()=>showGraphMinDegree
);
parcelHelpers.export(exports, "showGraphMaxDegree", ()=>showGraphMaxDegree
);
parcelHelpers.export(exports, "getVertexId", ()=>getVertexId
);
parcelHelpers.export(exports, "getVertexDegree", ()=>getVertexDegree
);
parcelHelpers.export(exports, "getVertexNeighborhood", ()=>getVertexNeighborhood
);
parcelHelpers.export(exports, "showGraphRegular", ()=>showGraphRegular
);
parcelHelpers.export(exports, "showGroups", ()=>showGroups
);
parcelHelpers.export(exports, "showAdjacencyMatrix", ()=>showAdjacencyMatrix
);
parcelHelpers.export(exports, "greedyColoring", ()=>greedyColoring
);
parcelHelpers.export(exports, "resetColoring", ()=>resetColoring
);
parcelHelpers.export(exports, "showChromaticNumber", ()=>showChromaticNumber
);
parcelHelpers.export(exports, "showBiparte", ()=>showBiparte
);
parcelHelpers.export(exports, "checkComponents", ()=>checkComponents
);
parcelHelpers.export(exports, "showCompleteGraph", ()=>showCompleteGraph
);
parcelHelpers.export(exports, "showTrivialGraph", ()=>showTrivialGraph
);
parcelHelpers.export(exports, "showCycles", ()=>showCycles
);
parcelHelpers.export(exports, "showTrees", ()=>showTrees
);
function sectionHeader(text) {
    var l = "\\[\\large{\\text{" + text + "}} \\]";
    return l;
}
function showGraphMinDegree() {
    var vertices = window.graph.graphVertices;
    var minDeg = Infinity;
    vertices.forEach(function(v) {
        if (v.degree < minDeg) minDeg = v.degree;
    });
    var l = "";
    if (vertices.length) l += "\\[\\delta(G)=" + minDeg + "\\]";
    else l += "\\[G \\hspace{10px} is \\hspace{10px} null\\]";
    return l;
}
function showGraphMaxDegree() {
    var vertices = window.graph.graphVertices;
    var maxDeg = 0;
    vertices.forEach(function(v) {
        if (v.degree > maxDeg) maxDeg = v.degree;
    });
    var l;
    if (vertices.length) l = "\\[\\Delta(G)=" + maxDeg + "\\]";
    else l = "\\[G \\hspace{10px} is \\hspace{10px} null\\]";
    return l;
}
function getVertexId(vertex) {
    var v = "\\[v_{" + vertex.id + "}" + "\\]";
    return v;
}
function getVertexDegree(vertex) {
    var l = "\\[\\delta_{G}(v_{" + vertex.id + "}" + ")=" + vertex.degree + "\\]";
    return l;
}
function vertexNeighborhood(vertex) {
    var edges = vertex.edges || [];
    return edges.map((it)=>it.target.id != vertex.id ? it.target.id : it.source.id
    );
}
function getVertexNeighborhood(vertex) {
    var neighborhood = vertexNeighborhood(vertex);
    // console.log("getVertexNeighborhood", { neighborhood });
    var e = "\\[\\Gamma_{G}(v_{" + vertex.id + "})=\\{";
    for(let i = 0; i < neighborhood.length; i++){
        if (i == neighborhood.length - 1) e += "v_{" + neighborhood[i] + "}";
        else e += "v_{" + neighborhood[i] + "}" + ",";
        //add line break
        if ((i + 1) % 10 == 0) e += "\\\\";
    }
    e += "\\}\\]";
    // console.log("getVertexNeighborhood 2", { neighborhood, e });
    return e;
}
function showGraphRegular() {
    var vertices = window.graph.graphVertices;
    var degSeq = vertices.map(function(v) {
        return v.degree;
    });
    //sort in decreasing order
    degSeq.sort(function(a, b) {
        return b - a;
    });
    //test if graph is regular
    var flag = false;
    if (degSeq.length > 0) flag = true;
    for(var i = 0; i < degSeq.length - 1; i++)if (degSeq[i] != degSeq[i + 1]) {
        flag = false;
        break;
    }
    var l = "";
    // var l = "\\[\\text{Degree Sequence}=(";
    // degSeq.forEach(function(d, i) {
    //     if (i !== degSeq.length - 1) l += d + ",";
    //     else l += d;
    //     if (i % 15 == 14) l += "\\\\";
    // });
    // l += ")\\]";
    if (flag) l += "\\[\\text{Grafo é \\(" + degSeq[0] + "\\)-regular de ordem }" + degSeq.length + "\\]";
    else l += "\\[\\text{Grafo não é k-regular.}\\]";
    return l;
}
function showGroups(vertices, edges) {
    var v = "\\[V=\\{";
    for(let i = 0; i < vertices.length; i++){
        if (i == 0) v += "v_{" + vertices[i].id + "}";
        else v += ",v_{" + vertices[i].id + "}";
        if ((i + 1) % 15 == 0) v += "\\\\";
    }
    v += "\\}\\]";
    var e = "\\[E=\\{";
    for(let i1 = 0; i1 < edges.length; i1++){
        if (i1 == edges.length - 1) e += "(v_{" + edges[i1].source.id + "}" + "v_{" + edges[i1].target.id + "}" + ")";
        else e += "(\\color{0}{v_{" + edges[i1].source.id + "}}" + "v_{" + edges[i1].target.id + "}" + ")" + ",";
        if ((i1 + 1) % 10 == 0) e += "\\\\";
    }
    e += "\\}\\]";
    e += "\\[\\text{|V| = }" + vertices.length + "\\]";
    e += "\\[\\text{|E| = }" + edges.length + "\\]";
    return v + e;
}
function showAdjacencyMatrix() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    var l = "";
    l += "\\[\\text{Matriz de adjacência}\\]";
    l += "\\[\\begin{pmatrix}";
    var a = [];
    for(let i = 0; i < vertices.length; i++){
        for(let j = 0; j < vertices.length; j++){
            var value;
            if (i == j) value = 0;
            else value = vertices[i].edges.filter((e)=>e.source.id == vertices[j].id || e.target.id == vertices[j].id
            ).length > 0 ? 1 : 0;
            var and = j == vertices.length - 1 ? "" : " & ";
            l += "" + value + and;
        }
        l += "\\";
        l += "\\";
    }
    l += "\\end{pmatrix}\\]";
    return l;
}
function greedyColoring(vertices) {
    const colors = vertices.map((it, index)=>index
    );
    const colorsResult = [];
    var result = [];
    vertices.forEach((v)=>{
        const usedColors = [];
        v.edges.forEach((edge, i)=>{
            var neighbour = vertices.find((it, _)=>it.id == edge.target.id || it.id == edge.source.id
            );
            usedColors.push(neighbour.color);
        });
        var color = colors.find((it, _)=>!usedColors.includes(it)
        );
        if (colorsResult.indexOf(color) === -1) colorsResult.push(color);
        v.color = color;
        result.push(v);
    });
    window.graph.graphVertices = result;
    window.graph.chromaticNumber = colorsResult.length;
    // console.log("GREEDY/final", {
    //     result,
    //     colors,
    //     graph: window.graph,
    //     colorsResult,
    // });
    window.graph.restartGraph();
}
function resetColoring(vertices) {
    window.graph.graphVertices = vertices.map((e)=>({
            ...e,
            color: null
        })
    );
    window.graph.restartGraph();
    window.graph.chromaticNumber = 0;
}
function showChromaticNumber(chromaticNumber) {
    // var l = "\\[\\text{Número crômatico é } \\chi = " + chromaticNumber + "\\]";
    var l = "\\[\\chi = " + chromaticNumber + "\\]";
    return l;
}
function showBiparte(isBipartite) {
    var vertices = window.graph.graphVertices;
    var l = "";
    if (isBipartite) {
        var setA = "", setB = "";
        var countA = 0, countB = 0;
        vertices.forEach(function(v) {
            if (v.color % 2 == 0) {
                countA++;
                setA += "v_{" + v.id + "},";
                if (countA % 12 == 0) setA += "\\\\";
            } else if (v.color % 2 == 1) {
                countB++;
                setB += "v_{" + v.id + "},";
                if (countB % 12 == 0) setB += "\\\\";
            }
        });
        //modify sets to make Latex text look nicer
        if (countA % 12 == 0) setA = setA.slice(0, -3);
        else setA = setA.slice(0, -1);
        if (countB % 12 == 0) setB = setB.slice(0, -3);
        else setB = setB.slice(0, -1);
        l += "\\[\\text{O grafo é bipartido!}\\]";
        l += "\\[\\text{Conjunto } A = \\{" + setA + "\\} \\]";
        l += "\\[\\text{Conjunto } B = \\{" + setB + "\\} \\]";
    } else if (isBipartite != false) l = "\\[\\text{O grafo não é bipartido.}\\]";
    else l = "\\[\\text{O grafo não é bipartido.}\\]";
    return l;
}
function checkComponents() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    if (vertices.length == 0) {
        componentCount = 0;
        return showComponents(componentCount);
    }
    componentCount = 1;
    //construct adjacency list of graph
    var adjList = {
    };
    vertices.forEach(function(v) {
        v.visited = false;
        adjList[v.id] = [];
    });
    edges.forEach(function(e) {
        adjList[e.source.id].push(vertices.find((v)=>v.id == e.target.id
        ));
        adjList[e.target.id].push(vertices.find((v)=>v.id == e.source.id
        ));
    });
    //perform DFS on vertices
    var q = [];
    q.push(vertices[0]);
    while(q.length > 0){
        var v1 = q.shift();
        var adj = adjList[v1.id];
        for(let i = 0; i < adj.length; i++){
            var v2 = adj[i];
            if (v2.visited) continue;
            q.push(v2);
        }
        v1.visited = true;
        v1.componentId = componentCount;
        //check for unvisited vertices
        if (q.length == 0) {
            for(let i = 0; i < vertices.length; i++)if (!vertices[i].visited) {
                q.push(vertices[i]);
                componentCount++;
                break;
            }
        }
    } //while ends here
    // vertices.style("fill", function(d) {
    //     return colors[d.componentId % 10];
    // });
    return showComponents(componentCount);
}
function showComponents(componentCount) {
    var l = "";
    if (componentCount == 0) l = "\\[\\text{Grafo não contém nenhum componente.}\\]";
    else if (componentCount == 1) l = "\\[\\text{O grafo tem somente um componente.}\\]";
    else l = "\\[\\text{O grafo tem " + componentCount + " componentes. É um grafo desconexo.}\\]";
    return l;
}
function showCompleteGraph() {
    var l = "";
    var degSeq = window.graph.graphVertices.map(function(v) {
        return v.degree;
    });
    //sort in decreasing order
    degSeq.sort(function(a, b) {
        return b - a;
    });
    var order = window.graph.graphVertices.length, size = window.graph.graphEdges.length;
    if (order > 0 && 2 * size == order * (order - 1)) l += "\\[\\text{\xc9 um grafo completo (}K_{" + degSeq.length + "} \\text{).}\\]";
    else l += "\\[\\text{Não é um grafo completo.}\\]";
    return l;
}
function showTrivialGraph() {
    var vertices = window.graph.graphVertices;
    var isTrivial = vertices.length == 1;
    if (isTrivial) return "\\[\\text{É um grafo trivial.}\\]";
    return "\\[\\text{Não é um grafo trivial.}\\]";
}
function checkCycle() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    if (edges.length == 0) return false;
    //construct adjacency list of graph
    //vis keeps track of visited node ids
    var adjList = {
    }, vis = {
    }, parent = {
    };
    vertices.forEach(function(v) {
        v.visited = false;
        adjList[v.id] = [];
        vis[v.id] = false;
    });
    edges.forEach(function(e) {
        adjList[e.source.id].push(e.target.id);
        adjList[e.target.id].push(e.source.id);
    });
    //perform DFS on vertices
    var q = [
        vertices[0].id
    ];
    //-1 means root
    parent[vertices[0].id] = -1;
    var v1, v2;
    while(q.length > 0){
        v1 = q.shift();
        vis[v1] = true;
        for(let i = 0; i < adjList[v1].length; i++){
            v2 = adjList[v1][i];
            if (vis[v2] && parent[v1] != v2) return true;
            if (!vis[v2]) {
                q.push(v2);
                parent[v2] = v1;
            }
        }
    }
    //check for other components
    if (q.length == 0) {
        for(let v in vis)if (!vis[v]) {
            q.push(v);
            parent[v] = -1;
            break;
        }
    }
    return false;
}
function showCycles() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    var l = "";
    //construct adjacency list of graph
    //vis keeps track of visited node ids
    var adjList = {
    }, vis = {
    }, parent = {
    };
    vertices.forEach(function(v) {
        v.visited = false;
        adjList[v.id] = [];
        vis[v.id] = false;
    });
    edges.forEach(function(e) {
        adjList[e.source.id].push(e.target.id);
        adjList[e.target.id].push(e.source.id);
    });
    //perform DFS on vertices
    var q = [
        vertices[0].id
    ];
    //-1 means root
    parent[vertices[0].id] = -1;
    var v1, v2;
    var cycles = 0;
    while(q.length > 0){
        v1 = q.shift();
        vis[v1] = true;
        for(let i = 0; i < adjList[v1].length; i++){
            v2 = adjList[v1][i];
            if (vis[v2] && parent[v1] != v2) cycles += 1;
            if (!vis[v2]) {
                q.push(v2);
                parent[v2] = v1;
            }
        }
        //check for other components
        if (q.length == 0) {
            for(let v in vis)if (!vis[v]) {
                q.push(v);
                parent[v] = -1;
                break;
            }
        }
    } //while ends here
    if (cycles == 0) l += "\\[\\text{O grafo não tem ciclos}\\]";
    else l += "\\[\\text{O grafo tem " + cycles + " ciclos.}\\]";
    return l;
}
function showTrees() {
    var vertices = window.graph.graphVertices;
    var edges = window.graph.graphEdges;
    var l = "";
    if (vertices.length == 0) l = "\\[\\text{Não é uma árvore.}\\]";
    else if (checkCycle()) l = "\\[\\text{Não é uma árvore. Grafo não é acíclico.}\\]";
    else if (vertices.length == edges.length + 1) l = "\\[\\text{É uma árvore.}\\]";
    else l = "\\[\\text{É uma floresta.}\\]";
    return l;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}]},["e3EAe","hzbwC"], "hzbwC", "parcelRequire0215")

</script>
<script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"4v140":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "29830712237a93bf";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    var parents = getParents(module.bundle.root, id); // If no parents, the asset is new. Prevent reloading the page.
    if (!parents.length) return true;
    return parents.some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"kMRg5":[function(require,module,exports) {
var _fileServiceJs = require("./src/file_service.js");

},{"./src/file_service.js":"gYrD3"}],"gYrD3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "importGraphMl", ()=>importGraphMl
);
parcelHelpers.export(exports, "exportGraphMl", ()=>exportGraphMl
);
var _graphmlJs = require("graphml-js");
var _xmlJs = require("xml-js");
var _xmlJsDefault = parcelHelpers.interopDefault(_xmlJs);
const inputElement = document.getElementById("inputElement");
inputElement.onchange = importGraphMl;
function importGraphMl(_) {
    const file = inputElement.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e)=>{
        const textContent = e.target.result;
        var parser = new _graphmlJs.GraphMLParser();
        parser.parse(textContent, function(err, graphml) {
            var graphVertices = mapGraphMlToVertices(graphml);
            var graphEdges = mapGraphMlToEdges(graphml, graphVertices);
            window.graph.importGraph(graphVertices, graphEdges);
        });
    };
    reader.onerror = (e)=>{
        const error = e.target.error;
        console.error(`Error occured while reading ${file.name}`, error);
    };
    reader.readAsText(file);
}
function mapGraphMlToVertices(graphml) {
    var nodes = graphml.nodes;
    var graphVertices = [];
    nodes.forEach((node, index)=>{
        var newVertice = {
            id: index,
            title: node["_id"]
        };
        graphVertices.push(newVertice);
    });
    return graphVertices;
}
function mapGraphMlToEdges(graphml, graphVertices) {
    var edges = graphml.edges;
    var graphEdges = [];
    edges.forEach((edge)=>{
        var newEdge = {
            source: graphVertices.findIndex((v)=>v.title == edge["_source"]
            ),
            target: graphVertices.findIndex((v)=>v.title == edge["_target"]
            )
        };
        graphEdges.push(newEdge);
    });
    return graphEdges;
}
function verticesToGraphMl(vertices) {
    return vertices.map((v)=>({
            "_attributes": {
                id: v["id"]
            }
        })
    );
}
function edgesToGraphMl(edges) {
    return edges.map((e)=>({
            "_attributes": {
                source: e["source"]["id"],
                target: e["target"]["id"]
            }
        })
    );
}
function exportGraphMl(vertices, edges) {
    var json = {
        "_declaration": {
            "_attributes": {
                "version": "1.0",
                "encoding": "UTF-8"
            }
        },
        "graphml": {
            "graph": {
                "node": verticesToGraphMl(vertices),
                "edge": edgesToGraphMl(edges)
            }
        }
    };
    var options = {
        compact: true,
        ignoreComment: true,
        spaces: 4
    };
    var resultJson = _xmlJsDefault.default.js2xml(json, options);
    download(resultJson, "graph.graphml", "text/plain");
}
function download(data, filename, type) {
    var file = new Blob([
        data
    ], {
        type: type
    });
    if (window.navigator.msSaveOrOpenBlob) window.navigator.msSaveOrOpenBlob(file, filename);
    else {
        var a = document.createElement("a"), url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    }
}

},{"graphml-js":"26k9B","xml-js":"a22RV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"26k9B":[function(require,module,exports) {
/// <reference path="../typings/index.d.ts" />
"use strict";
var __extends = this && this.__extends || function(d, b) {
    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var xml2js_1 = require('xml2js');
var GraphElement1 = function() {
    function GraphElement(id) {
        this.id = id;
        this.attributes = {
        };
    }
    Object.defineProperty(GraphElement.prototype, "id", {
        get: function() {
            return this._id;
        },
        set: function(id) {
            this._id = id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphElement.prototype, "attributes", {
        get: function() {
            return this._attributes;
        },
        set: function(attributes) {
            this._attributes = attributes;
        },
        enumerable: true,
        configurable: true
    });
    return GraphElement;
}();
exports.GraphElement = GraphElement1;
var Node1 = function(_super) {
    __extends(Node, _super);
    function Node(id) {
        _super.call(this, id);
    }
    return Node;
}(GraphElement1);
exports.Node = Node1;
var Edge1 = function(_super) {
    __extends(Edge, _super);
    function Edge(id, source, target) {
        _super.call(this, id);
        this.source = source;
        this.target = target;
    }
    Object.defineProperty(Edge.prototype, "source", {
        get: function() {
            return this._source;
        },
        set: function(source) {
            this._source = source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Edge.prototype, "target", {
        get: function() {
            return this._target;
        },
        set: function(target) {
            this._target = target;
        },
        enumerable: true,
        configurable: true
    });
    return Edge;
}(GraphElement1);
exports.Edge = Edge1;
var Graph1 = function() {
    function Graph() {
        this.nodes = new Array();
        this.edges = new Array();
    }
    return Graph;
}();
exports.Graph = Graph1;
var AttributeKey1 = function() {
    function AttributeKey(name, dataType) {
        this.name = name;
        this.dataType = dataType;
    }
    return AttributeKey;
}();
var GraphMLParser1 = function() {
    function GraphMLParser() {
        this.keys = {
        };
        this.graph = new Graph1();
    }
    GraphMLParser.prototype.parse = function(text, cb) {
        var _this = this;
        var parser = new xml2js_1.Parser();
        parser.parseString(text, function(err, data) {
            _this.buildKeys(data);
            _this.buildNodes(data);
            _this.buildEdges(data);
            cb(err, _this.graph);
        });
    };
    GraphMLParser.prototype.buildKeys = function(data) {
        for(var i in data.graphml.key){
            var key = data.graphml.key[i]['$'];
            var keyId = key.id;
            var name_1 = key['attr.name'];
            var dataType = key['attr.type'];
            var newKey = new AttributeKey1(name_1, dataType);
            this.keys[keyId] = newKey;
        }
    };
    GraphMLParser.prototype.buildNodes = function(data) {
        var nodes = data.graphml.graph[0].node;
        for(var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++){
            var node = nodes_1[_i];
            var id = node['$'].id;
            var newNode = new Node1(id);
            if (node.data !== undefined) this.buildAttributes(newNode.attributes, node.data);
            this.graph.nodes.push(newNode);
        }
    };
    GraphMLParser.prototype.buildEdges = function(data) {
        var edges = data.graphml.graph[0].edge;
        for(var _i = 0, edges_1 = edges; _i < edges_1.length; _i++){
            var edge = edges_1[_i];
            var id = edge['$'].id;
            var source = edge['$'].source;
            var target = edge['$'].target;
            var newEdge = new Edge1(id, source, target);
            if (edge.data !== undefined) this.buildAttributes(newEdge.attributes, edge.data);
            this.graph.edges.push(newEdge);
        }
    };
    GraphMLParser.prototype.buildAttributes = function(newAttr, attributes) {
        for(var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++){
            var attribute = attributes_1[_i];
            var attributeKey = attribute['$'].key;
            var attributeName = this.keys[attributeKey].name;
            var attributeValue = attribute['_'];
            var attributeDataType = this.keys[attributeKey].dataType;
            if (attributeDataType === 'int' || attributeDataType === 'long' || attributeDataType === 'float' || attributeDataType === 'double') newAttr[attributeName] = Number(attributeValue);
            else newAttr[attributeName] = attributeValue;
        }
    };
    return GraphMLParser;
}();
exports.GraphMLParser = GraphMLParser1;

},{"xml2js":"3dvPL"}],"3dvPL":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var builder, defaults, parser, processors, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    defaults = require('./defaults');
    builder = require('./builder');
    parser = require('./parser');
    processors = require('./processors');
    exports.defaults = defaults.defaults;
    exports.processors = processors;
    exports.ValidationError = (function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
            this.message = message;
        }
        return ValidationError;
    })(Error);
    exports.Builder = builder.Builder;
    exports.Parser = parser.Parser;
    exports.parseString = parser.parseString;
    exports.parseStringPromise = parser.parseStringPromise;
}).call(this);

},{"./defaults":"fDk2h","./builder":"hB728","./parser":"8Wy45","./processors":"ckxC8"}],"fDk2h":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    exports.defaults = {
        "0.1": {
            explicitCharkey: false,
            trim: true,
            normalize: true,
            normalizeTags: false,
            attrkey: "@",
            charkey: "#",
            explicitArray: false,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: false,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            childkey: '@@',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ''
        },
        "0.2": {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            charkey: "_",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: '$$',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: 'root',
            xmldec: {
                'version': '1.0',
                'encoding': 'UTF-8',
                'standalone': true
            },
            doctype: null,
            renderOpts: {
                'pretty': true,
                'indent': '  ',
                'newline': '\n'
            },
            headless: false,
            chunkSize: 10000,
            emptyTag: '',
            cdata: false
        }
    };
}).call(this);

},{}],"hB728":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {
    }.hasOwnProperty;
    builder = require('xmlbuilder');
    defaults = require('./defaults').defaults;
    requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
    };
    wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };
    escapeCDATA = function(entry) {
        return entry.replace(']]>', ']]]]><![CDATA[>');
    };
    exports.Builder = (function() {
        function Builder(opts) {
            var key, ref, value;
            this.options = {
            };
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
        }
        Builder.prototype.buildObject = function(rootObj) {
            var attrkey, charkey, render, rootElement, rootName;
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults['0.2'].rootName) {
                rootName = Object.keys(rootObj)[0];
                rootObj = rootObj[rootName];
            } else rootName = this.options.rootName;
            render = (function(_this) {
                return function(element, obj) {
                    var attr, child, entry, index, key, value;
                    if (typeof obj !== 'object') {
                        if (_this.options.cdata && requiresCDATA(obj)) element.raw(wrapCDATA(obj));
                        else element.txt(obj);
                    } else if (Array.isArray(obj)) for(index in obj){
                        if (!hasProp.call(obj, index)) continue;
                        child = obj[index];
                        for(key in child){
                            entry = child[key];
                            element = render(element.ele(key), entry).up();
                        }
                    }
                    else for(key in obj){
                        if (!hasProp.call(obj, key)) continue;
                        child = obj[key];
                        if (key === attrkey) {
                            if (typeof child === "object") for(attr in child){
                                value = child[attr];
                                element = element.att(attr, value);
                            }
                        } else if (key === charkey) {
                            if (_this.options.cdata && requiresCDATA(child)) element = element.raw(wrapCDATA(child));
                            else element = element.txt(child);
                        } else if (Array.isArray(child)) for(index in child){
                            if (!hasProp.call(child, index)) continue;
                            entry = child[index];
                            if (typeof entry === 'string') {
                                if (_this.options.cdata && requiresCDATA(entry)) element = element.ele(key).raw(wrapCDATA(entry)).up();
                                else element = element.ele(key, entry).up();
                            } else element = render(element.ele(key), entry).up();
                        }
                        else if (typeof child === "object") element = render(element.ele(key), child).up();
                        else if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) element = element.ele(key).raw(wrapCDATA(child)).up();
                        else {
                            if (child == null) child = '';
                            element = element.ele(key, child.toString()).up();
                        }
                    }
                    return element;
                };
            })(this);
            rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                headless: this.options.headless,
                allowSurrogateChars: this.options.allowSurrogateChars
            });
            return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
    })();
}).call(this);

},{"xmlbuilder":"hA8zs","./defaults":"fDk2h"}],"hA8zs":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
    ref = require('./Utility'), assign = ref.assign, isFunction = ref.isFunction;
    XMLDOMImplementation = require('./XMLDOMImplementation');
    XMLDocument = require('./XMLDocument');
    XMLDocumentCB = require('./XMLDocumentCB');
    XMLStringWriter = require('./XMLStringWriter');
    XMLStreamWriter = require('./XMLStreamWriter');
    NodeType = require('./NodeType');
    WriterState = require('./WriterState');
    module.exports.create = function(name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) throw new Error("Root element needs a name.");
        options = assign({
        }, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name);
        if (!options.headless) {
            doc.declaration(options);
            if (options.pubID != null || options.sysID != null) doc.dtd(options);
        }
        return root;
    };
    module.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
            ref1 = [
                options,
                onData
            ], onData = ref1[0], onEnd = ref1[1];
            options = {
            };
        }
        if (onData) return new XMLDocumentCB(options, onData, onEnd);
        else return new XMLDocument(options);
    };
    module.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
    };
    module.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
    };
    module.exports.implementation = new XMLDOMImplementation();
    module.exports.nodeType = NodeType;
    module.exports.writerState = WriterState;
}).call(this);

},{"./Utility":"3gpwT","./XMLDOMImplementation":"9wwaI","./XMLDocument":"8Zx5L","./XMLDocumentCB":"aJkVd","./XMLStringWriter":"WCwh2","./XMLStreamWriter":"8vRPE","./NodeType":"bHsfv","./WriterState":"psDCU"}],"3gpwT":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {
    }.hasOwnProperty;
    assign = function() {
        var i, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) Object.assign.apply(null, arguments);
        else for(i = 0, len = sources.length; i < len; i++){
            source = sources[i];
            if (source != null) for(key in source){
                if (!hasProp.call(source, key)) continue;
                target[key] = source[key];
            }
        }
        return target;
    };
    isFunction = function(val) {
        return !!val && Object.prototype.toString.call(val) === '[object Function]';
    };
    isObject = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === 'function' || ref === 'object');
    };
    isArray = function(val) {
        if (isFunction(Array.isArray)) return Array.isArray(val);
        else return Object.prototype.toString.call(val) === '[object Array]';
    };
    isEmpty = function(val) {
        var key;
        if (isArray(val)) return !val.length;
        else {
            for(key in val){
                if (!hasProp.call(val, key)) continue;
                return false;
            }
            return true;
        }
    };
    isPlainObject = function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === 'function' && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    };
    getValue = function(obj) {
        if (isFunction(obj.valueOf)) return obj.valueOf();
        else return obj;
    };
    module.exports.assign = assign;
    module.exports.isFunction = isFunction;
    module.exports.isObject = isObject;
    module.exports.isArray = isArray;
    module.exports.isEmpty = isEmpty;
    module.exports.isPlainObject = isPlainObject;
    module.exports.getValue = getValue;
}).call(this);

},{}],"9wwaI":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMImplementation1;
    module.exports = XMLDOMImplementation1 = (function() {
        function XMLDOMImplementation() {
        }
        XMLDOMImplementation.prototype.hasFeature = function(feature, version) {
            return true;
        };
        XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented.");
        };
        return XMLDOMImplementation;
    })();
}).call(this);

},{}],"8Zx5L":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument1, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    isPlainObject = require('./Utility').isPlainObject;
    XMLDOMImplementation = require('./XMLDOMImplementation');
    XMLDOMConfiguration = require('./XMLDOMConfiguration');
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    XMLStringifier = require('./XMLStringifier');
    XMLStringWriter = require('./XMLStringWriter');
    module.exports = XMLDocument1 = (function(superClass) {
        extend(XMLDocument, superClass);
        function XMLDocument(options) {
            XMLDocument.__super__.constructor.call(this, null);
            this.name = "#document";
            this.type = NodeType.Document;
            this.documentURI = null;
            this.domConfig = new XMLDOMConfiguration();
            options || (options = {
            });
            if (!options.writer) options.writer = new XMLStringWriter();
            this.options = options;
            this.stringify = new XMLStringifier(options);
        }
        Object.defineProperty(XMLDocument.prototype, 'implementation', {
            value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument.prototype, 'doctype', {
            get: function() {
                var child, i, len, ref;
                ref = this.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.DocType) return child;
                }
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'documentElement', {
            get: function() {
                return this.rootObject || null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {
            get: function() {
                return false;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {
            get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].encoding;
                else return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {
            get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].standalone === 'yes';
                else return false;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {
            get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].version;
                else return "1.0";
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'URL', {
            get: function() {
                return this.documentURI;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'origin', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'compatMode', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'characterSet', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, 'contentType', {
            get: function() {
                return null;
            }
        });
        XMLDocument.prototype.end = function(writer) {
            var writerOptions;
            writerOptions = {
            };
            if (!writer) writer = this.options.writer;
            else if (isPlainObject(writer)) {
                writerOptions = writer;
                writer = this.options.writer;
            }
            return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument.prototype.toString = function(options) {
            return this.options.writer.document(this, this.options.writer.filterOptions(options));
        };
        XMLDocument.prototype.createElement = function(tagName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createDocumentFragment = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createTextNode = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createComment = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createCDATASection = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createProcessingInstruction = function(target, data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createAttribute = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createEntityReference = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.importNode = function(importedNode, deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementById = function(elementId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.adoptNode = function(source) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.normalizeDocument = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createEvent = function(eventInterface) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createRange = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLDocument;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLDOMImplementation":"9wwaI","./XMLDOMConfiguration":"as1md","./XMLNode":"9Mxux","./NodeType":"bHsfv","./XMLStringifier":"i909L","./XMLStringWriter":"WCwh2"}],"as1md":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMConfiguration1, XMLDOMErrorHandler, XMLDOMStringList;
    XMLDOMErrorHandler = require('./XMLDOMErrorHandler');
    XMLDOMStringList = require('./XMLDOMStringList');
    module.exports = XMLDOMConfiguration1 = (function() {
        function XMLDOMConfiguration() {
            var clonedSelf;
            this.defaultParams = {
                "canonical-form": false,
                "cdata-sections": false,
                "comments": false,
                "datatype-normalization": false,
                "element-content-whitespace": true,
                "entities": true,
                "error-handler": new XMLDOMErrorHandler(),
                "infoset": true,
                "validate-if-schema": false,
                "namespaces": true,
                "namespace-declarations": true,
                "normalize-characters": false,
                "schema-location": '',
                "schema-type": '',
                "split-cdata-sections": true,
                "validate": false,
                "well-formed": true
            };
            this.params = clonedSelf = Object.create(this.defaultParams);
        }
        Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {
            get: function() {
                return new XMLDOMStringList(Object.keys(this.defaultParams));
            }
        });
        XMLDOMConfiguration.prototype.getParameter = function(name) {
            if (this.params.hasOwnProperty(name)) return this.params[name];
            else return null;
        };
        XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
            return true;
        };
        XMLDOMConfiguration.prototype.setParameter = function(name, value) {
            if (value != null) return this.params[name] = value;
            else return delete this.params[name];
        };
        return XMLDOMConfiguration;
    })();
}).call(this);

},{"./XMLDOMErrorHandler":"kyoOB","./XMLDOMStringList":"h1tRX"}],"kyoOB":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMErrorHandler1;
    module.exports = XMLDOMErrorHandler1 = (function() {
        function XMLDOMErrorHandler() {
        }
        XMLDOMErrorHandler.prototype.handleError = function(error) {
            throw new Error(error);
        };
        return XMLDOMErrorHandler;
    })();
}).call(this);

},{}],"h1tRX":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMStringList1;
    module.exports = XMLDOMStringList1 = (function() {
        function XMLDOMStringList(arr) {
            this.arr = arr || [];
        }
        Object.defineProperty(XMLDOMStringList.prototype, 'length', {
            get: function() {
                return this.arr.length;
            }
        });
        XMLDOMStringList.prototype.item = function(index) {
            return this.arr[index] || null;
        };
        XMLDOMStringList.prototype.contains = function(str) {
            return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList;
    })();
}).call(this);

},{}],"9Mxux":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode1, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {
    }.hasOwnProperty;
    ref1 = require('./Utility'), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
    XMLElement = null;
    XMLCData = null;
    XMLComment = null;
    XMLDeclaration = null;
    XMLDocType = null;
    XMLRaw = null;
    XMLText = null;
    XMLProcessingInstruction = null;
    XMLDummy = null;
    NodeType = null;
    XMLNodeList = null;
    XMLNamedNodeMap = null;
    DocumentPosition = null;
    module.exports = XMLNode1 = (function() {
        function XMLNode(parent1) {
            this.parent = parent1;
            if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
            }
            this.value = null;
            this.children = [];
            this.baseURI = null;
            if (!XMLElement) {
                XMLElement = require('./XMLElement');
                XMLCData = require('./XMLCData');
                XMLComment = require('./XMLComment');
                XMLDeclaration = require('./XMLDeclaration');
                XMLDocType = require('./XMLDocType');
                XMLRaw = require('./XMLRaw');
                XMLText = require('./XMLText');
                XMLProcessingInstruction = require('./XMLProcessingInstruction');
                XMLDummy = require('./XMLDummy');
                NodeType = require('./NodeType');
                XMLNodeList = require('./XMLNodeList');
                XMLNamedNodeMap = require('./XMLNamedNodeMap');
                DocumentPosition = require('./DocumentPosition');
            }
        }
        Object.defineProperty(XMLNode.prototype, 'nodeName', {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'nodeType', {
            get: function() {
                return this.type;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'nodeValue', {
            get: function() {
                return this.value;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'parentNode', {
            get: function() {
                return this.parent;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'childNodes', {
            get: function() {
                if (!this.childNodeList || !this.childNodeList.nodes) this.childNodeList = new XMLNodeList(this.children);
                return this.childNodeList;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'firstChild', {
            get: function() {
                return this.children[0] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'lastChild', {
            get: function() {
                return this.children[this.children.length - 1] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'previousSibling', {
            get: function() {
                var i;
                i = this.parent.children.indexOf(this);
                return this.parent.children[i - 1] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'nextSibling', {
            get: function() {
                var i;
                i = this.parent.children.indexOf(this);
                return this.parent.children[i + 1] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'ownerDocument', {
            get: function() {
                return this.document() || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, 'textContent', {
            get: function() {
                var child, j, len, ref2, str;
                if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
                    str = '';
                    ref2 = this.children;
                    for(j = 0, len = ref2.length; j < len; j++){
                        child = ref2[j];
                        if (child.textContent) str += child.textContent;
                    }
                    return str;
                } else return null;
            },
            set: function(value) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        XMLNode.prototype.setParent = function(parent) {
            var child, j, len, ref2, results;
            this.parent = parent;
            if (parent) {
                this.options = parent.options;
                this.stringify = parent.stringify;
            }
            ref2 = this.children;
            results = [];
            for(j = 0, len = ref2.length; j < len; j++){
                child = ref2[j];
                results.push(child.setParent(this));
            }
            return results;
        };
        XMLNode.prototype.element = function(name, attributes, text) {
            var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
            lastChild = null;
            if (attributes === null && text == null) ref2 = [
                {
                },
                null
            ], attributes = ref2[0], text = ref2[1];
            if (attributes == null) attributes = {
            };
            attributes = getValue(attributes);
            if (!isObject(attributes)) ref3 = [
                attributes,
                text
            ], text = ref3[0], attributes = ref3[1];
            if (name != null) name = getValue(name);
            if (Array.isArray(name)) for(j = 0, len = name.length; j < len; j++){
                item = name[j];
                lastChild = this.element(item);
            }
            else if (isFunction(name)) lastChild = this.element(name.apply());
            else if (isObject(name)) for(key in name){
                if (!hasProp.call(name, key)) continue;
                val = name[key];
                if (isFunction(val)) val = val.apply();
                if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) lastChild = this.dummy();
                else if (isObject(val) && isEmpty(val)) lastChild = this.element(key);
                else if (!this.options.keepNullNodes && val == null) lastChild = this.dummy();
                else if (!this.options.separateArrayItems && Array.isArray(val)) for(k = 0, len1 = val.length; k < len1; k++){
                    item = val[k];
                    childNode = {
                    };
                    childNode[key] = item;
                    lastChild = this.element(childNode);
                }
                else if (isObject(val)) {
                    if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) lastChild = this.element(val);
                    else {
                        lastChild = this.element(key);
                        lastChild.element(val);
                    }
                } else lastChild = this.element(key, val);
            }
            else if (!this.options.keepNullNodes && text === null) lastChild = this.dummy();
            else {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) lastChild = this.text(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) lastChild = this.cdata(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) lastChild = this.comment(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) lastChild = this.raw(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
                else lastChild = this.node(name, attributes, text);
            }
            if (lastChild == null) throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
            return lastChild;
        };
        XMLNode.prototype.insertBefore = function(name, attributes, text) {
            var child, i, newChild, refChild, removed;
            if (name != null ? name.type : void 0) {
                newChild = name;
                refChild = attributes;
                newChild.setParent(this);
                if (refChild) {
                    i = children.indexOf(refChild);
                    removed = children.splice(i);
                    children.push(newChild);
                    Array.prototype.push.apply(children, removed);
                } else children.push(newChild);
                return newChild;
            } else {
                if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                i = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i);
                child = this.parent.element(name, attributes, text);
                Array.prototype.push.apply(this.parent.children, removed);
                return child;
            }
        };
        XMLNode.prototype.insertAfter = function(name, attributes, text) {
            var child, i, removed;
            if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
        };
        XMLNode.prototype.remove = function() {
            var i, ref2;
            if (this.isRoot) throw new Error("Cannot remove the root element. " + this.debugInfo());
            i = this.parent.children.indexOf(this);
            [].splice.apply(this.parent.children, [
                i,
                i - i + 1
            ].concat(ref2 = []));
            return this.parent;
        };
        XMLNode.prototype.node = function(name, attributes, text) {
            var child, ref2;
            if (name != null) name = getValue(name);
            attributes || (attributes = {
            });
            attributes = getValue(attributes);
            if (!isObject(attributes)) ref2 = [
                attributes,
                text
            ], text = ref2[0], attributes = ref2[1];
            child = new XMLElement(this, name, attributes);
            if (text != null) child.text(text);
            this.children.push(child);
            return child;
        };
        XMLNode.prototype.text = function(value) {
            var child;
            if (isObject(value)) this.element(value);
            child = new XMLText(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.cdata = function(value) {
            var child;
            child = new XMLCData(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.comment = function(value) {
            var child;
            child = new XMLComment(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.commentBefore = function(value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.commentAfter = function(value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.raw = function(value) {
            var child;
            child = new XMLRaw(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.dummy = function() {
            var child;
            child = new XMLDummy(this);
            return child;
        };
        XMLNode.prototype.instruction = function(target, value) {
            var insTarget, insValue, instruction, j, len;
            if (target != null) target = getValue(target);
            if (value != null) value = getValue(value);
            if (Array.isArray(target)) for(j = 0, len = target.length; j < len; j++){
                insTarget = target[j];
                this.instruction(insTarget);
            }
            else if (isObject(target)) for(insTarget in target){
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                instruction = new XMLProcessingInstruction(this, target, value);
                this.children.push(instruction);
            }
            return this;
        };
        XMLNode.prototype.instructionBefore = function(target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.instructionAfter = function(target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.declaration = function(version, encoding, standalone) {
            var doc, xmldec;
            doc = this.document();
            xmldec = new XMLDeclaration(doc, version, encoding, standalone);
            if (doc.children.length === 0) doc.children.unshift(xmldec);
            else if (doc.children[0].type === NodeType.Declaration) doc.children[0] = xmldec;
            else doc.children.unshift(xmldec);
            return doc.root() || doc;
        };
        XMLNode.prototype.dtd = function(pubID, sysID) {
            var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
            doc = this.document();
            doctype = new XMLDocType(doc, pubID, sysID);
            ref2 = doc.children;
            for(i = j = 0, len = ref2.length; j < len; i = ++j){
                child = ref2[i];
                if (child.type === NodeType.DocType) {
                    doc.children[i] = doctype;
                    return doctype;
                }
            }
            ref3 = doc.children;
            for(i = k = 0, len1 = ref3.length; k < len1; i = ++k){
                child = ref3[i];
                if (child.isRoot) {
                    doc.children.splice(i, 0, doctype);
                    return doctype;
                }
            }
            doc.children.push(doctype);
            return doctype;
        };
        XMLNode.prototype.up = function() {
            if (this.isRoot) throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            return this.parent;
        };
        XMLNode.prototype.root = function() {
            var node;
            node = this;
            while(node){
                if (node.type === NodeType.Document) return node.rootObject;
                else if (node.isRoot) return node;
                else node = node.parent;
            }
        };
        XMLNode.prototype.document = function() {
            var node;
            node = this;
            while(node){
                if (node.type === NodeType.Document) return node;
                else node = node.parent;
            }
        };
        XMLNode.prototype.end = function(options) {
            return this.document().end(options);
        };
        XMLNode.prototype.prev = function() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i < 1) throw new Error("Already at the first node. " + this.debugInfo());
            return this.parent.children[i - 1];
        };
        XMLNode.prototype.next = function() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i === -1 || i === this.parent.children.length - 1) throw new Error("Already at the last node. " + this.debugInfo());
            return this.parent.children[i + 1];
        };
        XMLNode.prototype.importDocument = function(doc) {
            var clonedRoot;
            clonedRoot = doc.root().clone();
            clonedRoot.parent = this;
            clonedRoot.isRoot = false;
            this.children.push(clonedRoot);
            return this;
        };
        XMLNode.prototype.debugInfo = function(name) {
            var ref2, ref3;
            name = name || this.name;
            if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) return "";
            else if (name == null) return "parent: <" + this.parent.name + ">";
            else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) return "node: <" + name + ">";
            else return "node: <" + name + ">, parent: <" + this.parent.name + ">";
        };
        XMLNode.prototype.ele = function(name, attributes, text) {
            return this.element(name, attributes, text);
        };
        XMLNode.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLNode.prototype.txt = function(value) {
            return this.text(value);
        };
        XMLNode.prototype.dat = function(value) {
            return this.cdata(value);
        };
        XMLNode.prototype.com = function(value) {
            return this.comment(value);
        };
        XMLNode.prototype.ins = function(target, value) {
            return this.instruction(target, value);
        };
        XMLNode.prototype.doc = function() {
            return this.document();
        };
        XMLNode.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
        };
        XMLNode.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
        };
        XMLNode.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLNode.prototype.t = function(value) {
            return this.text(value);
        };
        XMLNode.prototype.d = function(value) {
            return this.cdata(value);
        };
        XMLNode.prototype.c = function(value) {
            return this.comment(value);
        };
        XMLNode.prototype.r = function(value) {
            return this.raw(value);
        };
        XMLNode.prototype.i = function(target, value) {
            return this.instruction(target, value);
        };
        XMLNode.prototype.u = function() {
            return this.up();
        };
        XMLNode.prototype.importXMLBuilder = function(doc) {
            return this.importDocument(doc);
        };
        XMLNode.prototype.replaceChild = function(newChild, oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.removeChild = function(oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.appendChild = function(newChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.hasChildNodes = function() {
            return this.children.length !== 0;
        };
        XMLNode.prototype.cloneNode = function(deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.normalize = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.isSupported = function(feature, version) {
            return true;
        };
        XMLNode.prototype.hasAttributes = function() {
            return this.attribs.length !== 0;
        };
        XMLNode.prototype.compareDocumentPosition = function(other) {
            var ref, res;
            ref = this;
            if (ref === other) return 0;
            else if (this.document() !== other.document()) {
                res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
                if (Math.random() < 0.5) res |= DocumentPosition.Preceding;
                else res |= DocumentPosition.Following;
                return res;
            } else if (ref.isAncestor(other)) return DocumentPosition.Contains | DocumentPosition.Preceding;
            else if (ref.isDescendant(other)) return DocumentPosition.Contains | DocumentPosition.Following;
            else if (ref.isPreceding(other)) return DocumentPosition.Preceding;
            else return DocumentPosition.Following;
        };
        XMLNode.prototype.isSameNode = function(other) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.lookupPrefix = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.lookupNamespaceURI = function(prefix) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.isEqualNode = function(node) {
            var i, j, ref2;
            if (node.nodeType !== this.nodeType) return false;
            if (node.children.length !== this.children.length) return false;
            for(i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j){
                if (!this.children[i].isEqualNode(node.children[i])) return false;
            }
            return true;
        };
        XMLNode.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.setUserData = function(key, data, handler) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.getUserData = function(key) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.contains = function(other) {
            if (!other) return false;
            return other === this || this.isDescendant(other);
        };
        XMLNode.prototype.isDescendant = function(node) {
            var child, isDescendantChild, j, len, ref2;
            ref2 = this.children;
            for(j = 0, len = ref2.length; j < len; j++){
                child = ref2[j];
                if (node === child) return true;
                isDescendantChild = child.isDescendant(node);
                if (isDescendantChild) return true;
            }
            return false;
        };
        XMLNode.prototype.isAncestor = function(node) {
            return node.isDescendant(this);
        };
        XMLNode.prototype.isPreceding = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) return false;
            else return nodePos < thisPos;
        };
        XMLNode.prototype.isFollowing = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) return false;
            else return nodePos > thisPos;
        };
        XMLNode.prototype.treePosition = function(node) {
            var found, pos;
            pos = 0;
            found = false;
            this.foreachTreeNode(this.document(), function(childNode) {
                pos++;
                if (!found && childNode === node) return found = true;
            });
            if (found) return pos;
            else return -1;
        };
        XMLNode.prototype.foreachTreeNode = function(node, func) {
            var child, j, len, ref2, res;
            node || (node = this.document());
            ref2 = node.children;
            for(j = 0, len = ref2.length; j < len; j++){
                child = ref2[j];
                if (res = func(child)) return res;
                else {
                    res = this.foreachTreeNode(child, func);
                    if (res) return res;
                }
            }
        };
        return XMLNode;
    })();
}).call(this);

},{"./Utility":"3gpwT","./XMLElement":"4FyHi","./XMLCData":"bJsP2","./XMLComment":"457jq","./XMLDeclaration":"jSij2","./XMLDocType":"cVmkM","./XMLRaw":"kQIkd","./XMLText":"bU2bi","./XMLProcessingInstruction":"caXGK","./XMLDummy":"hsJt1","./NodeType":"bHsfv","./XMLNodeList":"dWyE7","./XMLNamedNodeMap":"19z2B","./DocumentPosition":"aDJjD"}],"4FyHi":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLAttribute, XMLElement1, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    XMLAttribute = require('./XMLAttribute');
    XMLNamedNodeMap = require('./XMLNamedNodeMap');
    module.exports = XMLElement1 = (function(superClass) {
        extend(XMLElement, superClass);
        function XMLElement(parent, name, attributes) {
            var child, j, len, ref1;
            XMLElement.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing element name. " + this.debugInfo());
            this.name = this.stringify.name(name);
            this.type = NodeType.Element;
            this.attribs = {
            };
            this.schemaTypeInfo = null;
            if (attributes != null) this.attribute(attributes);
            if (parent.type === NodeType.Document) {
                this.isRoot = true;
                this.documentObject = parent;
                parent.rootObject = this;
                if (parent.children) {
                    ref1 = parent.children;
                    for(j = 0, len = ref1.length; j < len; j++){
                        child = ref1[j];
                        if (child.type === NodeType.DocType) {
                            child.name = this.name;
                            break;
                        }
                    }
                }
            }
        }
        Object.defineProperty(XMLElement.prototype, 'tagName', {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLElement.prototype, 'namespaceURI', {
            get: function() {
                return '';
            }
        });
        Object.defineProperty(XMLElement.prototype, 'prefix', {
            get: function() {
                return '';
            }
        });
        Object.defineProperty(XMLElement.prototype, 'localName', {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLElement.prototype, 'id', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLElement.prototype, 'className', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLElement.prototype, 'classList', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLElement.prototype, 'attributes', {
            get: function() {
                if (!this.attributeMap || !this.attributeMap.nodes) this.attributeMap = new XMLNamedNodeMap(this.attribs);
                return this.attributeMap;
            }
        });
        XMLElement.prototype.clone = function() {
            var att, attName, clonedSelf, ref1;
            clonedSelf = Object.create(this);
            if (clonedSelf.isRoot) clonedSelf.documentObject = null;
            clonedSelf.attribs = {
            };
            ref1 = this.attribs;
            for(attName in ref1){
                if (!hasProp.call(ref1, attName)) continue;
                att = ref1[attName];
                clonedSelf.attribs[attName] = att.clone();
            }
            clonedSelf.children = [];
            this.children.forEach(function(child) {
                var clonedChild;
                clonedChild = child.clone();
                clonedChild.parent = clonedSelf;
                return clonedSelf.children.push(clonedChild);
            });
            return clonedSelf;
        };
        XMLElement.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (name != null) name = getValue(name);
            if (isObject(name)) for(attName in name){
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                if (this.options.keepNullAttributes && value == null) this.attribs[name] = new XMLAttribute(this, name, "");
                else if (value != null) this.attribs[name] = new XMLAttribute(this, name, value);
            }
            return this;
        };
        XMLElement.prototype.removeAttribute = function(name) {
            var attName, j, len;
            if (name == null) throw new Error("Missing attribute name. " + this.debugInfo());
            name = getValue(name);
            if (Array.isArray(name)) for(j = 0, len = name.length; j < len; j++){
                attName = name[j];
                delete this.attribs[attName];
            }
            else delete this.attribs[name];
            return this;
        };
        XMLElement.prototype.toString = function(options) {
            return this.options.writer.element(this, this.options.writer.filterOptions(options));
        };
        XMLElement.prototype.att = function(name, value) {
            return this.attribute(name, value);
        };
        XMLElement.prototype.a = function(name, value) {
            return this.attribute(name, value);
        };
        XMLElement.prototype.getAttribute = function(name) {
            if (this.attribs.hasOwnProperty(name)) return this.attribs[name].value;
            else return null;
        };
        XMLElement.prototype.setAttribute = function(name, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getAttributeNode = function(name) {
            if (this.attribs.hasOwnProperty(name)) return this.attribs[name];
            else return null;
        };
        XMLElement.prototype.setAttributeNode = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.removeAttributeNode = function(oldAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagName = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.hasAttribute = function(name) {
            return this.attribs.hasOwnProperty(name);
        };
        XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setIdAttribute = function(name, isId) {
            if (this.attribs.hasOwnProperty(name)) return this.attribs[name].isId;
            else return isId;
        };
        XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.isEqualNode = function(node) {
            var i, j, ref1;
            if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.namespaceURI !== this.namespaceURI) return false;
            if (node.prefix !== this.prefix) return false;
            if (node.localName !== this.localName) return false;
            if (node.attribs.length !== this.attribs.length) return false;
            for(i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j){
                if (!this.attribs[i].isEqualNode(node.attribs[i])) return false;
            }
            return true;
        };
        return XMLElement;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLNode":"9Mxux","./NodeType":"bHsfv","./XMLAttribute":"4geFW","./XMLNamedNodeMap":"19z2B"}],"bHsfv":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    module.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
    };
}).call(this);

},{}],"4geFW":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLAttribute1, XMLNode;
    NodeType = require('./NodeType');
    XMLNode = require('./XMLNode');
    module.exports = XMLAttribute1 = (function() {
        function XMLAttribute(parent, name, value) {
            this.parent = parent;
            if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
            }
            if (name == null) throw new Error("Missing attribute name. " + this.debugInfo(name));
            this.name = this.stringify.name(name);
            this.value = this.stringify.attValue(value);
            this.type = NodeType.Attribute;
            this.isId = false;
            this.schemaTypeInfo = null;
        }
        Object.defineProperty(XMLAttribute.prototype, 'nodeType', {
            get: function() {
                return this.type;
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {
            get: function() {
                return this.parent;
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'textContent', {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || '';
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {
            get: function() {
                return '';
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'prefix', {
            get: function() {
                return '';
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'localName', {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLAttribute.prototype, 'specified', {
            get: function() {
                return true;
            }
        });
        XMLAttribute.prototype.clone = function() {
            return Object.create(this);
        };
        XMLAttribute.prototype.toString = function(options) {
            return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        };
        XMLAttribute.prototype.debugInfo = function(name) {
            name = name || this.name;
            if (name == null) return "parent: <" + this.parent.name + ">";
            else return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        };
        XMLAttribute.prototype.isEqualNode = function(node) {
            if (node.namespaceURI !== this.namespaceURI) return false;
            if (node.prefix !== this.prefix) return false;
            if (node.localName !== this.localName) return false;
            if (node.value !== this.value) return false;
            return true;
        };
        return XMLAttribute;
    })();
}).call(this);

},{"./NodeType":"bHsfv","./XMLNode":"9Mxux"}],"19z2B":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLNamedNodeMap1;
    module.exports = XMLNamedNodeMap1 = (function() {
        function XMLNamedNodeMap(nodes) {
            this.nodes = nodes;
        }
        Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {
            get: function() {
                return Object.keys(this.nodes).length || 0;
            }
        });
        XMLNamedNodeMap.prototype.clone = function() {
            return this.nodes = null;
        };
        XMLNamedNodeMap.prototype.getNamedItem = function(name) {
            return this.nodes[name];
        };
        XMLNamedNodeMap.prototype.setNamedItem = function(node) {
            var oldNode;
            oldNode = this.nodes[node.nodeName];
            this.nodes[node.nodeName] = node;
            return oldNode || null;
        };
        XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
            var oldNode;
            oldNode = this.nodes[name];
            delete this.nodes[name];
            return oldNode || null;
        };
        XMLNamedNodeMap.prototype.item = function(index) {
            return this.nodes[Object.keys(this.nodes)[index]] || null;
        };
        XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
        };
        return XMLNamedNodeMap;
    })();
}).call(this);

},{}],"bJsP2":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCData1, XMLCharacterData, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLCharacterData = require('./XMLCharacterData');
    module.exports = XMLCData1 = (function(superClass) {
        extend(XMLCData, superClass);
        function XMLCData(parent, text) {
            XMLCData.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing CDATA text. " + this.debugInfo());
            this.name = "#cdata-section";
            this.type = NodeType.CData;
            this.value = this.stringify.cdata(text);
        }
        XMLCData.prototype.clone = function() {
            return Object.create(this);
        };
        XMLCData.prototype.toString = function(options) {
            return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        };
        return XMLCData;
    })(XMLCharacterData);
}).call(this);

},{"./NodeType":"bHsfv","./XMLCharacterData":"iKivp"}],"iKivp":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLCharacterData1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    module.exports = XMLCharacterData1 = (function(superClass) {
        extend(XMLCharacterData, superClass);
        function XMLCharacterData(parent) {
            XMLCharacterData.__super__.constructor.call(this, parent);
            this.value = '';
        }
        Object.defineProperty(XMLCharacterData.prototype, 'data', {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || '';
            }
        });
        Object.defineProperty(XMLCharacterData.prototype, 'length', {
            get: function() {
                return this.value.length;
            }
        });
        Object.defineProperty(XMLCharacterData.prototype, 'textContent', {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || '';
            }
        });
        XMLCharacterData.prototype.clone = function() {
            return Object.create(this);
        };
        XMLCharacterData.prototype.substringData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.appendData = function(arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.insertData = function(offset, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.deleteData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.replaceData = function(offset, count, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.isEqualNode = function(node) {
            if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.data !== this.data) return false;
            return true;
        };
        return XMLCharacterData;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux"}],"457jq":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCharacterData, XMLComment1, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLCharacterData = require('./XMLCharacterData');
    module.exports = XMLComment1 = (function(superClass) {
        extend(XMLComment, superClass);
        function XMLComment(parent, text) {
            XMLComment.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing comment text. " + this.debugInfo());
            this.name = "#comment";
            this.type = NodeType.Comment;
            this.value = this.stringify.comment(text);
        }
        XMLComment.prototype.clone = function() {
            return Object.create(this);
        };
        XMLComment.prototype.toString = function(options) {
            return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        };
        return XMLComment;
    })(XMLCharacterData);
}).call(this);

},{"./NodeType":"bHsfv","./XMLCharacterData":"iKivp"}],"jSij2":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDeclaration1, XMLNode, isObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    isObject = require('./Utility').isObject;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDeclaration1 = (function(superClass) {
        extend(XMLDeclaration, superClass);
        function XMLDeclaration(parent, version, encoding, standalone) {
            var ref;
            XMLDeclaration.__super__.constructor.call(this, parent);
            if (isObject(version)) ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
            if (!version) version = '1.0';
            this.type = NodeType.Declaration;
            this.version = this.stringify.xmlVersion(version);
            if (encoding != null) this.encoding = this.stringify.xmlEncoding(encoding);
            if (standalone != null) this.standalone = this.stringify.xmlStandalone(standalone);
        }
        XMLDeclaration.prototype.toString = function(options) {
            return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        };
        return XMLDeclaration;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"cVmkM":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType1, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    isObject = require('./Utility').isObject;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    XMLDTDAttList = require('./XMLDTDAttList');
    XMLDTDEntity = require('./XMLDTDEntity');
    XMLDTDElement = require('./XMLDTDElement');
    XMLDTDNotation = require('./XMLDTDNotation');
    XMLNamedNodeMap = require('./XMLNamedNodeMap');
    module.exports = XMLDocType1 = (function(superClass) {
        extend(XMLDocType, superClass);
        function XMLDocType(parent, pubID, sysID) {
            var child, i, len, ref, ref1, ref2;
            XMLDocType.__super__.constructor.call(this, parent);
            this.type = NodeType.DocType;
            if (parent.children) {
                ref = parent.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.Element) {
                        this.name = child.name;
                        break;
                    }
                }
            }
            this.documentObject = parent;
            if (isObject(pubID)) ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
            if (sysID == null) ref2 = [
                pubID,
                sysID
            ], sysID = ref2[0], pubID = ref2[1];
            if (pubID != null) this.pubID = this.stringify.dtdPubID(pubID);
            if (sysID != null) this.sysID = this.stringify.dtdSysID(sysID);
        }
        Object.defineProperty(XMLDocType.prototype, 'entities', {
            get: function() {
                var child, i, len, nodes, ref;
                nodes = {
                };
                ref = this.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.EntityDeclaration && !child.pe) nodes[child.name] = child;
                }
                return new XMLNamedNodeMap(nodes);
            }
        });
        Object.defineProperty(XMLDocType.prototype, 'notations', {
            get: function() {
                var child, i, len, nodes, ref;
                nodes = {
                };
                ref = this.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.NotationDeclaration) nodes[child.name] = child;
                }
                return new XMLNamedNodeMap(nodes);
            }
        });
        Object.defineProperty(XMLDocType.prototype, 'publicId', {
            get: function() {
                return this.pubID;
            }
        });
        Object.defineProperty(XMLDocType.prototype, 'systemId', {
            get: function() {
                return this.sysID;
            }
        });
        Object.defineProperty(XMLDocType.prototype, 'internalSubset', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        XMLDocType.prototype.element = function(name, value) {
            var child;
            child = new XMLDTDElement(this, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var child;
            child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.entity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, false, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.pEntity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, true, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.notation = function(name, value) {
            var child;
            child = new XMLDTDNotation(this, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.toString = function(options) {
            return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        };
        XMLDocType.prototype.ele = function(name, value) {
            return this.element(name, value);
        };
        XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType.prototype.ent = function(name, value) {
            return this.entity(name, value);
        };
        XMLDocType.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
        };
        XMLDocType.prototype.not = function(name, value) {
            return this.notation(name, value);
        };
        XMLDocType.prototype.up = function() {
            return this.root() || this.documentObject;
        };
        XMLDocType.prototype.isEqualNode = function(node) {
            if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.name !== this.name) return false;
            if (node.publicId !== this.publicId) return false;
            if (node.systemId !== this.systemId) return false;
            return true;
        };
        return XMLDocType;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLNode":"9Mxux","./NodeType":"bHsfv","./XMLDTDAttList":"388gh","./XMLDTDEntity":"3zIKf","./XMLDTDElement":"dW7eI","./XMLDTDNotation":"gZJiZ","./XMLNamedNodeMap":"19z2B"}],"388gh":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDAttList1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDTDAttList1 = (function(superClass) {
        extend(XMLDTDAttList, superClass);
        function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            XMLDTDAttList.__super__.constructor.call(this, parent);
            if (elementName == null) throw new Error("Missing DTD element name. " + this.debugInfo());
            if (attributeName == null) throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
            if (!attributeType) throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
            if (!defaultValueType) throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
            if (defaultValueType.indexOf('#') !== 0) defaultValueType = '#' + defaultValueType;
            if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            this.elementName = this.stringify.name(elementName);
            this.type = NodeType.AttributeDeclaration;
            this.attributeName = this.stringify.name(attributeName);
            this.attributeType = this.stringify.dtdAttType(attributeType);
            if (defaultValue) this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
            this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList.prototype.toString = function(options) {
            return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDAttList;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"3zIKf":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDEntity1, XMLNode, isObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    isObject = require('./Utility').isObject;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDTDEntity1 = (function(superClass) {
        extend(XMLDTDEntity, superClass);
        function XMLDTDEntity(parent, pe, name, value) {
            XMLDTDEntity.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing DTD entity name. " + this.debugInfo(name));
            if (value == null) throw new Error("Missing DTD entity value. " + this.debugInfo(name));
            this.pe = !!pe;
            this.name = this.stringify.name(name);
            this.type = NodeType.EntityDeclaration;
            if (!isObject(value)) {
                this.value = this.stringify.dtdEntityValue(value);
                this.internal = true;
            } else {
                if (!value.pubID && !value.sysID) throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
                if (value.pubID && !value.sysID) throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
                this.internal = false;
                if (value.pubID != null) this.pubID = this.stringify.dtdPubID(value.pubID);
                if (value.sysID != null) this.sysID = this.stringify.dtdSysID(value.sysID);
                if (value.nData != null) this.nData = this.stringify.dtdNData(value.nData);
                if (this.pe && this.nData) throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            }
        }
        Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {
            get: function() {
                return this.pubID;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {
            get: function() {
                return this.sysID;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {
            get: function() {
                return this.nData || null;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {
            get: function() {
                return null;
            }
        });
        XMLDTDEntity.prototype.toString = function(options) {
            return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDEntity;
    })(XMLNode);
}).call(this);

},{"./Utility":"3gpwT","./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"dW7eI":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDElement1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDTDElement1 = (function(superClass) {
        extend(XMLDTDElement, superClass);
        function XMLDTDElement(parent, name, value) {
            XMLDTDElement.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing DTD element name. " + this.debugInfo());
            if (!value) value = '(#PCDATA)';
            if (Array.isArray(value)) value = '(' + value.join(',') + ')';
            this.name = this.stringify.name(name);
            this.type = NodeType.ElementDeclaration;
            this.value = this.stringify.dtdElementValue(value);
        }
        XMLDTDElement.prototype.toString = function(options) {
            return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDElement;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"gZJiZ":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDNotation1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDTDNotation1 = (function(superClass) {
        extend(XMLDTDNotation, superClass);
        function XMLDTDNotation(parent, name, value) {
            XMLDTDNotation.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing DTD notation name. " + this.debugInfo(name));
            if (!value.pubID && !value.sysID) throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
            this.name = this.stringify.name(name);
            this.type = NodeType.NotationDeclaration;
            if (value.pubID != null) this.pubID = this.stringify.dtdPubID(value.pubID);
            if (value.sysID != null) this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {
            get: function() {
                return this.pubID;
            }
        });
        Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {
            get: function() {
                return this.sysID;
            }
        });
        XMLDTDNotation.prototype.toString = function(options) {
            return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDNotation;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"kQIkd":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLNode, XMLRaw1, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLNode = require('./XMLNode');
    module.exports = XMLRaw1 = (function(superClass) {
        extend(XMLRaw, superClass);
        function XMLRaw(parent, text) {
            XMLRaw.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing raw text. " + this.debugInfo());
            this.type = NodeType.Raw;
            this.value = this.stringify.raw(text);
        }
        XMLRaw.prototype.clone = function() {
            return Object.create(this);
        };
        XMLRaw.prototype.toString = function(options) {
            return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        };
        return XMLRaw;
    })(XMLNode);
}).call(this);

},{"./NodeType":"bHsfv","./XMLNode":"9Mxux"}],"bU2bi":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCharacterData, XMLText1, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLCharacterData = require('./XMLCharacterData');
    module.exports = XMLText1 = (function(superClass) {
        extend(XMLText, superClass);
        function XMLText(parent, text) {
            XMLText.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing element text. " + this.debugInfo());
            this.name = "#text";
            this.type = NodeType.Text;
            this.value = this.stringify.text(text);
        }
        Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLText.prototype, 'wholeText', {
            get: function() {
                var next, prev, str;
                str = '';
                prev = this.previousSibling;
                while(prev){
                    str = prev.data + str;
                    prev = prev.previousSibling;
                }
                str += this.data;
                next = this.nextSibling;
                while(next){
                    str = str + next.data;
                    next = next.nextSibling;
                }
                return str;
            }
        });
        XMLText.prototype.clone = function() {
            return Object.create(this);
        };
        XMLText.prototype.toString = function(options) {
            return this.options.writer.text(this, this.options.writer.filterOptions(options));
        };
        XMLText.prototype.splitText = function(offset) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLText.prototype.replaceWholeText = function(content) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLText;
    })(XMLCharacterData);
}).call(this);

},{"./NodeType":"bHsfv","./XMLCharacterData":"iKivp"}],"caXGK":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCharacterData, XMLProcessingInstruction1, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLCharacterData = require('./XMLCharacterData');
    module.exports = XMLProcessingInstruction1 = (function(superClass) {
        extend(XMLProcessingInstruction, superClass);
        function XMLProcessingInstruction(parent, target, value) {
            XMLProcessingInstruction.__super__.constructor.call(this, parent);
            if (target == null) throw new Error("Missing instruction target. " + this.debugInfo());
            this.type = NodeType.ProcessingInstruction;
            this.target = this.stringify.insTarget(target);
            this.name = this.target;
            if (value) this.value = this.stringify.insValue(value);
        }
        XMLProcessingInstruction.prototype.clone = function() {
            return Object.create(this);
        };
        XMLProcessingInstruction.prototype.toString = function(options) {
            return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        };
        XMLProcessingInstruction.prototype.isEqualNode = function(node) {
            if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.target !== this.target) return false;
            return true;
        };
        return XMLProcessingInstruction;
    })(XMLCharacterData);
}).call(this);

},{"./NodeType":"bHsfv","./XMLCharacterData":"iKivp"}],"hsJt1":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDummy1, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLNode = require('./XMLNode');
    NodeType = require('./NodeType');
    module.exports = XMLDummy1 = (function(superClass) {
        extend(XMLDummy, superClass);
        function XMLDummy(parent) {
            XMLDummy.__super__.constructor.call(this, parent);
            this.type = NodeType.Dummy;
        }
        XMLDummy.prototype.clone = function() {
            return Object.create(this);
        };
        XMLDummy.prototype.toString = function(options) {
            return '';
        };
        return XMLDummy;
    })(XMLNode);
}).call(this);

},{"./XMLNode":"9Mxux","./NodeType":"bHsfv"}],"dWyE7":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLNodeList1;
    module.exports = XMLNodeList1 = (function() {
        function XMLNodeList(nodes) {
            this.nodes = nodes;
        }
        Object.defineProperty(XMLNodeList.prototype, 'length', {
            get: function() {
                return this.nodes.length || 0;
            }
        });
        XMLNodeList.prototype.clone = function() {
            return this.nodes = null;
        };
        XMLNodeList.prototype.item = function(index) {
            return this.nodes[index] || null;
        };
        return XMLNodeList;
    })();
}).call(this);

},{}],"aDJjD":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    module.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
    };
}).call(this);

},{}],"i909L":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLStringifier1, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, hasProp = {
    }.hasOwnProperty;
    module.exports = XMLStringifier1 = (function() {
        function XMLStringifier(options) {
            this.assertLegalName = bind(this.assertLegalName, this);
            this.assertLegalChar = bind(this.assertLegalChar, this);
            var key, ref, value;
            options || (options = {
            });
            this.options = options;
            if (!this.options.version) this.options.version = '1.0';
            ref = options.stringify || {
            };
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this[key] = value;
            }
        }
        XMLStringifier.prototype.name = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalName('' + val || '');
        };
        XMLStringifier.prototype.text = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar(this.textEscape('' + val || ''));
        };
        XMLStringifier.prototype.cdata = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            val = val.replace(']]>', ']]]]><![CDATA[>');
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.comment = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            if (val.match(/--/)) throw new Error("Comment text cannot contain double-hypen: " + val);
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.raw = function(val) {
            if (this.options.noValidation) return val;
            return '' + val || '';
        };
        XMLStringifier.prototype.attValue = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar(this.attEscape(val = '' + val || ''));
        };
        XMLStringifier.prototype.insTarget = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.insValue = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            if (val.match(/\?>/)) throw new Error("Invalid processing instruction value: " + val);
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.xmlVersion = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            if (!val.match(/1\.[0-9]+/)) throw new Error("Invalid version number: " + val);
            return val;
        };
        XMLStringifier.prototype.xmlEncoding = function(val) {
            if (this.options.noValidation) return val;
            val = '' + val || '';
            if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) throw new Error("Invalid encoding: " + val);
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.xmlStandalone = function(val) {
            if (this.options.noValidation) return val;
            if (val) return "yes";
            else return "no";
        };
        XMLStringifier.prototype.dtdPubID = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdSysID = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdElementValue = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdAttType = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdAttDefault = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdEntityValue = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.dtdNData = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar('' + val || '');
        };
        XMLStringifier.prototype.convertAttKey = '@';
        XMLStringifier.prototype.convertPIKey = '?';
        XMLStringifier.prototype.convertTextKey = '#text';
        XMLStringifier.prototype.convertCDataKey = '#cdata';
        XMLStringifier.prototype.convertCommentKey = '#comment';
        XMLStringifier.prototype.convertRawKey = '#raw';
        XMLStringifier.prototype.assertLegalChar = function(str) {
            var regex, res;
            if (this.options.noValidation) return str;
            regex = '';
            if (this.options.version === '1.0') {
                regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
            } else if (this.options.version === '1.1') {
                regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
            return str;
        };
        XMLStringifier.prototype.assertLegalName = function(str) {
            var regex;
            if (this.options.noValidation) return str;
            this.assertLegalChar(str);
            regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
            if (!str.match(regex)) throw new Error("Invalid character in name");
            return str;
        };
        XMLStringifier.prototype.textEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) return str;
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
        };
        XMLStringifier.prototype.attEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) return str;
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
        };
        return XMLStringifier;
    })();
}).call(this);

},{}],"WCwh2":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLStringWriter1, XMLWriterBase, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    XMLWriterBase = require('./XMLWriterBase');
    module.exports = XMLStringWriter1 = (function(superClass) {
        extend(XMLStringWriter, superClass);
        function XMLStringWriter(options) {
            XMLStringWriter.__super__.constructor.call(this, options);
        }
        XMLStringWriter.prototype.document = function(doc, options) {
            var child, i, len, r, ref;
            options = this.filterOptions(options);
            r = '';
            ref = doc.children;
            for(i = 0, len = ref.length; i < len; i++){
                child = ref[i];
                r += this.writeChildNode(child, options, 0);
            }
            if (options.pretty && r.slice(-options.newline.length) === options.newline) r = r.slice(0, -options.newline.length);
            return r;
        };
        return XMLStringWriter;
    })(XMLWriterBase);
}).call(this);

},{"./XMLWriterBase":"epzCv"}],"epzCv":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase1, assign, hasProp = {
    }.hasOwnProperty;
    assign = require('./Utility').assign;
    NodeType = require('./NodeType');
    XMLDeclaration = require('./XMLDeclaration');
    XMLDocType = require('./XMLDocType');
    XMLCData = require('./XMLCData');
    XMLComment = require('./XMLComment');
    XMLElement = require('./XMLElement');
    XMLRaw = require('./XMLRaw');
    XMLText = require('./XMLText');
    XMLProcessingInstruction = require('./XMLProcessingInstruction');
    XMLDummy = require('./XMLDummy');
    XMLDTDAttList = require('./XMLDTDAttList');
    XMLDTDElement = require('./XMLDTDElement');
    XMLDTDEntity = require('./XMLDTDEntity');
    XMLDTDNotation = require('./XMLDTDNotation');
    WriterState = require('./WriterState');
    module.exports = XMLWriterBase1 = (function() {
        function XMLWriterBase(options) {
            var key, ref, value;
            options || (options = {
            });
            this.options = options;
            ref = options.writer || {
            };
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this["_" + key] = this[key];
                this[key] = value;
            }
        }
        XMLWriterBase.prototype.filterOptions = function(options) {
            var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
            options || (options = {
            });
            options = assign({
            }, this.options, options);
            filteredOptions = {
                writer: this
            };
            filteredOptions.pretty = options.pretty || false;
            filteredOptions.allowEmpty = options.allowEmpty || false;
            filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
            filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\n';
            filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
            filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
            filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';
            if (filteredOptions.spaceBeforeSlash === true) filteredOptions.spaceBeforeSlash = ' ';
            filteredOptions.suppressPrettyCount = 0;
            filteredOptions.user = {
            };
            filteredOptions.state = WriterState.None;
            return filteredOptions;
        };
        XMLWriterBase.prototype.indent = function(node, options, level) {
            var indentLevel;
            if (!options.pretty || options.suppressPrettyCount) return '';
            else if (options.pretty) {
                indentLevel = (level || 0) + options.offset + 1;
                if (indentLevel > 0) return new Array(indentLevel).join(options.indent);
            }
            return '';
        };
        XMLWriterBase.prototype.endline = function(node, options, level) {
            if (!options.pretty || options.suppressPrettyCount) return '';
            else return options.newline;
        };
        XMLWriterBase.prototype.attribute = function(att, options, level) {
            var r;
            this.openAttribute(att, options, level);
            r = ' ' + att.name + '="' + att.value + '"';
            this.closeAttribute(att, options, level);
            return r;
        };
        XMLWriterBase.prototype.cdata = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<![CDATA[';
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += ']]>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.comment = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<\!-- ';
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += ' -->' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.declaration = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<?xml';
            options.state = WriterState.InsideTag;
            r += ' version="' + node.version + '"';
            if (node.encoding != null) r += ' encoding="' + node.encoding + '"';
            if (node.standalone != null) r += ' standalone="' + node.standalone + '"';
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '?>';
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.docType = function(node, options, level) {
            var child, i, len, r, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            r += '<!DOCTYPE ' + node.root().name;
            if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
            if (node.children.length > 0) {
                r += ' [';
                r += this.endline(node, options, level);
                options.state = WriterState.InsideTag;
                ref = node.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    r += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r += ']';
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>';
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
            level || (level = 0);
            prettySuppressed = false;
            r = '';
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r += this.indent(node, options, level) + '<' + node.name;
            ref = node.attribs;
            for(name in ref){
                if (!hasProp.call(ref, name)) continue;
                att = ref[name];
                r += this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e) {
                return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
            })) {
                if (options.allowEmpty) {
                    r += '>';
                    options.state = WriterState.CloseTag;
                    r += '</' + node.name + '>' + this.endline(node, options, level);
                } else {
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
                }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                r += '>';
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                prettySuppressed = true;
                r += this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                prettySuppressed = false;
                options.state = WriterState.CloseTag;
                r += '</' + node.name + '>' + this.endline(node, options, level);
            } else {
                if (options.dontPrettyTextNodes) {
                    ref1 = node.children;
                    for(i = 0, len = ref1.length; i < len; i++){
                        child = ref1[i];
                        if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                            options.suppressPrettyCount++;
                            prettySuppressed = true;
                            break;
                        }
                    }
                }
                r += '>' + this.endline(node, options, level);
                options.state = WriterState.InsideTag;
                ref2 = node.children;
                for(j = 0, len1 = ref2.length; j < len1; j++){
                    child = ref2[j];
                    r += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r += this.indent(node, options, level) + '</' + node.name + '>';
                if (prettySuppressed) options.suppressPrettyCount--;
                r += this.endline(node, options, level);
                options.state = WriterState.None;
            }
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
            switch(node.type){
                case NodeType.CData:
                    return this.cdata(node, options, level);
                case NodeType.Comment:
                    return this.comment(node, options, level);
                case NodeType.Element:
                    return this.element(node, options, level);
                case NodeType.Raw:
                    return this.raw(node, options, level);
                case NodeType.Text:
                    return this.text(node, options, level);
                case NodeType.ProcessingInstruction:
                    return this.processingInstruction(node, options, level);
                case NodeType.Dummy:
                    return '';
                case NodeType.Declaration:
                    return this.declaration(node, options, level);
                case NodeType.DocType:
                    return this.docType(node, options, level);
                case NodeType.AttributeDeclaration:
                    return this.dtdAttList(node, options, level);
                case NodeType.ElementDeclaration:
                    return this.dtdElement(node, options, level);
                case NodeType.EntityDeclaration:
                    return this.dtdEntity(node, options, level);
                case NodeType.NotationDeclaration:
                    return this.dtdNotation(node, options, level);
                default:
                    throw new Error("Unknown XML node type: " + node.constructor.name);
            }
        };
        XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<?';
            options.state = WriterState.InsideTag;
            r += node.target;
            if (node.value) r += ' ' + node.value;
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '?>';
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.raw = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.text = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<!ATTLIST';
            options.state = WriterState.InsideTag;
            r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
            if (node.defaultValueType !== '#DEFAULT') r += ' ' + node.defaultValueType;
            if (node.defaultValue) r += ' "' + node.defaultValue + '"';
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdElement = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<!ELEMENT';
            options.state = WriterState.InsideTag;
            r += ' ' + node.name + ' ' + node.value;
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<!ENTITY';
            options.state = WriterState.InsideTag;
            if (node.pe) r += ' %';
            r += ' ' + node.name;
            if (node.value) r += ' "' + node.value + '"';
            else {
                if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
                if (node.nData) r += ' NDATA ' + node.nData;
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + '<!NOTATION';
            options.state = WriterState.InsideTag;
            r += ' ' + node.name;
            if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            else if (node.pubID) r += ' PUBLIC "' + node.pubID + '"';
            else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.openNode = function(node, options, level) {
        };
        XMLWriterBase.prototype.closeNode = function(node, options, level) {
        };
        XMLWriterBase.prototype.openAttribute = function(att, options, level) {
        };
        XMLWriterBase.prototype.closeAttribute = function(att, options, level) {
        };
        return XMLWriterBase;
    })();
}).call(this);

},{"./Utility":"3gpwT","./NodeType":"bHsfv","./XMLDeclaration":"jSij2","./XMLDocType":"cVmkM","./XMLCData":"bJsP2","./XMLComment":"457jq","./XMLElement":"4FyHi","./XMLRaw":"kQIkd","./XMLText":"bU2bi","./XMLProcessingInstruction":"caXGK","./XMLDummy":"hsJt1","./XMLDTDAttList":"388gh","./XMLDTDElement":"dW7eI","./XMLDTDEntity":"3zIKf","./XMLDTDNotation":"gZJiZ","./WriterState":"psDCU"}],"psDCU":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    module.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
    };
}).call(this);

},{}],"aJkVd":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB1, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {
    }.hasOwnProperty;
    ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
    NodeType = require('./NodeType');
    XMLDocument = require('./XMLDocument');
    XMLElement = require('./XMLElement');
    XMLCData = require('./XMLCData');
    XMLComment = require('./XMLComment');
    XMLRaw = require('./XMLRaw');
    XMLText = require('./XMLText');
    XMLProcessingInstruction = require('./XMLProcessingInstruction');
    XMLDeclaration = require('./XMLDeclaration');
    XMLDocType = require('./XMLDocType');
    XMLDTDAttList = require('./XMLDTDAttList');
    XMLDTDEntity = require('./XMLDTDEntity');
    XMLDTDElement = require('./XMLDTDElement');
    XMLDTDNotation = require('./XMLDTDNotation');
    XMLAttribute = require('./XMLAttribute');
    XMLStringifier = require('./XMLStringifier');
    XMLStringWriter = require('./XMLStringWriter');
    WriterState = require('./WriterState');
    module.exports = XMLDocumentCB1 = (function() {
        function XMLDocumentCB(options, onData, onEnd) {
            var writerOptions;
            this.name = "?xml";
            this.type = NodeType.Document;
            options || (options = {
            });
            writerOptions = {
            };
            if (!options.writer) options.writer = new XMLStringWriter();
            else if (isPlainObject(options.writer)) {
                writerOptions = options.writer;
                options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.writer = options.writer;
            this.writerOptions = this.writer.filterOptions(writerOptions);
            this.stringify = new XMLStringifier(options);
            this.onDataCallback = onData || function() {
            };
            this.onEndCallback = onEnd || function() {
            };
            this.currentNode = null;
            this.currentLevel = -1;
            this.openTags = {
            };
            this.documentStarted = false;
            this.documentCompleted = false;
            this.root = null;
        }
        XMLDocumentCB.prototype.createChildNode = function(node) {
            var att, attName, attributes, child, i, len, ref1, ref2;
            switch(node.type){
                case NodeType.CData:
                    this.cdata(node.value);
                    break;
                case NodeType.Comment:
                    this.comment(node.value);
                    break;
                case NodeType.Element:
                    attributes = {
                    };
                    ref1 = node.attribs;
                    for(attName in ref1){
                        if (!hasProp.call(ref1, attName)) continue;
                        att = ref1[attName];
                        attributes[attName] = att.value;
                    }
                    this.node(node.name, attributes);
                    break;
                case NodeType.Dummy:
                    this.dummy();
                    break;
                case NodeType.Raw:
                    this.raw(node.value);
                    break;
                case NodeType.Text:
                    this.text(node.value);
                    break;
                case NodeType.ProcessingInstruction:
                    this.instruction(node.target, node.value);
                    break;
                default:
                    throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
            }
            ref2 = node.children;
            for(i = 0, len = ref2.length; i < len; i++){
                child = ref2[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) this.up();
            }
            return this;
        };
        XMLDocumentCB.prototype.dummy = function() {
            return this;
        };
        XMLDocumentCB.prototype.node = function(name, attributes, text) {
            var ref1;
            if (name == null) throw new Error("Missing node name.");
            if (this.root && this.currentLevel === -1) throw new Error("Document can only have one root node. " + this.debugInfo(name));
            this.openCurrent();
            name = getValue(name);
            if (attributes == null) attributes = {
            };
            attributes = getValue(attributes);
            if (!isObject(attributes)) ref1 = [
                attributes,
                text
            ], text = ref1[0], attributes = ref1[1];
            this.currentNode = new XMLElement(this, name, attributes);
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            if (text != null) this.text(text);
            return this;
        };
        XMLDocumentCB.prototype.element = function(name, attributes, text) {
            var child, i, len, oldValidationFlag, ref1, root;
            if (this.currentNode && this.currentNode.type === NodeType.DocType) this.dtdElement.apply(this, arguments);
            else if (Array.isArray(name) || isObject(name) || isFunction(name)) {
                oldValidationFlag = this.options.noValidation;
                this.options.noValidation = true;
                root = new XMLDocument(this.options).element('TEMP_ROOT');
                root.element(name);
                this.options.noValidation = oldValidationFlag;
                ref1 = root.children;
                for(i = 0, len = ref1.length; i < len; i++){
                    child = ref1[i];
                    this.createChildNode(child);
                    if (child.type === NodeType.Element) this.up();
                }
            } else this.node(name, attributes, text);
            return this;
        };
        XMLDocumentCB.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (!this.currentNode || this.currentNode.children) throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
            if (name != null) name = getValue(name);
            if (isObject(name)) for(attName in name){
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                if (this.options.keepNullAttributes && value == null) this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
                else if (value != null) this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
            }
            return this;
        };
        XMLDocumentCB.prototype.text = function(value) {
            var node;
            this.openCurrent();
            node = new XMLText(this, value);
            this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.cdata = function(value) {
            var node;
            this.openCurrent();
            node = new XMLCData(this, value);
            this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.comment = function(value) {
            var node;
            this.openCurrent();
            node = new XMLComment(this, value);
            this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.raw = function(value) {
            var node;
            this.openCurrent();
            node = new XMLRaw(this, value);
            this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.instruction = function(target, value) {
            var i, insTarget, insValue, len, node;
            this.openCurrent();
            if (target != null) target = getValue(target);
            if (value != null) value = getValue(value);
            if (Array.isArray(target)) for(i = 0, len = target.length; i < len; i++){
                insTarget = target[i];
                this.instruction(insTarget);
            }
            else if (isObject(target)) for(insTarget in target){
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                node = new XMLProcessingInstruction(this, target, value);
                this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            }
            return this;
        };
        XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
            var node;
            this.openCurrent();
            if (this.documentStarted) throw new Error("declaration() must be the first node.");
            node = new XMLDeclaration(this, version, encoding, standalone);
            this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
            this.openCurrent();
            if (root == null) throw new Error("Missing root node name.");
            if (this.root) throw new Error("dtd() must come before the root node.");
            this.currentNode = new XMLDocType(this, pubID, sysID);
            this.currentNode.rootNodeName = root;
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            return this;
        };
        XMLDocumentCB.prototype.dtdElement = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDElement(this, name, value);
            this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var node;
            this.openCurrent();
            node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.entity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, false, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.pEntity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, true, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.notation = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDNotation(this, name, value);
            this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.up = function() {
            if (this.currentLevel < 0) throw new Error("The document node has no parent.");
            if (this.currentNode) {
                if (this.currentNode.children) this.closeNode(this.currentNode);
                else this.openNode(this.currentNode);
                this.currentNode = null;
            } else this.closeNode(this.openTags[this.currentLevel]);
            delete this.openTags[this.currentLevel];
            this.currentLevel--;
            return this;
        };
        XMLDocumentCB.prototype.end = function() {
            while(this.currentLevel >= 0)this.up();
            return this.onEnd();
        };
        XMLDocumentCB.prototype.openCurrent = function() {
            if (this.currentNode) {
                this.currentNode.children = true;
                return this.openNode(this.currentNode);
            }
        };
        XMLDocumentCB.prototype.openNode = function(node) {
            var att, chunk, name, ref1;
            if (!node.isOpen) {
                if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) this.root = node;
                chunk = '';
                if (node.type === NodeType.Element) {
                    this.writerOptions.state = WriterState.OpenTag;
                    chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
                    ref1 = node.attribs;
                    for(name in ref1){
                        if (!hasProp.call(ref1, name)) continue;
                        att = ref1[name];
                        chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                    }
                    chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
                    this.writerOptions.state = WriterState.InsideTag;
                } else {
                    this.writerOptions.state = WriterState.OpenTag;
                    chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;
                    if (node.pubID && node.sysID) chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                    else if (node.sysID) chunk += ' SYSTEM "' + node.sysID + '"';
                    if (node.children) {
                        chunk += ' [';
                        this.writerOptions.state = WriterState.InsideTag;
                    } else {
                        this.writerOptions.state = WriterState.CloseTag;
                        chunk += '>';
                    }
                    chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
                }
                this.onData(chunk, this.currentLevel);
                return node.isOpen = true;
            }
        };
        XMLDocumentCB.prototype.closeNode = function(node) {
            var chunk;
            if (!node.isClosed) {
                chunk = '';
                this.writerOptions.state = WriterState.CloseTag;
                if (node.type === NodeType.Element) chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
                else chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
                this.writerOptions.state = WriterState.None;
                this.onData(chunk, this.currentLevel);
                return node.isClosed = true;
            }
        };
        XMLDocumentCB.prototype.onData = function(chunk, level) {
            this.documentStarted = true;
            return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB.prototype.onEnd = function() {
            this.documentCompleted = true;
            return this.onEndCallback();
        };
        XMLDocumentCB.prototype.debugInfo = function(name) {
            if (name == null) return "";
            else return "node: <" + name + ">";
        };
        XMLDocumentCB.prototype.ele = function() {
            return this.element.apply(this, arguments);
        };
        XMLDocumentCB.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLDocumentCB.prototype.txt = function(value) {
            return this.text(value);
        };
        XMLDocumentCB.prototype.dat = function(value) {
            return this.cdata(value);
        };
        XMLDocumentCB.prototype.com = function(value) {
            return this.comment(value);
        };
        XMLDocumentCB.prototype.ins = function(target, value) {
            return this.instruction(target, value);
        };
        XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
            return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
        };
        XMLDocumentCB.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLDocumentCB.prototype.t = function(value) {
            return this.text(value);
        };
        XMLDocumentCB.prototype.d = function(value) {
            return this.cdata(value);
        };
        XMLDocumentCB.prototype.c = function(value) {
            return this.comment(value);
        };
        XMLDocumentCB.prototype.r = function(value) {
            return this.raw(value);
        };
        XMLDocumentCB.prototype.i = function(target, value) {
            return this.instruction(target, value);
        };
        XMLDocumentCB.prototype.att = function() {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
            else return this.attribute.apply(this, arguments);
        };
        XMLDocumentCB.prototype.a = function() {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
            else return this.attribute.apply(this, arguments);
        };
        XMLDocumentCB.prototype.ent = function(name, value) {
            return this.entity(name, value);
        };
        XMLDocumentCB.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
        };
        XMLDocumentCB.prototype.not = function(name, value) {
            return this.notation(name, value);
        };
        return XMLDocumentCB;
    })();
}).call(this);

},{"./Utility":"3gpwT","./NodeType":"bHsfv","./XMLDocument":"8Zx5L","./XMLElement":"4FyHi","./XMLCData":"bJsP2","./XMLComment":"457jq","./XMLRaw":"kQIkd","./XMLText":"bU2bi","./XMLProcessingInstruction":"caXGK","./XMLDeclaration":"jSij2","./XMLDocType":"cVmkM","./XMLDTDAttList":"388gh","./XMLDTDEntity":"3zIKf","./XMLDTDElement":"dW7eI","./XMLDTDNotation":"gZJiZ","./XMLAttribute":"4geFW","./XMLStringifier":"i909L","./XMLStringWriter":"WCwh2","./WriterState":"psDCU"}],"8vRPE":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLStreamWriter1, XMLWriterBase, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    NodeType = require('./NodeType');
    XMLWriterBase = require('./XMLWriterBase');
    WriterState = require('./WriterState');
    module.exports = XMLStreamWriter1 = (function(superClass) {
        extend(XMLStreamWriter, superClass);
        function XMLStreamWriter(stream, options) {
            this.stream = stream;
            XMLStreamWriter.__super__.constructor.call(this, options);
        }
        XMLStreamWriter.prototype.endline = function(node, options, level) {
            if (node.isLastRootNode && options.state === WriterState.CloseTag) return '';
            else return XMLStreamWriter.__super__.endline.call(this, node, options, level);
        };
        XMLStreamWriter.prototype.document = function(doc, options) {
            var child, i, j, k, len, len1, ref, ref1, results;
            ref = doc.children;
            for(i = j = 0, len = ref.length; j < len; i = ++j){
                child = ref[i];
                child.isLastRootNode = i === doc.children.length - 1;
            }
            options = this.filterOptions(options);
            ref1 = doc.children;
            results = [];
            for(k = 0, len1 = ref1.length; k < len1; k++){
                child = ref1[k];
                results.push(this.writeChildNode(child, options, 0));
            }
            return results;
        };
        XMLStreamWriter.prototype.attribute = function(att, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
        };
        XMLStreamWriter.prototype.cdata = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.comment = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.declaration = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.docType = function(node, options, level) {
            var child, j, len, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level));
            this.stream.write('<!DOCTYPE ' + node.root().name);
            if (node.pubID && node.sysID) this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            else if (node.sysID) this.stream.write(' SYSTEM "' + node.sysID + '"');
            if (node.children.length > 0) {
                this.stream.write(' [');
                this.stream.write(this.endline(node, options, level));
                options.state = WriterState.InsideTag;
                ref = node.children;
                for(j = 0, len = ref.length; j < len; j++){
                    child = ref[j];
                    this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write(']');
            }
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + '>');
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
        };
        XMLStreamWriter.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level) + '<' + node.name);
            ref = node.attribs;
            for(name in ref){
                if (!hasProp.call(ref, name)) continue;
                att = ref[name];
                this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e) {
                return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
            })) {
                if (options.allowEmpty) {
                    this.stream.write('>');
                    options.state = WriterState.CloseTag;
                    this.stream.write('</' + node.name + '>');
                } else {
                    options.state = WriterState.CloseTag;
                    this.stream.write(options.spaceBeforeSlash + '/>');
                }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                this.stream.write('>');
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                prettySuppressed = true;
                this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                prettySuppressed = false;
                options.state = WriterState.CloseTag;
                this.stream.write('</' + node.name + '>');
            } else {
                this.stream.write('>' + this.endline(node, options, level));
                options.state = WriterState.InsideTag;
                ref1 = node.children;
                for(j = 0, len = ref1.length; j < len; j++){
                    child = ref1[j];
                    this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
            }
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
        };
        XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.raw = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.text = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
        };
        return XMLStreamWriter;
    })(XMLWriterBase);
}).call(this);

},{"./NodeType":"bHsfv","./XMLWriterBase":"epzCv","./WriterState":"psDCU"}],"8Wy45":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var bom, defaults, events, isEmpty, processItem, processors1, sax, setImmediate, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {
    }.hasOwnProperty;
    sax = require('sax');
    events = require('events');
    bom = require('./bom');
    processors1 = require('./processors');
    setImmediate = require('timers').setImmediate;
    defaults = require('./defaults').defaults;
    isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
    };
    processItem = function(processors, item, key) {
        var i, len, process;
        for(i = 0, len = processors.length; i < len; i++){
            process = processors[i];
            item = process(item, key);
        }
        return item;
    };
    exports.Parser = (function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
            this.parseStringPromise = bind(this.parseStringPromise, this);
            this.parseString = bind(this.parseString, this);
            this.reset = bind(this.reset, this);
            this.assignOrPush = bind(this.assignOrPush, this);
            this.processAsync = bind(this.processAsync, this);
            var key, ref, value;
            if (!(this instanceof exports.Parser)) return new exports.Parser(opts);
            this.options = {
            };
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
            if (this.options.xmlns) this.options.xmlnskey = this.options.attrkey + "ns";
            if (this.options.normalizeTags) {
                if (!this.options.tagNameProcessors) this.options.tagNameProcessors = [];
                this.options.tagNameProcessors.unshift(processors1.normalize);
            }
            this.reset();
        }
        Parser.prototype.processAsync = function() {
            var chunk, err;
            try {
                if (this.remaining.length <= this.options.chunkSize) {
                    chunk = this.remaining;
                    this.remaining = '';
                    this.saxParser = this.saxParser.write(chunk);
                    return this.saxParser.close();
                } else {
                    chunk = this.remaining.substr(0, this.options.chunkSize);
                    this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                    this.saxParser = this.saxParser.write(chunk);
                    return setImmediate(this.processAsync);
                }
            } catch (error1) {
                err = error1;
                if (!this.saxParser.errThrown) {
                    this.saxParser.errThrown = true;
                    return this.emit(err);
                }
            }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
            if (!(key in obj)) {
                if (!this.options.explicitArray) return obj[key] = newValue;
                else return obj[key] = [
                    newValue
                ];
            } else {
                if (!(obj[key] instanceof Array)) obj[key] = [
                    obj[key]
                ];
                return obj[key].push(newValue);
            }
        };
        Parser.prototype.reset = function() {
            var attrkey, charkey, ontext, stack;
            this.removeAllListeners();
            this.saxParser = sax.parser(this.options.strict, {
                trim: false,
                normalize: false,
                xmlns: this.options.xmlns
            });
            this.saxParser.errThrown = false;
            this.saxParser.onerror = (function(_this) {
                return function(error) {
                    _this.saxParser.resume();
                    if (!_this.saxParser.errThrown) {
                        _this.saxParser.errThrown = true;
                        return _this.emit("error", error);
                    }
                };
            })(this);
            this.saxParser.onend = (function(_this) {
                return function() {
                    if (!_this.saxParser.ended) {
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            })(this);
            this.saxParser.ended = false;
            this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
            this.resultObject = null;
            stack = [];
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            this.saxParser.onopentag = (function(_this) {
                return function(node) {
                    var key, newValue, obj, processedKey, ref;
                    obj = {
                    };
                    obj[charkey] = "";
                    if (!_this.options.ignoreAttrs) {
                        ref = node.attributes;
                        for(key in ref){
                            if (!hasProp.call(ref, key)) continue;
                            if (!(attrkey in obj) && !_this.options.mergeAttrs) obj[attrkey] = {
                            };
                            newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                            processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                            if (_this.options.mergeAttrs) _this.assignOrPush(obj, processedKey, newValue);
                            else obj[attrkey][processedKey] = newValue;
                        }
                    }
                    obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                    if (_this.options.xmlns) obj[_this.options.xmlnskey] = {
                        uri: node.uri,
                        local: node.local
                    };
                    return stack.push(obj);
                };
            })(this);
            this.saxParser.onclosetag = (function(_this) {
                return function() {
                    var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                    obj = stack.pop();
                    nodeName = obj["#name"];
                    if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) delete obj["#name"];
                    if (obj.cdata === true) {
                        cdata = obj.cdata;
                        delete obj.cdata;
                    }
                    s = stack[stack.length - 1];
                    if (obj[charkey].match(/^\s*$/) && !cdata) {
                        emptyStr = obj[charkey];
                        delete obj[charkey];
                    } else {
                        if (_this.options.trim) obj[charkey] = obj[charkey].trim();
                        if (_this.options.normalize) obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                        obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                        if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
                    }
                    if (isEmpty(obj)) obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
                    if (_this.options.validator != null) {
                        xpath = "/" + (function() {
                            var i, len, results;
                            results = [];
                            for(i = 0, len = stack.length; i < len; i++){
                                node = stack[i];
                                results.push(node["#name"]);
                            }
                            return results;
                        })().concat(nodeName).join("/");
                        (function() {
                            var err;
                            try {
                                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                            } catch (error1) {
                                err = error1;
                                return _this.emit("error", err);
                            }
                        })();
                    }
                    if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                        if (!_this.options.preserveChildrenOrder) {
                            node = {
                            };
                            if (_this.options.attrkey in obj) {
                                node[_this.options.attrkey] = obj[_this.options.attrkey];
                                delete obj[_this.options.attrkey];
                            }
                            if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                node[_this.options.charkey] = obj[_this.options.charkey];
                                delete obj[_this.options.charkey];
                            }
                            if (Object.getOwnPropertyNames(obj).length > 0) node[_this.options.childkey] = obj;
                            obj = node;
                        } else if (s) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            objClone = {
                            };
                            for(key in obj){
                                if (!hasProp.call(obj, key)) continue;
                                objClone[key] = obj[key];
                            }
                            s[_this.options.childkey].push(objClone);
                            delete obj["#name"];
                            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
                        }
                    }
                    if (stack.length > 0) return _this.assignOrPush(s, nodeName, obj);
                    else {
                        if (_this.options.explicitRoot) {
                            old = obj;
                            obj = {
                            };
                            obj[nodeName] = old;
                        }
                        _this.resultObject = obj;
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            })(this);
            ontext = (function(_this) {
                return function(text) {
                    var charChild, s;
                    s = stack[stack.length - 1];
                    if (s) {
                        s[charkey] += text;
                        if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            charChild = {
                                '#name': '__text__'
                            };
                            charChild[charkey] = text;
                            if (_this.options.normalize) charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                            s[_this.options.childkey].push(charChild);
                        }
                        return s;
                    }
                };
            })(this);
            this.saxParser.ontext = ontext;
            return this.saxParser.oncdata = (function(_this) {
                return function(text) {
                    var s;
                    s = ontext(text);
                    if (s) return s.cdata = true;
                };
            })(this);
        };
        Parser.prototype.parseString = function(str, cb) {
            var err1;
            if (cb != null && typeof cb === "function") {
                this.on("end", function(result) {
                    this.reset();
                    return cb(null, result);
                });
                this.on("error", function(err) {
                    this.reset();
                    return cb(err);
                });
            }
            try {
                str = str.toString();
                if (str.trim() === '') {
                    this.emit("end", null);
                    return true;
                }
                str = bom.stripBOM(str);
                if (this.options.async) {
                    this.remaining = str;
                    setImmediate(this.processAsync);
                    return this.saxParser;
                }
                return this.saxParser.write(str).close();
            } catch (error1) {
                err1 = error1;
                if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                    this.emit('error', err1);
                    return this.saxParser.errThrown = true;
                } else if (this.saxParser.ended) throw err1;
            }
        };
        Parser.prototype.parseStringPromise = function(str) {
            return new Promise(function(_this) {
                return function(resolve, reject) {
                    return _this.parseString(str, function(err, value) {
                        if (err) return reject(err);
                        else return resolve(value);
                    });
                };
            }(this));
        };
        return Parser;
    })(events);
    exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
            if (typeof b === 'function') cb = b;
            if (typeof a === 'object') options = a;
        } else {
            if (typeof a === 'function') cb = a;
            options = {
            };
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
    };
    exports.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === 'object') options = a;
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
    };
}).call(this);

},{"sax":"gBT5g","events":"bHM3D","./bom":"hdwAm","./processors":"ckxC8","timers":"59lXe","./defaults":"fDk2h"}],"gBT5g":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function(sax) {
    sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 65536;
    var buffers = [
        'comment',
        'sgmlDecl',
        'textNode',
        'tagName',
        'doctype',
        'procInstName',
        'procInstBody',
        'entity',
        'attribName',
        'attribValue',
        'cdata',
        'script'
    ];
    sax.EVENTS = [
        'text',
        'processinginstruction',
        'sgmldeclaration',
        'doctype',
        'comment',
        'opentagstart',
        'attribute',
        'opentag',
        'closetag',
        'opencdata',
        'cdata',
        'closecdata',
        'error',
        'end',
        'ready',
        'script',
        'opennamespace',
        'closenamespace'
    ];
    function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = '';
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {
        };
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        // namespaces form a prototype chain.
        // it always points at the current tag,
        // which protos to its parent tag.
        if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
        // mostly just for error reporting
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
        emit(parser, 'onready');
    }
    if (!Object.create) Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
    };
    if (!Object.keys) Object.keys = function(o) {
        var a = [];
        for(var i in o)if (o.hasOwnProperty(i)) a.push(i);
        return a;
    };
    function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for(var i = 0, l = buffers.length; i < l; i++){
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) // Text/cdata nodes can get big, and since they're buffered,
            // we can get here under normal conditions.
            // Avoid issues by emitting the text node now,
            // so at least it won't get any bigger.
            switch(buffers[i]){
                case 'textNode':
                    closeText(parser);
                    break;
                case 'cdata':
                    emitNode(parser, 'oncdata', parser.cdata);
                    parser.cdata = '';
                    break;
                case 'script':
                    emitNode(parser, 'onscript', parser.script);
                    parser.script = '';
                    break;
                default:
                    error(parser, 'Max buffer length exceeded: ' + buffers[i]);
            }
            maxActual = Math.max(maxActual, len);
        }
        // schedule the next check for the earliest possible buffer overrun.
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
        for(var i = 0, l = buffers.length; i < l; i++)parser[buffers[i]] = '';
    }
    function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== '') {
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
        }
        if (parser.script !== '') {
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
    }
    SAXParser.prototype = {
        end: function() {
            end(this);
        },
        write: write,
        resume: function() {
            this.error = null;
            return this;
        },
        close: function() {
            return this.write(null);
        },
        flush: function() {
            flushBuffers(this);
        }
    };
    var Stream;
    try {
        Stream = require('stream').Stream;
    } catch (ex) {
        Stream = function() {
        };
    }
    var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== 'error' && ev !== 'end';
    });
    function createStream(strict, opt) {
        return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
            me.emit('end');
        };
        this._parser.onerror = function(er) {
            me.emit('error', er);
            // if didn't throw, then means error was handled.
            // go ahead and clear error, so we can write again.
            me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
            Object.defineProperty(me, 'on' + ev, {
                get: function() {
                    return me._parser['on' + ev];
                },
                set: function(h) {
                    if (!h) {
                        me.removeAllListeners(ev);
                        me._parser['on' + ev] = h;
                        return h;
                    }
                    me.on(ev, h);
                },
                enumerable: true,
                configurable: false
            });
        });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
            value: SAXStream
        }
    });
    SAXStream.prototype.write = function(data) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = require('string_decoder').StringDecoder;
                this._decoder = new SD('utf8');
            }
            data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit('data', data);
        return true;
    };
    SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) this.write(chunk);
        this._parser.end();
        return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) me._parser['on' + ev] = function() {
            var args = arguments.length === 1 ? [
                arguments[0]
            ] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
        };
        return Stream.prototype.on.call(me, ev, handler);
    };
    // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.
    var CDATA = '[CDATA[';
    var DOCTYPE = 'DOCTYPE';
    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
    var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
    };
    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
        return c === ' ' || c === '\n' || c === '\r' || c === '\t';
    }
    function isQuote(c) {
        return c === '"' || c === '\'';
    }
    function isAttribEnd(c) {
        return c === '>' || isWhitespace(c);
    }
    function isMatch(regex, c) {
        return regex.test(c);
    }
    function notMatch(regex, c) {
        return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++ // <script> ... <
    };
    sax.XML_ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': "'"
    };
    sax.ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': "'",
        'AElig': 198,
        'Aacute': 193,
        'Acirc': 194,
        'Agrave': 192,
        'Aring': 197,
        'Atilde': 195,
        'Auml': 196,
        'Ccedil': 199,
        'ETH': 208,
        'Eacute': 201,
        'Ecirc': 202,
        'Egrave': 200,
        'Euml': 203,
        'Iacute': 205,
        'Icirc': 206,
        'Igrave': 204,
        'Iuml': 207,
        'Ntilde': 209,
        'Oacute': 211,
        'Ocirc': 212,
        'Ograve': 210,
        'Oslash': 216,
        'Otilde': 213,
        'Ouml': 214,
        'THORN': 222,
        'Uacute': 218,
        'Ucirc': 219,
        'Ugrave': 217,
        'Uuml': 220,
        'Yacute': 221,
        'aacute': 225,
        'acirc': 226,
        'aelig': 230,
        'agrave': 224,
        'aring': 229,
        'atilde': 227,
        'auml': 228,
        'ccedil': 231,
        'eacute': 233,
        'ecirc': 234,
        'egrave': 232,
        'eth': 240,
        'euml': 235,
        'iacute': 237,
        'icirc': 238,
        'igrave': 236,
        'iuml': 239,
        'ntilde': 241,
        'oacute': 243,
        'ocirc': 244,
        'ograve': 242,
        'oslash': 248,
        'otilde': 245,
        'ouml': 246,
        'szlig': 223,
        'thorn': 254,
        'uacute': 250,
        'ucirc': 251,
        'ugrave': 249,
        'uuml': 252,
        'yacute': 253,
        'yuml': 255,
        'copy': 169,
        'reg': 174,
        'nbsp': 160,
        'iexcl': 161,
        'cent': 162,
        'pound': 163,
        'curren': 164,
        'yen': 165,
        'brvbar': 166,
        'sect': 167,
        'uml': 168,
        'ordf': 170,
        'laquo': 171,
        'not': 172,
        'shy': 173,
        'macr': 175,
        'deg': 176,
        'plusmn': 177,
        'sup1': 185,
        'sup2': 178,
        'sup3': 179,
        'acute': 180,
        'micro': 181,
        'para': 182,
        'middot': 183,
        'cedil': 184,
        'ordm': 186,
        'raquo': 187,
        'frac14': 188,
        'frac12': 189,
        'frac34': 190,
        'iquest': 191,
        'times': 215,
        'divide': 247,
        'OElig': 338,
        'oelig': 339,
        'Scaron': 352,
        'scaron': 353,
        'Yuml': 376,
        'fnof': 402,
        'circ': 710,
        'tilde': 732,
        'Alpha': 913,
        'Beta': 914,
        'Gamma': 915,
        'Delta': 916,
        'Epsilon': 917,
        'Zeta': 918,
        'Eta': 919,
        'Theta': 920,
        'Iota': 921,
        'Kappa': 922,
        'Lambda': 923,
        'Mu': 924,
        'Nu': 925,
        'Xi': 926,
        'Omicron': 927,
        'Pi': 928,
        'Rho': 929,
        'Sigma': 931,
        'Tau': 932,
        'Upsilon': 933,
        'Phi': 934,
        'Chi': 935,
        'Psi': 936,
        'Omega': 937,
        'alpha': 945,
        'beta': 946,
        'gamma': 947,
        'delta': 948,
        'epsilon': 949,
        'zeta': 950,
        'eta': 951,
        'theta': 952,
        'iota': 953,
        'kappa': 954,
        'lambda': 955,
        'mu': 956,
        'nu': 957,
        'xi': 958,
        'omicron': 959,
        'pi': 960,
        'rho': 961,
        'sigmaf': 962,
        'sigma': 963,
        'tau': 964,
        'upsilon': 965,
        'phi': 966,
        'chi': 967,
        'psi': 968,
        'omega': 969,
        'thetasym': 977,
        'upsih': 978,
        'piv': 982,
        'ensp': 8194,
        'emsp': 8195,
        'thinsp': 8201,
        'zwnj': 8204,
        'zwj': 8205,
        'lrm': 8206,
        'rlm': 8207,
        'ndash': 8211,
        'mdash': 8212,
        'lsquo': 8216,
        'rsquo': 8217,
        'sbquo': 8218,
        'ldquo': 8220,
        'rdquo': 8221,
        'bdquo': 8222,
        'dagger': 8224,
        'Dagger': 8225,
        'bull': 8226,
        'hellip': 8230,
        'permil': 8240,
        'prime': 8242,
        'Prime': 8243,
        'lsaquo': 8249,
        'rsaquo': 8250,
        'oline': 8254,
        'frasl': 8260,
        'euro': 8364,
        'image': 8465,
        'weierp': 8472,
        'real': 8476,
        'trade': 8482,
        'alefsym': 8501,
        'larr': 8592,
        'uarr': 8593,
        'rarr': 8594,
        'darr': 8595,
        'harr': 8596,
        'crarr': 8629,
        'lArr': 8656,
        'uArr': 8657,
        'rArr': 8658,
        'dArr': 8659,
        'hArr': 8660,
        'forall': 8704,
        'part': 8706,
        'exist': 8707,
        'empty': 8709,
        'nabla': 8711,
        'isin': 8712,
        'notin': 8713,
        'ni': 8715,
        'prod': 8719,
        'sum': 8721,
        'minus': 8722,
        'lowast': 8727,
        'radic': 8730,
        'prop': 8733,
        'infin': 8734,
        'ang': 8736,
        'and': 8743,
        'or': 8744,
        'cap': 8745,
        'cup': 8746,
        'int': 8747,
        'there4': 8756,
        'sim': 8764,
        'cong': 8773,
        'asymp': 8776,
        'ne': 8800,
        'equiv': 8801,
        'le': 8804,
        'ge': 8805,
        'sub': 8834,
        'sup': 8835,
        'nsub': 8836,
        'sube': 8838,
        'supe': 8839,
        'oplus': 8853,
        'otimes': 8855,
        'perp': 8869,
        'sdot': 8901,
        'lceil': 8968,
        'rceil': 8969,
        'lfloor': 8970,
        'rfloor': 8971,
        'lang': 9001,
        'rang': 9002,
        'loz': 9674,
        'spades': 9824,
        'clubs': 9827,
        'hearts': 9829,
        'diams': 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === 'number' ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
    });
    for(var s1 in sax.STATE)sax.STATE[sax.STATE[s1]] = s1;
    // shorthand
    S = sax.STATE;
    function emit(parser, event, data) {
        parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
    }
    function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, 'ontext', parser.textNode);
        parser.textNode = '';
    }
    function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, ' ');
        return text;
    }
    function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
        er = new Error(er);
        parser.error = er;
        emit(parser, 'onerror', er);
        return parser;
    }
    function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) error(parser, 'Unexpected end');
        closeText(parser);
        parser.c = '';
        parser.closed = true;
        emit(parser, 'onend');
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
    }
    function strictFail(parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser)) throw new Error('bad call to strictFail');
        if (parser.strict) error(parser, message);
    }
    function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
            name: parser.tagName,
            attributes: {
            }
        };
        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
        if (parser.opt.xmlns) tag.ns = parent.ns;
        parser.attribList.length = 0;
        emitNode(parser, 'onopentagstart', tag);
    }
    function qname(name, attribute) {
        var i = name.indexOf(':');
        var qualName = i < 0 ? [
            '',
            name
        ] : name.split(':');
        var prefix = qualName[0];
        var local = qualName[1];
        // <x "xmlns"="http://foo">
        if (attribute && name === 'xmlns') {
            prefix = 'xmlns';
            local = '';
        }
        return {
            prefix: prefix,
            local: local
        };
    }
    function attrib(parser) {
        if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = '';
            return;
        }
        if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === 'xmlns') {
                // namespace binding attribute. push the binding into scope
                if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
                    tag.ns[local] = parser.attribValue;
                }
            }
            // defer onattribute events until all attributes have been seen
            // so any new bindings can take effect. preserve attribute order
            // so deferred events can be emitted in document order
            parser.attribList.push([
                parser.attribName,
                parser.attribValue
            ]);
        } else {
            // in non-xmlns mode, we can emit the event right away
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, 'onattribute', {
                name: parser.attribName,
                value: parser.attribValue
            });
        }
        parser.attribName = parser.attribValue = '';
    }
    function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
            // emit namespace binding events
            var tag = parser.tag;
            // add namespace info to tag
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || '';
            if (tag.prefix && !tag.uri) {
                strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
                tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p) {
                emitNode(parser, 'onopennamespace', {
                    prefix: p,
                    uri: tag.ns[p]
                });
            });
            // handle deferred onattribute events
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for(var i = 0, l = parser.attribList.length; i < l; i++){
                var nv = parser.attribList[i];
                var name = nv[0];
                var value = nv[1];
                var qualName = qname(name, true);
                var prefix = qualName.prefix;
                var local = qualName.local;
                var uri = prefix === '' ? '' : tag.ns[prefix] || '';
                var a = {
                    name: name,
                    value: value,
                    prefix: prefix,
                    local: local,
                    uri: uri
                };
                // if there's any attributes with an undefined namespace,
                // then fail on them now.
                if (prefix && prefix !== 'xmlns' && !uri) {
                    strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
                    a.uri = prefix;
                }
                parser.tag.attributes[name] = a;
                emitNode(parser, 'onattribute', a);
            }
            parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        // process the tag
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, 'onopentag', parser.tag);
        if (!selfClosing) {
            // special case for <script> in non-strict mode.
            if (!parser.noscript && parser.tagName.toLowerCase() === 'script') parser.state = S.SCRIPT;
            else parser.state = S.TEXT;
            parser.tag = null;
            parser.tagName = '';
        }
        parser.attribName = parser.attribValue = '';
        parser.attribList.length = 0;
    }
    function closeTag(parser) {
        if (!parser.tagName) {
            strictFail(parser, 'Weird empty close tag.');
            parser.textNode += '</>';
            parser.state = S.TEXT;
            return;
        }
        if (parser.script) {
            if (parser.tagName !== 'script') {
                parser.script += '</' + parser.tagName + '>';
                parser.tagName = '';
                parser.state = S.SCRIPT;
                return;
            }
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
        // first make sure that the closing tag actually exists.
        // <a><b></c></b></a> will close everything, otherwise.
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) tagName = tagName[parser.looseCase]();
        var closeTo = tagName;
        while(t--){
            var close = parser.tags[t];
            if (close.name !== closeTo) // fail the first time in strict mode
            strictFail(parser, 'Unexpected close tag');
            else break;
        }
        // didn't find it.  we already failed for strict, so just abort.
        if (t < 0) {
            strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
            parser.textNode += '</' + parser.tagName + '>';
            parser.state = S.TEXT;
            return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while((s--) > t){
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, 'onclosetag', parser.tagName);
            var x = {
            };
            for(var i in tag.ns)x[i] = tag.ns[i];
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) // remove namespace bindings introduced by tag
            Object.keys(tag.ns).forEach(function(p) {
                var n = tag.ns[p];
                emitNode(parser, 'onclosenamespace', {
                    prefix: p,
                    uri: n
                });
            });
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = '';
        parser.attribList.length = 0;
        parser.state = S.TEXT;
    }
    function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = '';
        if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
        if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
        entity = entityLC;
        if (entity.charAt(0) === '#') {
            if (entity.charAt(1) === 'x') {
                entity = entity.slice(2);
                num = parseInt(entity, 16);
                numStr = num.toString(16);
            } else {
                entity = entity.slice(1);
                num = parseInt(entity, 10);
                numStr = num.toString(10);
            }
        }
        entity = entity.replace(/^0+/, '');
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, 'Invalid character entity');
            return '&' + parser.entity + ';';
        }
        return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
        if (c === '<') {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
            // have to process this as a text node.
            // weird, but happens.
            strictFail(parser, 'Non-whitespace before first tag.');
            parser.textNode = c;
            parser.state = S.TEXT;
        }
    }
    function charAt(chunk, i) {
        var result = '';
        if (i < chunk.length) result = chunk.charAt(i);
        return result;
    }
    function write(chunk) {
        var parser = this;
        if (this.error) throw this.error;
        if (parser.closed) return error(parser, 'Cannot write after close. Assign an onready handler.');
        if (chunk === null) return end(parser);
        if (typeof chunk === 'object') chunk = chunk.toString();
        var i = 0;
        var c = '';
        while(true){
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) break;
            if (parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                    parser.line++;
                    parser.column = 0;
                } else parser.column++;
            }
            switch(parser.state){
                case S.BEGIN:
                    parser.state = S.BEGIN_WHITESPACE;
                    if (c === '\uFEFF') continue;
                    beginWhiteSpace(parser, c);
                    continue;
                case S.BEGIN_WHITESPACE:
                    beginWhiteSpace(parser, c);
                    continue;
                case S.TEXT:
                    if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i - 1;
                        while(c && c !== '<' && c !== '&'){
                            c = charAt(chunk, i++);
                            if (c && parser.trackPosition) {
                                parser.position++;
                                if (c === '\n') {
                                    parser.line++;
                                    parser.column = 0;
                                } else parser.column++;
                            }
                        }
                        parser.textNode += chunk.substring(starti, i - 1);
                    }
                    if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    } else {
                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, 'Text data outside of root node.');
                        if (c === '&') parser.state = S.TEXT_ENTITY;
                        else parser.textNode += c;
                    }
                    continue;
                case S.SCRIPT:
                    // only non-strict
                    if (c === '<') parser.state = S.SCRIPT_ENDING;
                    else parser.script += c;
                    continue;
                case S.SCRIPT_ENDING:
                    if (c === '/') parser.state = S.CLOSE_TAG;
                    else {
                        parser.script += '<' + c;
                        parser.state = S.SCRIPT;
                    }
                    continue;
                case S.OPEN_WAKA:
                    // either a /, ?, !, or text is coming next.
                    if (c === '!') {
                        parser.state = S.SGML_DECL;
                        parser.sgmlDecl = '';
                    } else if (isWhitespace(c)) ;
                    else if (isMatch(nameStart, c)) {
                        parser.state = S.OPEN_TAG;
                        parser.tagName = c;
                    } else if (c === '/') {
                        parser.state = S.CLOSE_TAG;
                        parser.tagName = '';
                    } else if (c === '?') {
                        parser.state = S.PROC_INST;
                        parser.procInstName = parser.procInstBody = '';
                    } else {
                        strictFail(parser, 'Unencoded <');
                        // if there was some whitespace, then add that in.
                        if (parser.startTagPosition + 1 < parser.position) {
                            var pad = parser.position - parser.startTagPosition;
                            c = new Array(pad).join(' ') + c;
                        }
                        parser.textNode += '<' + c;
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.SGML_DECL:
                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                        emitNode(parser, 'onopencdata');
                        parser.state = S.CDATA;
                        parser.sgmlDecl = '';
                        parser.cdata = '';
                    } else if (parser.sgmlDecl + c === '--') {
                        parser.state = S.COMMENT;
                        parser.comment = '';
                        parser.sgmlDecl = '';
                    } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                        parser.state = S.DOCTYPE;
                        if (parser.doctype || parser.sawRoot) strictFail(parser, 'Inappropriately located doctype declaration');
                        parser.doctype = '';
                        parser.sgmlDecl = '';
                    } else if (c === '>') {
                        emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                        parser.sgmlDecl = '';
                        parser.state = S.TEXT;
                    } else if (isQuote(c)) {
                        parser.state = S.SGML_DECL_QUOTED;
                        parser.sgmlDecl += c;
                    } else parser.sgmlDecl += c;
                    continue;
                case S.SGML_DECL_QUOTED:
                    if (c === parser.q) {
                        parser.state = S.SGML_DECL;
                        parser.q = '';
                    }
                    parser.sgmlDecl += c;
                    continue;
                case S.DOCTYPE:
                    if (c === '>') {
                        parser.state = S.TEXT;
                        emitNode(parser, 'ondoctype', parser.doctype);
                        parser.doctype = true // just remember that we saw it.
                        ;
                    } else {
                        parser.doctype += c;
                        if (c === '[') parser.state = S.DOCTYPE_DTD;
                        else if (isQuote(c)) {
                            parser.state = S.DOCTYPE_QUOTED;
                            parser.q = c;
                        }
                    }
                    continue;
                case S.DOCTYPE_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.q = '';
                        parser.state = S.DOCTYPE;
                    }
                    continue;
                case S.DOCTYPE_DTD:
                    parser.doctype += c;
                    if (c === ']') parser.state = S.DOCTYPE;
                    else if (isQuote(c)) {
                        parser.state = S.DOCTYPE_DTD_QUOTED;
                        parser.q = c;
                    }
                    continue;
                case S.DOCTYPE_DTD_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.q = '';
                    }
                    continue;
                case S.COMMENT:
                    if (c === '-') parser.state = S.COMMENT_ENDING;
                    else parser.comment += c;
                    continue;
                case S.COMMENT_ENDING:
                    if (c === '-') {
                        parser.state = S.COMMENT_ENDED;
                        parser.comment = textopts(parser.opt, parser.comment);
                        if (parser.comment) emitNode(parser, 'oncomment', parser.comment);
                        parser.comment = '';
                    } else {
                        parser.comment += '-' + c;
                        parser.state = S.COMMENT;
                    }
                    continue;
                case S.COMMENT_ENDED:
                    if (c !== '>') {
                        strictFail(parser, 'Malformed comment');
                        // allow <\!-- blah -- bloo --> in non-strict mode,
                        // which is a comment of " blah -- bloo "
                        parser.comment += '--' + c;
                        parser.state = S.COMMENT;
                    } else parser.state = S.TEXT;
                    continue;
                case S.CDATA:
                    if (c === ']') parser.state = S.CDATA_ENDING;
                    else parser.cdata += c;
                    continue;
                case S.CDATA_ENDING:
                    if (c === ']') parser.state = S.CDATA_ENDING_2;
                    else {
                        parser.cdata += ']' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.CDATA_ENDING_2:
                    if (c === '>') {
                        if (parser.cdata) emitNode(parser, 'oncdata', parser.cdata);
                        emitNode(parser, 'onclosecdata');
                        parser.cdata = '';
                        parser.state = S.TEXT;
                    } else if (c === ']') parser.cdata += ']';
                    else {
                        parser.cdata += ']]' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.PROC_INST:
                    if (c === '?') parser.state = S.PROC_INST_ENDING;
                    else if (isWhitespace(c)) parser.state = S.PROC_INST_BODY;
                    else parser.procInstName += c;
                    continue;
                case S.PROC_INST_BODY:
                    if (!parser.procInstBody && isWhitespace(c)) continue;
                    else if (c === '?') parser.state = S.PROC_INST_ENDING;
                    else parser.procInstBody += c;
                    continue;
                case S.PROC_INST_ENDING:
                    if (c === '>') {
                        emitNode(parser, 'onprocessinginstruction', {
                            name: parser.procInstName,
                            body: parser.procInstBody
                        });
                        parser.procInstName = parser.procInstBody = '';
                        parser.state = S.TEXT;
                    } else {
                        parser.procInstBody += '?' + c;
                        parser.state = S.PROC_INST_BODY;
                    }
                    continue;
                case S.OPEN_TAG:
                    if (isMatch(nameBody, c)) parser.tagName += c;
                    else {
                        newTag(parser);
                        if (c === '>') openTag(parser);
                        else if (c === '/') parser.state = S.OPEN_TAG_SLASH;
                        else {
                            if (!isWhitespace(c)) strictFail(parser, 'Invalid character in tag name');
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.OPEN_TAG_SLASH:
                    if (c === '>') {
                        openTag(parser, true);
                        closeTag(parser);
                    } else {
                        strictFail(parser, 'Forward-slash in opening tag not followed by >');
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.ATTRIB:
                    // haven't read the attribute name yet.
                    if (isWhitespace(c)) continue;
                    else if (c === '>') openTag(parser);
                    else if (c === '/') parser.state = S.OPEN_TAG_SLASH;
                    else if (isMatch(nameStart, c)) {
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else strictFail(parser, 'Invalid attribute name');
                    continue;
                case S.ATTRIB_NAME:
                    if (c === '=') parser.state = S.ATTRIB_VALUE;
                    else if (c === '>') {
                        strictFail(parser, 'Attribute without value');
                        parser.attribValue = parser.attribName;
                        attrib(parser);
                        openTag(parser);
                    } else if (isWhitespace(c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;
                    else if (isMatch(nameBody, c)) parser.attribName += c;
                    else strictFail(parser, 'Invalid attribute name');
                    continue;
                case S.ATTRIB_NAME_SAW_WHITE:
                    if (c === '=') parser.state = S.ATTRIB_VALUE;
                    else if (isWhitespace(c)) continue;
                    else {
                        strictFail(parser, 'Attribute without value');
                        parser.tag.attributes[parser.attribName] = '';
                        parser.attribValue = '';
                        emitNode(parser, 'onattribute', {
                            name: parser.attribName,
                            value: ''
                        });
                        parser.attribName = '';
                        if (c === '>') openTag(parser);
                        else if (isMatch(nameStart, c)) {
                            parser.attribName = c;
                            parser.state = S.ATTRIB_NAME;
                        } else {
                            strictFail(parser, 'Invalid attribute name');
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.ATTRIB_VALUE:
                    if (isWhitespace(c)) continue;
                    else if (isQuote(c)) {
                        parser.q = c;
                        parser.state = S.ATTRIB_VALUE_QUOTED;
                    } else {
                        strictFail(parser, 'Unquoted attribute value');
                        parser.state = S.ATTRIB_VALUE_UNQUOTED;
                        parser.attribValue = c;
                    }
                    continue;
                case S.ATTRIB_VALUE_QUOTED:
                    if (c !== parser.q) {
                        if (c === '&') parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                        else parser.attribValue += c;
                        continue;
                    }
                    attrib(parser);
                    parser.q = '';
                    parser.state = S.ATTRIB_VALUE_CLOSED;
                    continue;
                case S.ATTRIB_VALUE_CLOSED:
                    if (isWhitespace(c)) parser.state = S.ATTRIB;
                    else if (c === '>') openTag(parser);
                    else if (c === '/') parser.state = S.OPEN_TAG_SLASH;
                    else if (isMatch(nameStart, c)) {
                        strictFail(parser, 'No whitespace between attributes');
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else strictFail(parser, 'Invalid attribute name');
                    continue;
                case S.ATTRIB_VALUE_UNQUOTED:
                    if (!isAttribEnd(c)) {
                        if (c === '&') parser.state = S.ATTRIB_VALUE_ENTITY_U;
                        else parser.attribValue += c;
                        continue;
                    }
                    attrib(parser);
                    if (c === '>') openTag(parser);
                    else parser.state = S.ATTRIB;
                    continue;
                case S.CLOSE_TAG:
                    if (!parser.tagName) {
                        if (isWhitespace(c)) continue;
                        else if (notMatch(nameStart, c)) {
                            if (parser.script) {
                                parser.script += '</' + c;
                                parser.state = S.SCRIPT;
                            } else strictFail(parser, 'Invalid tagname in closing tag.');
                        } else parser.tagName = c;
                    } else if (c === '>') closeTag(parser);
                    else if (isMatch(nameBody, c)) parser.tagName += c;
                    else if (parser.script) {
                        parser.script += '</' + parser.tagName;
                        parser.tagName = '';
                        parser.state = S.SCRIPT;
                    } else {
                        if (!isWhitespace(c)) strictFail(parser, 'Invalid tagname in closing tag');
                        parser.state = S.CLOSE_TAG_SAW_WHITE;
                    }
                    continue;
                case S.CLOSE_TAG_SAW_WHITE:
                    if (isWhitespace(c)) continue;
                    if (c === '>') closeTag(parser);
                    else strictFail(parser, 'Invalid characters in closing tag');
                    continue;
                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                    var returnState;
                    var buffer;
                    switch(parser.state){
                        case S.TEXT_ENTITY:
                            returnState = S.TEXT;
                            buffer = 'textNode';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_Q:
                            returnState = S.ATTRIB_VALUE_QUOTED;
                            buffer = 'attribValue';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_U:
                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                            buffer = 'attribValue';
                            break;
                    }
                    if (c === ';') {
                        parser[buffer] += parseEntity(parser);
                        parser.entity = '';
                        parser.state = returnState;
                    } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) parser.entity += c;
                    else {
                        strictFail(parser, 'Invalid character in entity name');
                        parser[buffer] += '&' + parser.entity + c;
                        parser.entity = '';
                        parser.state = returnState;
                    }
                    continue;
                default:
                    throw new Error(parser, 'Unknown state: ' + parser.state);
            }
        } // while
        if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
        return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ /* istanbul ignore next */ if (!String.fromCodePoint) (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) return '';
            var result = '';
            while(++index < length){
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint // not an integer
                ) throw RangeError('Invalid code point: ' + codePoint);
                if (codePoint <= 65535) codeUnits.push(codePoint);
                else {
                    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    codePoint -= 65536;
                    highSurrogate = (codePoint >> 10) + 55296;
                    lowSurrogate = codePoint % 1024 + 56320;
                    codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                    result += stringFromCharCode.apply(null, codeUnits);
                    codeUnits.length = 0;
                }
            }
            return result;
        };
        /* istanbul ignore next */ if (Object.defineProperty) Object.defineProperty(String, 'fromCodePoint', {
            value: fromCodePoint,
            configurable: true,
            writable: true
        });
        else String.fromCodePoint = fromCodePoint;
    })();
})(typeof exports === 'undefined' ? this.sax = {
} : exports);

},{"buffer":"bOetu","stream":"ylvqt","string_decoder":"vLxWd"}],"bOetu":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
var base64 = require('base64-js');
var ieee754 = require('ieee754');
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 2147483647;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    var length = byteLength1(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength1(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength1;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 255 // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i1;
    if (dir) {
        var foundIndex = -1;
        for(i1 = byteOffset; i1 < arrLength; i1++)if (read(arr, i1) === read(val, foundIndex === -1 ? 0 : i1 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i1;
            if (i1 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i1 -= i1 - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i1 = byteOffset; i1 >= 0; i1--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i1 + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i1;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 127);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 256))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 256))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 256))val += this[offset + i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 256))val += this[offset + --i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while(++i < byteLength && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while(++i < byteLength && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 55295 && codePoint < 57344) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 255);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"base64-js":"nR26C","ieee754":"ljh7N"}],"nR26C":[function(require,module,exports) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i1 = 0, len1 = code.length; i1 < len1; ++i1){
    lookup[i1] = code[i1];
    revLookup[code.charCodeAt(i1)] = i1;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + '=');
    }
    return parts.join('');
}

},{}],"ljh7N":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"ylvqt":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;
var EE = require('events').EventEmitter;
var inherits = require('inherits');
inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js');
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js');
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.
function Stream() {
    EE.call(this);
}
Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
        if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) source.pause();
        }
    }
    source.on('data', ondata);
    function ondrain() {
        if (source.readable && source.resume) source.resume();
    }
    dest.on('drain', ondrain);
    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === 'function') dest.destroy();
    }
    // don't leave dangling pipes when there are errors.
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, 'error') === 0) throw er; // Unhandled stream error in pipe.
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    // remove all the event listeners that were added.
    function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);
        source.removeListener('end', onend);
        source.removeListener('close', onclose);
        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);
        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);
        dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
};

},{"events":"bHM3D","inherits":"d3hL2","readable-stream/lib/_stream_readable.js":"cOmIG","readable-stream/lib/_stream_writable.js":"8Zkyc","readable-stream/lib/_stream_duplex.js":"gXe2L","readable-stream/lib/_stream_transform.js":"d0v77","readable-stream/lib/_stream_passthrough.js":"dYz8E","readable-stream/lib/internal/streams/end-of-stream.js":"lMiCr","readable-stream/lib/internal/streams/pipeline.js":"l5HmF"}],"bHM3D":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== 'function') throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === 'error';
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === 'function') ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === 'function') // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
        }
    } else if (typeof list !== 'function') {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === 'function') this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === 'function') return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === 'function') return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === 'function') emitter.removeListener('error', errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== 'error') addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === 'function') // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"d3hL2":[function(require,module,exports) {
if (typeof Object.create === 'function') // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"cOmIG":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = require('./internal/streams/stream');
/*</replacement>*/ var Buffer = require('buffer').Buffer;
var OurUint8Array = global.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog('stream');
else debug = function debug() {
};
/*</replacement>*/ var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    'error',
    'close',
    'destroy',
    'pause',
    'resume'
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require('./_stream_duplex');
    options = options || {
    }; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true; // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true; // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy; // has it been destroyed
    this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || require('./_stream_duplex');
    if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex); // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === 'function') this._read = options.read;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
         // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === 'string') {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = '';
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug('readableAddChunk', chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) chunk = _uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            else if (state.destroyed) return false;
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    } // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit('data', chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) er = new ERR_INVALID_ARG_TYPE('chunk', [
        'string',
        'Buffer',
        'Uint8Array'
    ], chunk);
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
}; // backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = '';
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== '') this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
}; // Don't raise the hwm > 1GB
var MAX_HWM = 1073741824;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    } // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n; // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
} // you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
    } else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true; // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true; // call internal read method
        this._read(state.highWaterMark);
        state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit('data', ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug('onEofChunk');
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug('emitReadable', state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug('emitReadable_', state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit('readable');
        state.emittedReadable = false;
    } // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once('end', endFn);
    dest.on('unpipe', onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug('onunpipe');
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug('onend');
        dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug('cleanup'); // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', unpipe);
        src.removeListener('data', ondata);
        cleanedUp = true; // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on('data', ondata);
    function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        debug('dest.write', ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug('false write response, pause', state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
    } // Make sure our error handler is attached before userland ones.
    prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
    }
    dest.once('finish', onfinish);
    function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
    } // tell the dest that it's being piped to
    dest.emit('pipe', src); // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug('pipe resume');
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    }; // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this; // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes; // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this, unpipeInfo);
        return this;
    } // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit('unpipe', this, {
            hasUnpiped: false
        });
        return this;
    } // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit('unpipe', this, unpipeInfo);
    return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === 'data') {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === 'readable') {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug('on readable', state.length, state.reading);
            if (state.length) emitReadable(this);
            else if (!state.reading) process.nextTick(nReadingNextTick, this);
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === 'readable') // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === 'readable' || ev === undefined) // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
function updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount('readable') > 0;
    if (state.resumeScheduled && !state.paused) // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
    else if (self.listenerCount('data') > 0) self.resume();
}
function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug('resume'); // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug('resume', state.reading);
    if (!state.reading) stream.read(0);
    state.resumeScheduled = false;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug('call pause flowing=%j', this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);
    while(state.flowing && stream.read() !== null);
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === 'function') this[i] = (function methodWrap(method) {
        return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
        };
    })(i);
     // proxy certain important events.
    for(var n1 = 0; n1 < kProxyEvents.length; n1++)stream.on(kProxyEvents[n1], this.emit.bind(this, kProxyEvents[n1]));
     // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === 'function') Readable.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === undefined) createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    return createReadableStreamAsyncIterator(this);
};
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) this._readableState.flowing = state;
    }
}); // exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = state.buffer.consume(n, state.decoder);
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug('endReadable', state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
        }
    }
}
if (typeof Symbol === 'function') Readable.from = function(iterable, opts) {
    if (from === undefined) from = require('./internal/streams/from');
    return from(Readable, iterable, opts);
};
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

},{"process":"lDnB8","events":"bHM3D","./internal/streams/stream":"2DxWV","buffer":"bOetu","util":"joWnX","./internal/streams/buffer_list":"m1twv","./internal/streams/destroy":"fTkLZ","./internal/streams/state":"c6Ca1","../errors":"9j4wu","inherits":"d3hL2","./_stream_duplex":"gXe2L","string_decoder/":"vLxWd","./internal/streams/async_iterator":"1SRgg","./internal/streams/from":"6Gblw"}],"lDnB8":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {
};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {
};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {
};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"2DxWV":[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":"bHM3D"}],"joWnX":[function(require,module,exports) {
"use strict";

},{}],"m1twv":[function(require,module,exports) {
'use strict';
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {
        };
        if (i % 2) ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
        else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        else ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var _require = require('buffer'), Buffer = _require.Buffer;
var _require2 = require('util'), inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ (function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return '';
                var p = this.head;
                var ret = '' + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            } // Consumes a specified amount of bytes or characters from the buffered data.
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) // First chunk is a perfect match.
                ret = this.shift();
                else // Result spans more than one buffer.
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            } // Consumes a specified amount of characters from the buffered data.
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            } // Consumes a specified amount of bytes from the buffered data.
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            } // Make sure the linked list only shows the minimal necessary information.
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread({
                }, options, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
})();

},{"buffer":"bOetu","util":"joWnX"}],"fTkLZ":[function(require,module,exports) {
var process = require("process");
'use strict'; // undocumented cb() API, needed for core, not for public API
function destroy(err1, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err1);
        else if (err1) {
            if (!this._writableState) process.nextTick(emitErrorNT, this, err1);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err1);
            }
        }
        return this;
    } // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
     // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err1 || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) process.nextTick(emitErrorAndCloseNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else process.nextTick(emitCloseNT, _this);
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else process.nextTick(emitCloseNT, _this);
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit('close');
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit('error', err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit('error', err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};

},{"process":"lDnB8"}],"c6Ca1":[function(require,module,exports) {
'use strict';
var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : 'highWaterMark';
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    } // Default value
    return state.objectMode ? 16 : 16384;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};

},{"../../../errors":"9j4wu"}],"9j4wu":[function(require,module,exports) {
'use strict';
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
var codes = {
};
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError1 = /*#__PURE__*/ function(_Base) {
        _inheritsLoose(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError;
    }(Base);
    NodeError1.prototype.name = Base.name;
    NodeError1.prototype.code = code;
    codes[code] = NodeError1;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== 'number') start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType('ERR_INVALID_OPT_VALUE', function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
    } else determiner = 'must be';
    var msg;
    if (endsWith(name, ' argument')) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    else {
        var type = includes(name, '.') ? 'property' : 'argument';
        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function(name) {
    return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function(name) {
    return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function(arg) {
    return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],"gXe2L":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
// Allow the keys array to be GC'ed.
var keys1 = objectKeys(Writable.prototype);
for(var v = 0; v < keys1.length; v++){
    var method = keys1[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once('end', onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
}); // the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return; // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
         // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});

},{"process":"lDnB8","./_stream_readable":"cOmIG","./_stream_writable":"8Zkyc","inherits":"d3hL2"}],"8Zkyc":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: require('util-deprecate')
};
/*</replacement>*/ /*<replacement>*/ var Stream = require('./internal/streams/stream');
/*</replacement>*/ var Buffer = require('buffer').Buffer;
var OurUint8Array = global.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {
}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require('./_stream_duplex');
    options = options || {
    }; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called
    this.finalCalled = false; // drain event flag.
    this.needDrain = false; // at the start of calling end()
    this.ending = false; // when end() has been called, and returned
    this.ended = false; // when 'finish' is emitted
    this.finished = false; // has it been destroyed
    this.destroyed = false; // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0; // a flag to see when we're in the middle of a write.
    this.writing = false; // when true all writes will be buffered until .uncork() call
    this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true; // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    }; // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null; // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false; // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy; // count buffered requests
    this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", 'DEP0003')
        });
    } catch (_) {
    }
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else realHasInstance = function realHasInstance(object) {
    return object instanceof this;
};
function Writable(options) {
    Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex); // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === 'function') this._write = options.write;
        if (typeof options.writev === 'function') this._writev = options.writev;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
        if (typeof options.final === 'function') this._final = options.final;
    }
    Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) er = new ERR_STREAM_NULL_VALUES();
    else if (typeof chunk !== 'string' && !state.objectMode) er = new ERR_INVALID_ARG_TYPE('chunk', [
        'string',
        'Buffer'
    ], chunk);
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);
    if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = 'buffer';
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== 'function') cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!([
        'hex',
        'utf8',
        'utf-8',
        'ascii',
        'binary',
        'base64',
        'ucs2',
        'ucs-2',
        'utf16le',
        'utf-16le',
        'raw'
    ].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = 'buffer';
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er); // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er); // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
        if (sync) process.nextTick(afterWrite, stream, state, finished, cb);
        else afterWrite(stream, state, finished, cb);
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
    }
} // if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else state.corkedRequestsFree = new CorkedRequest(state);
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) break;
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    } // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) errorOrDestroy(stream, err);
        state.prefinished = true;
        stream.emit('prefinish');
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === 'function' && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit('prefinish');
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit('finish');
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) stream.destroy();
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    } // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) return false;
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) return;
         // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};

},{"process":"lDnB8","util-deprecate":"bfjXI","./internal/streams/stream":"2DxWV","buffer":"bOetu","./internal/streams/destroy":"fTkLZ","./internal/streams/state":"c6Ca1","../errors":"9j4wu","inherits":"d3hL2","./_stream_duplex":"gXe2L"}],"bfjXI":[function(require,module,exports) {
var global = arguments[3];
/**
 * Module exports.
 */ module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */ function deprecate(fn, msg) {
    if (config('noDeprecation')) return fn;
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config('throwDeprecation')) throw new Error(msg);
            else if (config('traceDeprecation')) console.trace(msg);
            else console.warn(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */ function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
        if (!global.localStorage) return false;
    } catch (_) {
        return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === 'true';
}

},{}],"vLxWd":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
/*<replacement>*/ var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = '' + encoding;
    switch(encoding && encoding.toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while(true)switch(enc){
        case 'utf8':
        case 'utf-8':
            return 'utf8';
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return 'utf16le';
        case 'latin1':
        case 'binary':
            return 'latin1';
        case 'base64':
        case 'ascii':
        case 'hex':
            return enc;
        default:
            if (retried) return; // undefined
            enc = ('' + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
            self.lastNeed = 1;
            return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
                self.lastNeed = 2;
                return '\ufffd';
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + '\ufffd';
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":"hZf9b"}],"hZf9b":[function(require,module,exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = require('buffer');
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') throw new TypeError('Argument must not be a number');
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') throw new TypeError('Argument must be a number');
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') throw new TypeError('Argument must be a number');
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') throw new TypeError('Argument must be a number');
    return buffer.SlowBuffer(size);
};

},{"buffer":"bOetu"}],"1SRgg":[function(require,module,exports) {
var process = require("process");
'use strict';
var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read(); // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) return Promise.reject(error);
        if (this[kEnded]) return Promise.resolve(createIterResult(undefined, true));
        if (this[kStream].destroyed) // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function(resolve, reject) {
            process.nextTick(function() {
                if (_this[kError]) reject(_this[kError]);
                else resolve(createIterResult(undefined, true));
            });
        });
         // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) promise = new Promise(wrapForNext(lastPromise, this));
        else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) return Promise.resolve(createIterResult(data, false));
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {
    }, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
            var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on('readable', onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;

},{"process":"lDnB8","./end-of-stream":"lMiCr"}],"lMiCr":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';
var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        callback.apply(this, args);
    };
}
function noop() {
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
    if (typeof opts === 'function') return eos(stream, null, opts);
    if (!opts) opts = {
    };
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on('finish', onfinish);
    };
    if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();
        else stream.on('request', onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
    }
    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false) stream.on('error', onerror);
    stream.on('close', onclose);
    return function() {
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
    };
}
module.exports = eos;

},{"../../../errors":"9j4wu"}],"6Gblw":[function(require,module,exports) {
module.exports = function() {
    throw new Error('Readable.from is not available in the browser');
};

},{}],"d0v77":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';
module.exports = Transform;
var _require$codes = require('../errors').codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) return this.emit('error', new ERR_MULTIPLE_CALLBACK());
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    }; // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
    } // When the writable side finishes, then flush out anything remaining.
    this.on('prefinish', prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === 'function' && !this._readableState.destroyed) this._flush(function(er, data) {
        done(_this, er, data);
    });
    else done(this, null, null);
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
};
Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er) return stream.emit('error', er);
    if (data != null) stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}

},{"../errors":"9j4wu","./_stream_duplex":"gXe2L","inherits":"d3hL2"}],"dYz8E":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';
module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};

},{"./_stream_transform":"d0v77","inherits":"d3hL2"}],"l5HmF":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';
var eos;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = require('../../../errors').codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on('close', function() {
        closed = true;
    });
    if (eos === undefined) eos = require('./end-of-stream');
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true; // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === 'function') return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED('pipe'));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== 'function') return noop;
    return streams.pop();
}
function pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++)streams[_key] = arguments[_key];
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new ERR_MISSING_ARGS('streams');
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;

},{"../../../errors":"9j4wu","./end-of-stream":"lMiCr"}],"hdwAm":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    exports.stripBOM = function(str) {
        if (str[0] === '\uFEFF') return str.substring(1);
        else return str;
    };
}).call(this);

},{}],"ckxC8":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports.normalize = function(str) {
        return str.toLowerCase();
    };
    exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, '');
    };
    exports.parseNumbers = function(str) {
        if (!isNaN(str)) str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        return str;
    };
    exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) str = str.toLowerCase() === 'true';
        return str;
    };
}).call(this);

},{}],"59lXe":[function(require,module,exports) {
var global = arguments[3];
var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply;
// DOM APIs, for completeness
exports.setTimeout = function() {
    return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
    return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function(timeout) {
    if (timeout) timeout.close();
};
function Timeout(id, clearFn) {
    this._id = id;
    this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {
};
Timeout.prototype.close = function() {
    this._clearFn.call(scope, this._id);
};
// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = msecs;
};
exports.unenroll = function(item) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = -1;
};
exports._unrefActive = exports.active = function(item) {
    clearTimeout(item._idleTimeoutId);
    var msecs = item._idleTimeout;
    if (msecs >= 0) item._idleTimeoutId = setTimeout(function onTimeout() {
        if (item._onTimeout) item._onTimeout();
    }, msecs);
};
// setimmediate attaches itself to the global object
require("setimmediate");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;

},{"setimmediate":"jbb8I"}],"jbb8I":[function(require,module,exports) {
var process = require("process");
var global1 = arguments[3];
(function(global, undefined) {
    if (global.setImmediate) return;
    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {
    };
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;
    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") callback = new Function("" + callback);
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for(var i = 0; i < args.length; i++)args[i] = arguments[i + 1];
        // Store and register the task
        var task = {
            callback: callback,
            args: args
        };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }
    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }
    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch(args.length){
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }
    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
        // "too much recursion" error.
        setTimeout(runIfPresent, 0, handle);
        else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally{
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }
    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function() {
                runIfPresent(handle);
            });
        };
    }
    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }
    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) runIfPresent(+event.data.slice(messagePrefix.length));
        };
        if (global.addEventListener) global.addEventListener("message", onGlobalMessage, false);
        else global.attachEvent("onmessage", onGlobalMessage);
        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }
    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };
        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }
    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function() {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }
    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }
    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
    // Don't get fooled by e.g. browserify environments.
    if (({
    }).toString.call(global.process) === "[object process]") // For Node.js before 0.9
    installNextTickImplementation();
    else if (canUsePostMessage()) // For non-IE10 modern browsers
    installPostMessageImplementation();
    else if (global.MessageChannel) // For web workers, where supported
    installMessageChannelImplementation();
    else if (doc && "onreadystatechange" in doc.createElement("script")) // For IE 6–8
    installReadyStateChangeImplementation();
    else // For older browsers
    installSetTimeoutImplementation();
    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global1 === "undefined" ? this : global1 : self);

},{"process":"lDnB8"}],"a22RV":[function(require,module,exports) {
/*jslint node:true */ var xml2js = require('./xml2js');
var xml2json = require('./xml2json');
var js2xml = require('./js2xml');
var json2xml = require('./json2xml');
module.exports = {
    xml2js: xml2js,
    xml2json: xml2json,
    js2xml: js2xml,
    json2xml: json2xml
};

},{"./xml2js":"9phWB","./xml2json":"7o1rr","./js2xml":"fQpG1","./json2xml":"jFMMv"}],"9phWB":[function(require,module,exports) {
var sax = require('sax');
var expat /*= require('node-expat');*/  = {
    on: function() {
    },
    parse: function() {
    }
};
var helper = require('./options-helper');
var isArray = require('./array-helper').isArray;
var options;
var pureJsParser = true;
var currentElement;
function validateOptions(userOptions) {
    options = helper.copyOptions(userOptions);
    helper.ensureFlagExists('ignoreDeclaration', options);
    helper.ensureFlagExists('ignoreInstruction', options);
    helper.ensureFlagExists('ignoreAttributes', options);
    helper.ensureFlagExists('ignoreText', options);
    helper.ensureFlagExists('ignoreComment', options);
    helper.ensureFlagExists('ignoreCdata', options);
    helper.ensureFlagExists('ignoreDoctype', options);
    helper.ensureFlagExists('compact', options);
    helper.ensureFlagExists('alwaysChildren', options);
    helper.ensureFlagExists('addParent', options);
    helper.ensureFlagExists('trim', options);
    helper.ensureFlagExists('nativeType', options);
    helper.ensureFlagExists('nativeTypeAttributes', options);
    helper.ensureFlagExists('sanitize', options);
    helper.ensureFlagExists('instructionHasAttributes', options);
    helper.ensureFlagExists('captureSpacesBetweenElements', options);
    helper.ensureAlwaysArrayExists(options);
    helper.ensureKeyExists('declaration', options);
    helper.ensureKeyExists('instruction', options);
    helper.ensureKeyExists('attributes', options);
    helper.ensureKeyExists('text', options);
    helper.ensureKeyExists('comment', options);
    helper.ensureKeyExists('cdata', options);
    helper.ensureKeyExists('doctype', options);
    helper.ensureKeyExists('type', options);
    helper.ensureKeyExists('name', options);
    helper.ensureKeyExists('elements', options);
    helper.ensureKeyExists('parent', options);
    helper.checkFnExists('doctype', options);
    helper.checkFnExists('instruction', options);
    helper.checkFnExists('cdata', options);
    helper.checkFnExists('comment', options);
    helper.checkFnExists('text', options);
    helper.checkFnExists('instructionName', options);
    helper.checkFnExists('elementName', options);
    helper.checkFnExists('attributeName', options);
    helper.checkFnExists('attributeValue', options);
    helper.checkFnExists('attributes', options);
    return options;
}
function nativeType(value) {
    var nValue = Number(value);
    if (!isNaN(nValue)) return nValue;
    var bValue = value.toLowerCase();
    if (bValue === 'true') return true;
    else if (bValue === 'false') return false;
    return value;
}
function addField(type, value) {
    var key;
    if (options.compact) {
        if (!currentElement[options[type + 'Key']] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)) currentElement[options[type + 'Key']] = [];
        if (currentElement[options[type + 'Key']] && !isArray(currentElement[options[type + 'Key']])) currentElement[options[type + 'Key']] = [
            currentElement[options[type + 'Key']]
        ];
        if (type + 'Fn' in options && typeof value === 'string') value = options[type + 'Fn'](value, currentElement);
        if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {
            for(key in value)if (value.hasOwnProperty(key)) {
                if ('instructionFn' in options) value[key] = options.instructionFn(value[key], key, currentElement);
                else {
                    var temp = value[key];
                    delete value[key];
                    value[options.instructionNameFn(key, temp, currentElement)] = temp;
                }
            }
        }
        if (isArray(currentElement[options[type + 'Key']])) currentElement[options[type + 'Key']].push(value);
        else currentElement[options[type + 'Key']] = value;
    } else {
        if (!currentElement[options.elementsKey]) currentElement[options.elementsKey] = [];
        var element = {
        };
        element[options.typeKey] = type;
        if (type === 'instruction') {
            for(key in value){
                if (value.hasOwnProperty(key)) break;
            }
            element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;
            if (options.instructionHasAttributes) {
                element[options.attributesKey] = value[key][options.attributesKey];
                if ('instructionFn' in options) element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
            } else {
                if ('instructionFn' in options) value[key] = options.instructionFn(value[key], key, currentElement);
                element[options.instructionKey] = value[key];
            }
        } else {
            if (type + 'Fn' in options) value = options[type + 'Fn'](value, currentElement);
            element[options[type + 'Key']] = value;
        }
        if (options.addParent) element[options.parentKey] = currentElement;
        currentElement[options.elementsKey].push(element);
    }
}
function manipulateAttributes(attributes) {
    if ('attributesFn' in options && attributes) attributes = options.attributesFn(attributes, currentElement);
    if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {
        var key;
        for(key in attributes)if (attributes.hasOwnProperty(key)) {
            if (options.trim) attributes[key] = attributes[key].trim();
            if (options.nativeTypeAttributes) attributes[key] = nativeType(attributes[key]);
            if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
            if ('attributeNameFn' in options) {
                var temp = attributes[key];
                delete attributes[key];
                attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
            }
        }
    }
    return attributes;
}
function onInstruction(instruction) {
    var attributes = {
    };
    if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {
        var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
        var match;
        while((match = attrsRegExp.exec(instruction.body)) !== null)attributes[match[1]] = match[2] || match[3] || match[4];
        attributes = manipulateAttributes(attributes);
    }
    if (instruction.name.toLowerCase() === 'xml') {
        if (options.ignoreDeclaration) return;
        currentElement[options.declarationKey] = {
        };
        if (Object.keys(attributes).length) currentElement[options.declarationKey][options.attributesKey] = attributes;
        if (options.addParent) currentElement[options.declarationKey][options.parentKey] = currentElement;
    } else {
        if (options.ignoreInstruction) return;
        if (options.trim) instruction.body = instruction.body.trim();
        var value = {
        };
        if (options.instructionHasAttributes && Object.keys(attributes).length) {
            value[instruction.name] = {
            };
            value[instruction.name][options.attributesKey] = attributes;
        } else value[instruction.name] = instruction.body;
        addField('instruction', value);
    }
}
function onStartElement(name, attributes) {
    var element;
    if (typeof name === 'object') {
        attributes = name.attributes;
        name = name.name;
    }
    attributes = manipulateAttributes(attributes);
    if ('elementNameFn' in options) name = options.elementNameFn(name, currentElement);
    if (options.compact) {
        element = {
        };
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
            element[options.attributesKey] = {
            };
            var key;
            for(key in attributes)if (attributes.hasOwnProperty(key)) element[options.attributesKey][key] = attributes[key];
        }
        if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) currentElement[name] = [];
        if (currentElement[name] && !isArray(currentElement[name])) currentElement[name] = [
            currentElement[name]
        ];
        if (isArray(currentElement[name])) currentElement[name].push(element);
        else currentElement[name] = element;
    } else {
        if (!currentElement[options.elementsKey]) currentElement[options.elementsKey] = [];
        element = {
        };
        element[options.typeKey] = 'element';
        element[options.nameKey] = name;
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) element[options.attributesKey] = attributes;
        if (options.alwaysChildren) element[options.elementsKey] = [];
        currentElement[options.elementsKey].push(element);
    }
    element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent
    currentElement = element;
}
function onText(text) {
    if (options.ignoreText) return;
    if (!text.trim() && !options.captureSpacesBetweenElements) return;
    if (options.trim) text = text.trim();
    if (options.nativeType) text = nativeType(text);
    if (options.sanitize) text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    addField('text', text);
}
function onComment(comment) {
    if (options.ignoreComment) return;
    if (options.trim) comment = comment.trim();
    addField('comment', comment);
}
function onEndElement(name) {
    var parentElement = currentElement[options.parentKey];
    if (!options.addParent) delete currentElement[options.parentKey];
    currentElement = parentElement;
}
function onCdata(cdata) {
    if (options.ignoreCdata) return;
    if (options.trim) cdata = cdata.trim();
    addField('cdata', cdata);
}
function onDoctype(doctype) {
    if (options.ignoreDoctype) return;
    doctype = doctype.replace(/^ /, '');
    if (options.trim) doctype = doctype.trim();
    addField('doctype', doctype);
}
function onError(error) {
    error.note = error; //console.error(error);
}
module.exports = function(xml, userOptions) {
    var parser = pureJsParser ? sax.parser(true, {
    }) : parser = new expat.Parser('UTF-8');
    var result = {
    };
    currentElement = result;
    options = validateOptions(userOptions);
    if (pureJsParser) {
        parser.opt = {
            strictEntities: true
        };
        parser.onopentag = onStartElement;
        parser.ontext = onText;
        parser.oncomment = onComment;
        parser.onclosetag = onEndElement;
        parser.onerror = onError;
        parser.oncdata = onCdata;
        parser.ondoctype = onDoctype;
        parser.onprocessinginstruction = onInstruction;
    } else {
        parser.on('startElement', onStartElement);
        parser.on('text', onText);
        parser.on('comment', onComment);
        parser.on('endElement', onEndElement);
        parser.on('error', onError);
    //parser.on('startCdata', onStartCdata);
    //parser.on('endCdata', onEndCdata);
    //parser.on('entityDecl', onEntityDecl);
    }
    if (pureJsParser) parser.write(xml).close();
    else {
        if (!parser.parse(xml)) throw new Error('XML parsing error: ' + parser.getError());
    }
    if (result[options.elementsKey]) {
        var temp = result[options.elementsKey];
        delete result[options.elementsKey];
        result[options.elementsKey] = temp;
        delete result.text;
    }
    return result;
};

},{"sax":"gBT5g","./options-helper":"jReS5","./array-helper":"9HMGN"}],"jReS5":[function(require,module,exports) {
var isArray = require('./array-helper').isArray;
module.exports = {
    copyOptions: function(options) {
        var key, copy = {
        };
        for(key in options)if (options.hasOwnProperty(key)) copy[key] = options[key];
        return copy;
    },
    ensureFlagExists: function(item, options) {
        if (!(item in options) || typeof options[item] !== 'boolean') options[item] = false;
    },
    ensureSpacesExists: function(options) {
        if (!('spaces' in options) || typeof options.spaces !== 'number' && typeof options.spaces !== 'string') options.spaces = 0;
    },
    ensureAlwaysArrayExists: function(options) {
        if (!('alwaysArray' in options) || typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray)) options.alwaysArray = false;
    },
    ensureKeyExists: function(key, options) {
        if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') options[key + 'Key'] = options.compact ? '_' + key : key;
    },
    checkFnExists: function(key, options) {
        return key + 'Fn' in options;
    }
};

},{"./array-helper":"9HMGN"}],"9HMGN":[function(require,module,exports) {
module.exports = {
    isArray: function(value) {
        if (Array.isArray) return Array.isArray(value);
        // fallback for older browsers like  IE 8
        return Object.prototype.toString.call(value) === '[object Array]';
    }
};

},{}],"7o1rr":[function(require,module,exports) {
var helper = require('./options-helper');
var xml2js = require('./xml2js');
function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureSpacesExists(options);
    return options;
}
module.exports = function(xml, userOptions) {
    var options, js, json, parentKey;
    options = validateOptions(userOptions);
    js = xml2js(xml, options);
    parentKey = 'compact' in options && options.compact ? '_parent' : 'parent';
    // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this
    if ('addParent' in options && options.addParent) json = JSON.stringify(js, function(k, v) {
        return k === parentKey ? '_' : v;
    }, options.spaces);
    else json = JSON.stringify(js, null, options.spaces);
    return json.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
};

},{"./options-helper":"jReS5","./xml2js":"9phWB"}],"fQpG1":[function(require,module,exports) {
var helper = require('./options-helper');
var isArray = require('./array-helper').isArray;
var currentElement, currentElementName;
function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureFlagExists('ignoreDeclaration', options);
    helper.ensureFlagExists('ignoreInstruction', options);
    helper.ensureFlagExists('ignoreAttributes', options);
    helper.ensureFlagExists('ignoreText', options);
    helper.ensureFlagExists('ignoreComment', options);
    helper.ensureFlagExists('ignoreCdata', options);
    helper.ensureFlagExists('ignoreDoctype', options);
    helper.ensureFlagExists('compact', options);
    helper.ensureFlagExists('indentText', options);
    helper.ensureFlagExists('indentCdata', options);
    helper.ensureFlagExists('indentAttributes', options);
    helper.ensureFlagExists('indentInstruction', options);
    helper.ensureFlagExists('fullTagEmptyElement', options);
    helper.ensureFlagExists('noQuotesForNativeAttributes', options);
    helper.ensureSpacesExists(options);
    if (typeof options.spaces === 'number') options.spaces = Array(options.spaces + 1).join(' ');
    helper.ensureKeyExists('declaration', options);
    helper.ensureKeyExists('instruction', options);
    helper.ensureKeyExists('attributes', options);
    helper.ensureKeyExists('text', options);
    helper.ensureKeyExists('comment', options);
    helper.ensureKeyExists('cdata', options);
    helper.ensureKeyExists('doctype', options);
    helper.ensureKeyExists('type', options);
    helper.ensureKeyExists('name', options);
    helper.ensureKeyExists('elements', options);
    helper.checkFnExists('doctype', options);
    helper.checkFnExists('instruction', options);
    helper.checkFnExists('cdata', options);
    helper.checkFnExists('comment', options);
    helper.checkFnExists('text', options);
    helper.checkFnExists('instructionName', options);
    helper.checkFnExists('elementName', options);
    helper.checkFnExists('attributeName', options);
    helper.checkFnExists('attributeValue', options);
    helper.checkFnExists('attributes', options);
    helper.checkFnExists('fullTagEmptyElement', options);
    return options;
}
function writeIndentation(options, depth, firstLine) {
    return (!firstLine && options.spaces ? '\n' : '') + Array(depth + 1).join(options.spaces);
}
function writeAttributes(attributes, options, depth) {
    if (options.ignoreAttributes) return '';
    if ('attributesFn' in options) attributes = options.attributesFn(attributes, currentElementName, currentElement);
    var key, attr, attrName, quote, result = [];
    for(key in attributes)if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {
        quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '"';
        attr = '' + attributes[key]; // ensure number and boolean are converted to String
        attr = attr.replace(/"/g, '&quot;');
        attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
        result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : ' ');
        result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
    }
    if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) result.push(writeIndentation(options, depth, false));
    return result.join('');
}
function writeDeclaration(declaration, options, depth) {
    currentElement = declaration;
    currentElementName = 'xml';
    return options.ignoreDeclaration ? '' : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';
}
function writeInstruction(instruction, options, depth) {
    if (options.ignoreInstruction) return '';
    var key;
    for(key in instruction){
        if (instruction.hasOwnProperty(key)) break;
    }
    var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
    if (typeof instruction[key] === 'object') {
        currentElement = instruction;
        currentElementName = instructionName;
        return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';
    } else {
        var instructionValue = instruction[key] ? instruction[key] : '';
        if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
        return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';
    }
}
function writeComment(comment, options) {
    return options.ignoreComment ? '' : '<\!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';
}
function writeCdata(cdata, options) {
    return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';
}
function writeDoctype(doctype, options) {
    return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';
}
function writeText(text, options) {
    if (options.ignoreText) return '';
    text = '' + text; // ensure Number and Boolean are converted to String
    text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization
    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;
}
function hasContent(element, options) {
    var i;
    if (element.elements && element.elements.length) for(i = 0; i < element.elements.length; ++i)switch(element.elements[i][options.typeKey]){
        case 'text':
            if (options.indentText) return true;
            break; // skip to next key
        case 'cdata':
            if (options.indentCdata) return true;
            break; // skip to next key
        case 'instruction':
            if (options.indentInstruction) return true;
            break; // skip to next key
        case 'doctype':
        case 'comment':
        case 'element':
            return true;
        default:
            return true;
    }
    return false;
}
function writeElement(element, options, depth) {
    currentElement = element;
    currentElementName = element.name;
    var xml = [], elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;
    xml.push('<' + elementName);
    if (element[options.attributesKey]) xml.push(writeAttributes(element[options.attributesKey], options, depth));
    var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
    if (!withClosingTag) {
        if ('fullTagEmptyElementFn' in options) withClosingTag = options.fullTagEmptyElementFn(element.name, element);
        else withClosingTag = options.fullTagEmptyElement;
    }
    if (withClosingTag) {
        xml.push('>');
        if (element[options.elementsKey] && element[options.elementsKey].length) {
            xml.push(writeElements(element[options.elementsKey], options, depth + 1));
            currentElement = element;
            currentElementName = element.name;
        }
        xml.push(options.spaces && hasContent(element, options) ? '\n' + Array(depth + 1).join(options.spaces) : '');
        xml.push('</' + elementName + '>');
    } else xml.push('/>');
    return xml.join('');
}
function writeElements(elements, options, depth, firstLine) {
    return elements.reduce(function(xml, element) {
        var indent = writeIndentation(options, depth, firstLine && !xml);
        switch(element.type){
            case 'element':
                return xml + indent + writeElement(element, options, depth);
            case 'comment':
                return xml + indent + writeComment(element[options.commentKey], options);
            case 'doctype':
                return xml + indent + writeDoctype(element[options.doctypeKey], options);
            case 'cdata':
                return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);
            case 'text':
                return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);
            case 'instruction':
                var instruction = {
                };
                instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
                return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);
        }
    }, '');
}
function hasContentCompact(element, options, anyContent) {
    var key;
    for(key in element)if (element.hasOwnProperty(key)) switch(key){
        case options.parentKey:
        case options.attributesKey:
            break; // skip to next key
        case options.textKey:
            if (options.indentText || anyContent) return true;
            break; // skip to next key
        case options.cdataKey:
            if (options.indentCdata || anyContent) return true;
            break; // skip to next key
        case options.instructionKey:
            if (options.indentInstruction || anyContent) return true;
            break; // skip to next key
        case options.doctypeKey:
        case options.commentKey:
            return true;
        default:
            return true;
    }
    return false;
}
function writeElementCompact(element, name, options, depth, indent) {
    currentElement = element;
    currentElementName = name;
    var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;
    if (typeof element === 'undefined' || element === null || element === '') return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';
    var xml = [];
    if (name) {
        xml.push('<' + elementName);
        if (typeof element !== 'object') {
            xml.push('>' + writeText(element, options) + '</' + elementName + '>');
            return xml.join('');
        }
        if (element[options.attributesKey]) xml.push(writeAttributes(element[options.attributesKey], options, depth));
        var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
        if (!withClosingTag) {
            if ('fullTagEmptyElementFn' in options) withClosingTag = options.fullTagEmptyElementFn(name, element);
            else withClosingTag = options.fullTagEmptyElement;
        }
        if (withClosingTag) xml.push('>');
        else {
            xml.push('/>');
            return xml.join('');
        }
    }
    xml.push(writeElementsCompact(element, options, depth + 1, false));
    currentElement = element;
    currentElementName = name;
    if (name) xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');
    return xml.join('');
}
function writeElementsCompact(element, options, depth, firstLine) {
    var i, key, nodes, xml = [];
    for(key in element)if (element.hasOwnProperty(key)) {
        nodes = isArray(element[key]) ? element[key] : [
            element[key]
        ];
        for(i = 0; i < nodes.length; ++i){
            switch(key){
                case options.declarationKey:
                    xml.push(writeDeclaration(nodes[i], options, depth));
                    break;
                case options.instructionKey:
                    xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth));
                    break;
                case options.attributesKey:
                case options.parentKey:
                    break; // skip
                case options.textKey:
                    xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options));
                    break;
                case options.cdataKey:
                    xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options));
                    break;
                case options.doctypeKey:
                    xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
                    break;
                case options.commentKey:
                    xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
                    break;
                default:
                    xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
            }
            firstLine = firstLine && !xml.length;
        }
    }
    return xml.join('');
}
module.exports = function(js, options) {
    options = validateOptions(options);
    var xml = [];
    currentElement = js;
    currentElementName = '_root_';
    if (options.compact) xml.push(writeElementsCompact(js, options, 0, true));
    else {
        if (js[options.declarationKey]) xml.push(writeDeclaration(js[options.declarationKey], options, 0));
        if (js[options.elementsKey] && js[options.elementsKey].length) xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
    }
    return xml.join('');
};

},{"./options-helper":"jReS5","./array-helper":"9HMGN"}],"jFMMv":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var js2xml = require('./js2xml.js');
module.exports = function(json, options) {
    if (json instanceof Buffer) json = json.toString();
    var js = null;
    if (typeof json === 'string') try {
        js = JSON.parse(json);
    } catch (e) {
        throw new Error('The JSON structure is invalid');
    }
    else js = json;
    return js2xml(js, options);
};

},{"buffer":"bOetu","./js2xml.js":"fQpG1"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}]},["4v140","kMRg5"], "kMRg5", "parcelRequire0215")

</script>

</html>